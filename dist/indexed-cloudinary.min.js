!function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = "function" == typeof require && require;
                if (!u && a)return a(o, !0);
                if (i)return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f
            }
            var l = n[o] = {exports: {}};
            t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
    }

    for (var i = "function" == typeof require && require, o = 0; o < r.length; o++)s(r[o]);
    return s
}({
    1: [function (require, module, exports) {
        (function (global) {
            "use strict";
            function rawAsap(task) {
                queue.length || (requestFlush(), flushing = !0), queue[queue.length] = task
            }

            function flush() {
                for (; index < queue.length;) {
                    var currentIndex = index;
                    if (index += 1, queue[currentIndex].call(), index > capacity) {
                        for (var scan = 0, newLength = queue.length - index; newLength > scan; scan++)queue[scan] = queue[scan + index];
                        queue.length -= index, index = 0
                    }
                }
                queue.length = 0, index = 0, flushing = !1
            }

            function makeRequestCallFromMutationObserver(callback) {
                var toggle = 1, observer = new BrowserMutationObserver(callback), node = document.createTextNode("");
                return observer.observe(node, {characterData: !0}), function () {
                    toggle = -toggle, node.data = toggle
                }
            }

            function makeRequestCallFromTimer(callback) {
                return function () {
                    function handleTimer() {
                        clearTimeout(timeoutHandle), clearInterval(intervalHandle), callback()
                    }

                    var timeoutHandle = setTimeout(handleTimer, 0), intervalHandle = setInterval(handleTimer, 50)
                }
            }

            module.exports = rawAsap;
            var requestFlush, queue = [], flushing = !1, index = 0, capacity = 1024, BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;
            requestFlush = "function" == typeof BrowserMutationObserver ? makeRequestCallFromMutationObserver(flush) : makeRequestCallFromTimer(flush), rawAsap.requestFlush = requestFlush, rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    2: [function (require, module, exports) {
        "use strict";
        function init() {
            for (var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; len > i; ++i)lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
            revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63
        }

        function toByteArray(b64) {
            var i, j, l, tmp, placeHolders, arr, len = b64.length;
            if (len % 4 > 0)throw new Error("Invalid string. Length must be a multiple of 4");
            placeHolders = "=" === b64[len - 2] ? 2 : "=" === b64[len - 1] ? 1 : 0, arr = new Arr(3 * len / 4 - placeHolders), l = placeHolders > 0 ? len - 4 : len;
            var L = 0;
            for (i = 0, j = 0; l > i; i += 4, j += 3)tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)], arr[L++] = tmp >> 16 & 255, arr[L++] = tmp >> 8 & 255, arr[L++] = 255 & tmp;
            return 2 === placeHolders ? (tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4, arr[L++] = 255 & tmp) : 1 === placeHolders && (tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2, arr[L++] = tmp >> 8 & 255, arr[L++] = 255 & tmp), arr
        }

        function tripletToBase64(num) {
            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[63 & num]
        }

        function encodeChunk(uint8, start, end) {
            for (var tmp, output = [], i = start; end > i; i += 3)tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2], output.push(tripletToBase64(tmp));
            return output.join("")
        }

        function fromByteArray(uint8) {
            for (var tmp, len = uint8.length, extraBytes = len % 3, output = "", parts = [], maxChunkLength = 16383, i = 0, len2 = len - extraBytes; len2 > i; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
            return 1 === extraBytes ? (tmp = uint8[len - 1], output += lookup[tmp >> 2], output += lookup[tmp << 4 & 63], output += "==") : 2 === extraBytes && (tmp = (uint8[len - 2] << 8) + uint8[len - 1], output += lookup[tmp >> 10], output += lookup[tmp >> 4 & 63], output += lookup[tmp << 2 & 63], output += "="), parts.push(output), parts.join("")
        }

        exports.toByteArray = toByteArray, exports.fromByteArray = fromByteArray;
        var lookup = [], revLookup = [], Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array;
        init()
    }, {}],
    3: [function (require, module, exports) {
        (function (global) {
            "use strict";
            function typedArraySupport() {
                try {
                    var arr = new Uint8Array(1);
                    return arr.foo = function () {
                        return 42
                    }, 42 === arr.foo() && "function" == typeof arr.subarray && 0 === arr.subarray(1, 1).byteLength
                } catch (e) {
                    return !1
                }
            }

            function kMaxLength() {
                return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
            }

            function createBuffer(that, length) {
                if (kMaxLength() < length)throw new RangeError("Invalid typed array length");
                return Buffer.TYPED_ARRAY_SUPPORT ? (that = new Uint8Array(length), that.__proto__ = Buffer.prototype) : (null === that && (that = new Buffer(length)), that.length = length), that
            }

            function Buffer(arg, encodingOrOffset, length) {
                if (!(Buffer.TYPED_ARRAY_SUPPORT || this instanceof Buffer))return new Buffer(arg, encodingOrOffset, length);
                if ("number" == typeof arg) {
                    if ("string" == typeof encodingOrOffset)throw new Error("If encoding is specified then the first argument must be a string");
                    return allocUnsafe(this, arg)
                }
                return from(this, arg, encodingOrOffset, length)
            }

            function from(that, value, encodingOrOffset, length) {
                if ("number" == typeof value)throw new TypeError('"value" argument must not be a number');
                return "undefined" != typeof ArrayBuffer && value instanceof ArrayBuffer ? fromArrayBuffer(that, value, encodingOrOffset, length) : "string" == typeof value ? fromString(that, value, encodingOrOffset) : fromObject(that, value)
            }

            function assertSize(size) {
                if ("number" != typeof size)throw new TypeError('"size" argument must be a number')
            }

            function alloc(that, size, fill, encoding) {
                return assertSize(size), 0 >= size ? createBuffer(that, size) : void 0 !== fill ? "string" == typeof encoding ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill) : createBuffer(that, size)
            }

            function allocUnsafe(that, size) {
                if (assertSize(size), that = createBuffer(that, 0 > size ? 0 : 0 | checked(size)), !Buffer.TYPED_ARRAY_SUPPORT)for (var i = 0; size > i; i++)that[i] = 0;
                return that
            }

            function fromString(that, string, encoding) {
                if ("string" == typeof encoding && "" !== encoding || (encoding = "utf8"), !Buffer.isEncoding(encoding))throw new TypeError('"encoding" must be a valid string encoding');
                var length = 0 | byteLength(string, encoding);
                return that = createBuffer(that, length), that.write(string, encoding), that
            }

            function fromArrayLike(that, array) {
                var length = 0 | checked(array.length);
                that = createBuffer(that, length);
                for (var i = 0; length > i; i += 1)that[i] = 255 & array[i];
                return that
            }

            function fromArrayBuffer(that, array, byteOffset, length) {
                if (array.byteLength, 0 > byteOffset || array.byteLength < byteOffset)throw new RangeError("'offset' is out of bounds");
                if (array.byteLength < byteOffset + (length || 0))throw new RangeError("'length' is out of bounds");
                return array = void 0 === length ? new Uint8Array(array, byteOffset) : new Uint8Array(array, byteOffset, length), Buffer.TYPED_ARRAY_SUPPORT ? (that = array, that.__proto__ = Buffer.prototype) : that = fromArrayLike(that, array), that
            }

            function fromObject(that, obj) {
                if (Buffer.isBuffer(obj)) {
                    var len = 0 | checked(obj.length);
                    return that = createBuffer(that, len), 0 === that.length ? that : (obj.copy(that, 0, 0, len), that)
                }
                if (obj) {
                    if ("undefined" != typeof ArrayBuffer && obj.buffer instanceof ArrayBuffer || "length" in obj)return "number" != typeof obj.length || isnan(obj.length) ? createBuffer(that, 0) : fromArrayLike(that, obj);
                    if ("Buffer" === obj.type && isArray(obj.data))return fromArrayLike(that, obj.data)
                }
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
            }

            function checked(length) {
                if (length >= kMaxLength())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
                return 0 | length
            }

            function SlowBuffer(length) {
                return +length != length && (length = 0), Buffer.alloc(+length)
            }

            function byteLength(string, encoding) {
                if (Buffer.isBuffer(string))return string.length;
                if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer))return string.byteLength;
                "string" != typeof string && (string = "" + string);
                var len = string.length;
                if (0 === len)return 0;
                for (var loweredCase = !1; ;)switch (encoding) {
                    case"ascii":
                    case"binary":
                    case"raw":
                    case"raws":
                        return len;
                    case"utf8":
                    case"utf-8":
                    case void 0:
                        return utf8ToBytes(string).length;
                    case"ucs2":
                    case"ucs-2":
                    case"utf16le":
                    case"utf-16le":
                        return 2 * len;
                    case"hex":
                        return len >>> 1;
                    case"base64":
                        return base64ToBytes(string).length;
                    default:
                        if (loweredCase)return utf8ToBytes(string).length;
                        encoding = ("" + encoding).toLowerCase(), loweredCase = !0
                }
            }

            function slowToString(encoding, start, end) {
                var loweredCase = !1;
                if ((void 0 === start || 0 > start) && (start = 0), start > this.length)return "";
                if ((void 0 === end || end > this.length) && (end = this.length), 0 >= end)return "";
                if (end >>>= 0, start >>>= 0, start >= end)return "";
                for (encoding || (encoding = "utf8"); ;)switch (encoding) {
                    case"hex":
                        return hexSlice(this, start, end);
                    case"utf8":
                    case"utf-8":
                        return utf8Slice(this, start, end);
                    case"ascii":
                        return asciiSlice(this, start, end);
                    case"binary":
                        return binarySlice(this, start, end);
                    case"base64":
                        return base64Slice(this, start, end);
                    case"ucs2":
                    case"ucs-2":
                    case"utf16le":
                    case"utf-16le":
                        return utf16leSlice(this, start, end);
                    default:
                        if (loweredCase)throw new TypeError("Unknown encoding: " + encoding);
                        encoding = (encoding + "").toLowerCase(), loweredCase = !0
                }
            }

            function swap(b, n, m) {
                var i = b[n];
                b[n] = b[m], b[m] = i
            }

            function arrayIndexOf(arr, val, byteOffset, encoding) {
                function read(buf, i) {
                    return 1 === indexSize ? buf[i] : buf.readUInt16BE(i * indexSize)
                }

                var indexSize = 1, arrLength = arr.length, valLength = val.length;
                if (void 0 !== encoding && (encoding = String(encoding).toLowerCase(), "ucs2" === encoding || "ucs-2" === encoding || "utf16le" === encoding || "utf-16le" === encoding)) {
                    if (arr.length < 2 || val.length < 2)return -1;
                    indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2
                }
                for (var foundIndex = -1, i = 0; arrLength > byteOffset + i; i++)if (read(arr, byteOffset + i) === read(val, -1 === foundIndex ? 0 : i - foundIndex)) {
                    if (-1 === foundIndex && (foundIndex = i), i - foundIndex + 1 === valLength)return (byteOffset + foundIndex) * indexSize
                } else-1 !== foundIndex && (i -= i - foundIndex), foundIndex = -1;
                return -1
            }

            function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                var remaining = buf.length - offset;
                length ? (length = Number(length), length > remaining && (length = remaining)) : length = remaining;
                var strLen = string.length;
                if (strLen % 2 !== 0)throw new Error("Invalid hex string");
                length > strLen / 2 && (length = strLen / 2);
                for (var i = 0; length > i; i++) {
                    var parsed = parseInt(string.substr(2 * i, 2), 16);
                    if (isNaN(parsed))return i;
                    buf[offset + i] = parsed
                }
                return i
            }

            function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
            }

            function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length)
            }

            function binaryWrite(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length)
            }

            function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length)
            }

            function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
            }

            function base64Slice(buf, start, end) {
                return 0 === start && end === buf.length ? base64.fromByteArray(buf) : base64.fromByteArray(buf.slice(start, end))
            }

            function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                for (var res = [], i = start; end > i;) {
                    var firstByte = buf[i], codePoint = null, bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                    if (end >= i + bytesPerSequence) {
                        var secondByte, thirdByte, fourthByte, tempCodePoint;
                        switch (bytesPerSequence) {
                            case 1:
                                128 > firstByte && (codePoint = firstByte);
                                break;
                            case 2:
                                secondByte = buf[i + 1], 128 === (192 & secondByte) && (tempCodePoint = (31 & firstByte) << 6 | 63 & secondByte, tempCodePoint > 127 && (codePoint = tempCodePoint));
                                break;
                            case 3:
                                secondByte = buf[i + 1], thirdByte = buf[i + 2], 128 === (192 & secondByte) && 128 === (192 & thirdByte) && (tempCodePoint = (15 & firstByte) << 12 | (63 & secondByte) << 6 | 63 & thirdByte, tempCodePoint > 2047 && (55296 > tempCodePoint || tempCodePoint > 57343) && (codePoint = tempCodePoint));
                                break;
                            case 4:
                                secondByte = buf[i + 1], thirdByte = buf[i + 2], fourthByte = buf[i + 3], 128 === (192 & secondByte) && 128 === (192 & thirdByte) && 128 === (192 & fourthByte) && (tempCodePoint = (15 & firstByte) << 18 | (63 & secondByte) << 12 | (63 & thirdByte) << 6 | 63 & fourthByte, tempCodePoint > 65535 && 1114112 > tempCodePoint && (codePoint = tempCodePoint))
                        }
                    }
                    null === codePoint ? (codePoint = 65533, bytesPerSequence = 1) : codePoint > 65535 && (codePoint -= 65536, res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | 1023 & codePoint), res.push(codePoint), i += bytesPerSequence
                }
                return decodeCodePointsArray(res)
            }

            function decodeCodePointsArray(codePoints) {
                var len = codePoints.length;
                if (MAX_ARGUMENTS_LENGTH >= len)return String.fromCharCode.apply(String, codePoints);
                for (var res = "", i = 0; len > i;)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                return res
            }

            function asciiSlice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; end > i; i++)ret += String.fromCharCode(127 & buf[i]);
                return ret
            }

            function binarySlice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; end > i; i++)ret += String.fromCharCode(buf[i]);
                return ret
            }

            function hexSlice(buf, start, end) {
                var len = buf.length;
                (!start || 0 > start) && (start = 0), (!end || 0 > end || end > len) && (end = len);
                for (var out = "", i = start; end > i; i++)out += toHex(buf[i]);
                return out
            }

            function utf16leSlice(buf, start, end) {
                for (var bytes = buf.slice(start, end), res = "", i = 0; i < bytes.length; i += 2)res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
                return res
            }

            function checkOffset(offset, ext, length) {
                if (offset % 1 !== 0 || 0 > offset)throw new RangeError("offset is not uint");
                if (offset + ext > length)throw new RangeError("Trying to access beyond buffer length")
            }

            function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf))throw new TypeError('"buffer" argument must be a Buffer instance');
                if (value > max || min > value)throw new RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length)throw new RangeError("Index out of range")
            }

            function objectWriteUInt16(buf, value, offset, littleEndian) {
                0 > value && (value = 65535 + value + 1);
                for (var i = 0, j = Math.min(buf.length - offset, 2); j > i; i++)buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> 8 * (littleEndian ? i : 1 - i)
            }

            function objectWriteUInt32(buf, value, offset, littleEndian) {
                0 > value && (value = 4294967295 + value + 1);
                for (var i = 0, j = Math.min(buf.length - offset, 4); j > i; i++)buf[offset + i] = value >>> 8 * (littleEndian ? i : 3 - i) & 255
            }

            function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length)throw new RangeError("Index out of range");
                if (0 > offset)throw new RangeError("Index out of range")
            }

            function writeFloat(buf, value, offset, littleEndian, noAssert) {
                return noAssert || checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38), ieee754.write(buf, value, offset, littleEndian, 23, 4), offset + 4
            }

            function writeDouble(buf, value, offset, littleEndian, noAssert) {
                return noAssert || checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308), ieee754.write(buf, value, offset, littleEndian, 52, 8), offset + 8
            }

            function base64clean(str) {
                if (str = stringtrim(str).replace(INVALID_BASE64_RE, ""), str.length < 2)return "";
                for (; str.length % 4 !== 0;)str += "=";
                return str
            }

            function stringtrim(str) {
                return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "")
            }

            function toHex(n) {
                return 16 > n ? "0" + n.toString(16) : n.toString(16)
            }

            function utf8ToBytes(string, units) {
                units = units || 1 / 0;
                for (var codePoint, length = string.length, leadSurrogate = null, bytes = [], i = 0; length > i; i++) {
                    if (codePoint = string.charCodeAt(i), codePoint > 55295 && 57344 > codePoint) {
                        if (!leadSurrogate) {
                            if (codePoint > 56319) {
                                (units -= 3) > -1 && bytes.push(239, 191, 189);
                                continue
                            }
                            if (i + 1 === length) {
                                (units -= 3) > -1 && bytes.push(239, 191, 189);
                                continue
                            }
                            leadSurrogate = codePoint;
                            continue
                        }
                        if (56320 > codePoint) {
                            (units -= 3) > -1 && bytes.push(239, 191, 189), leadSurrogate = codePoint;
                            continue
                        }
                        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536
                    } else leadSurrogate && (units -= 3) > -1 && bytes.push(239, 191, 189);
                    if (leadSurrogate = null, 128 > codePoint) {
                        if ((units -= 1) < 0)break;
                        bytes.push(codePoint)
                    } else if (2048 > codePoint) {
                        if ((units -= 2) < 0)break;
                        bytes.push(codePoint >> 6 | 192, 63 & codePoint | 128)
                    } else if (65536 > codePoint) {
                        if ((units -= 3) < 0)break;
                        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, 63 & codePoint | 128)
                    } else {
                        if (!(1114112 > codePoint))throw new Error("Invalid code point");
                        if ((units -= 4) < 0)break;
                        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, 63 & codePoint | 128)
                    }
                }
                return bytes
            }

            function asciiToBytes(str) {
                for (var byteArray = [], i = 0; i < str.length; i++)byteArray.push(255 & str.charCodeAt(i));
                return byteArray
            }

            function utf16leToBytes(str, units) {
                for (var c, hi, lo, byteArray = [], i = 0; i < str.length && !((units -= 2) < 0); i++)c = str.charCodeAt(i), hi = c >> 8, lo = c % 256, byteArray.push(lo), byteArray.push(hi);
                return byteArray
            }

            function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str))
            }

            function blitBuffer(src, dst, offset, length) {
                for (var i = 0; length > i && !(i + offset >= dst.length || i >= src.length); i++)dst[i + offset] = src[i];
                return i
            }

            function isnan(val) {
                return val !== val
            }

            var base64 = require("base64-js"), ieee754 = require("ieee754"), isArray = require("isarray");
            exports.Buffer = Buffer, exports.SlowBuffer = SlowBuffer, exports.INSPECT_MAX_BYTES = 50, Buffer.TYPED_ARRAY_SUPPORT = void 0 !== global.TYPED_ARRAY_SUPPORT ? global.TYPED_ARRAY_SUPPORT : typedArraySupport(), exports.kMaxLength = kMaxLength(), Buffer.poolSize = 8192, Buffer._augment = function (arr) {
                return arr.__proto__ = Buffer.prototype, arr
            }, Buffer.from = function (value, encodingOrOffset, length) {
                return from(null, value, encodingOrOffset, length)
            }, Buffer.TYPED_ARRAY_SUPPORT && (Buffer.prototype.__proto__ = Uint8Array.prototype, Buffer.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && Buffer[Symbol.species] === Buffer && Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: !0
            })), Buffer.alloc = function (size, fill, encoding) {
                return alloc(null, size, fill, encoding)
            }, Buffer.allocUnsafe = function (size) {
                return allocUnsafe(null, size)
            }, Buffer.allocUnsafeSlow = function (size) {
                return allocUnsafe(null, size)
            }, Buffer.isBuffer = function (b) {
                return !(null == b || !b._isBuffer)
            }, Buffer.compare = function (a, b) {
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))throw new TypeError("Arguments must be Buffers");
                if (a === b)return 0;
                for (var x = a.length, y = b.length, i = 0, len = Math.min(x, y); len > i; ++i)if (a[i] !== b[i]) {
                    x = a[i], y = b[i];
                    break
                }
                return y > x ? -1 : x > y ? 1 : 0
            }, Buffer.isEncoding = function (encoding) {
                switch (String(encoding).toLowerCase()) {
                    case"hex":
                    case"utf8":
                    case"utf-8":
                    case"ascii":
                    case"binary":
                    case"base64":
                    case"raw":
                    case"ucs2":
                    case"ucs-2":
                    case"utf16le":
                    case"utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, Buffer.concat = function (list, length) {
                if (!isArray(list))throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === list.length)return Buffer.alloc(0);
                var i;
                if (void 0 === length)for (length = 0, i = 0; i < list.length; i++)length += list[i].length;
                var buffer = Buffer.allocUnsafe(length), pos = 0;
                for (i = 0; i < list.length; i++) {
                    var buf = list[i];
                    if (!Buffer.isBuffer(buf))throw new TypeError('"list" argument must be an Array of Buffers');
                    buf.copy(buffer, pos), pos += buf.length
                }
                return buffer
            }, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function () {
                var len = this.length;
                if (len % 2 !== 0)throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (var i = 0; len > i; i += 2)swap(this, i, i + 1);
                return this
            }, Buffer.prototype.swap32 = function () {
                var len = this.length;
                if (len % 4 !== 0)throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (var i = 0; len > i; i += 4)swap(this, i, i + 3), swap(this, i + 1, i + 2);
                return this
            }, Buffer.prototype.toString = function () {
                var length = 0 | this.length;
                return 0 === length ? "" : 0 === arguments.length ? utf8Slice(this, 0, length) : slowToString.apply(this, arguments)
            }, Buffer.prototype.equals = function (b) {
                if (!Buffer.isBuffer(b))throw new TypeError("Argument must be a Buffer");
                return this === b ? !0 : 0 === Buffer.compare(this, b)
            }, Buffer.prototype.inspect = function () {
                var str = "", max = exports.INSPECT_MAX_BYTES;
                return this.length > 0 && (str = this.toString("hex", 0, max).match(/.{2}/g).join(" "), this.length > max && (str += " ... ")), "<Buffer " + str + ">"
            }, Buffer.prototype.compare = function (target, start, end, thisStart, thisEnd) {
                if (!Buffer.isBuffer(target))throw new TypeError("Argument must be a Buffer");
                if (void 0 === start && (start = 0), void 0 === end && (end = target ? target.length : 0), void 0 === thisStart && (thisStart = 0), void 0 === thisEnd && (thisEnd = this.length), 0 > start || end > target.length || 0 > thisStart || thisEnd > this.length)throw new RangeError("out of range index");
                if (thisStart >= thisEnd && start >= end)return 0;
                if (thisStart >= thisEnd)return -1;
                if (start >= end)return 1;
                if (start >>>= 0, end >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target)return 0;
                for (var x = thisEnd - thisStart, y = end - start, len = Math.min(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end), i = 0; len > i; ++i)if (thisCopy[i] !== targetCopy[i]) {
                    x = thisCopy[i], y = targetCopy[i];
                    break
                }
                return y > x ? -1 : x > y ? 1 : 0
            }, Buffer.prototype.indexOf = function (val, byteOffset, encoding) {
                if ("string" == typeof byteOffset ? (encoding = byteOffset, byteOffset = 0) : byteOffset > 2147483647 ? byteOffset = 2147483647 : -2147483648 > byteOffset && (byteOffset = -2147483648), byteOffset >>= 0, 0 === this.length)return -1;
                if (byteOffset >= this.length)return -1;
                if (0 > byteOffset && (byteOffset = Math.max(this.length + byteOffset, 0)), "string" == typeof val && (val = Buffer.from(val, encoding)), Buffer.isBuffer(val))return 0 === val.length ? -1 : arrayIndexOf(this, val, byteOffset, encoding);
                if ("number" == typeof val)return Buffer.TYPED_ARRAY_SUPPORT && "function" === Uint8Array.prototype.indexOf ? Uint8Array.prototype.indexOf.call(this, val, byteOffset) : arrayIndexOf(this, [val], byteOffset, encoding);
                throw new TypeError("val must be string, number or Buffer")
            }, Buffer.prototype.includes = function (val, byteOffset, encoding) {
                return -1 !== this.indexOf(val, byteOffset, encoding)
            }, Buffer.prototype.write = function (string, offset, length, encoding) {
                if (void 0 === offset)encoding = "utf8", length = this.length, offset = 0; else if (void 0 === length && "string" == typeof offset)encoding = offset, length = this.length, offset = 0; else {
                    if (!isFinite(offset))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    offset = 0 | offset, isFinite(length) ? (length = 0 | length, void 0 === encoding && (encoding = "utf8")) : (encoding = length, length = void 0)
                }
                var remaining = this.length - offset;
                if ((void 0 === length || length > remaining) && (length = remaining), string.length > 0 && (0 > length || 0 > offset) || offset > this.length)throw new RangeError("Attempt to write outside buffer bounds");
                encoding || (encoding = "utf8");
                for (var loweredCase = !1; ;)switch (encoding) {
                    case"hex":
                        return hexWrite(this, string, offset, length);
                    case"utf8":
                    case"utf-8":
                        return utf8Write(this, string, offset, length);
                    case"ascii":
                        return asciiWrite(this, string, offset, length);
                    case"binary":
                        return binaryWrite(this, string, offset, length);
                    case"base64":
                        return base64Write(this, string, offset, length);
                    case"ucs2":
                    case"ucs-2":
                    case"utf16le":
                    case"utf-16le":
                        return ucs2Write(this, string, offset, length);
                    default:
                        if (loweredCase)throw new TypeError("Unknown encoding: " + encoding);
                        encoding = ("" + encoding).toLowerCase(), loweredCase = !0
                }
            }, Buffer.prototype.toJSON = function () {
                return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)}
            };
            var MAX_ARGUMENTS_LENGTH = 4096;
            Buffer.prototype.slice = function (start, end) {
                var len = this.length;
                start = ~~start, end = void 0 === end ? len : ~~end, 0 > start ? (start += len, 0 > start && (start = 0)) : start > len && (start = len), 0 > end ? (end += len, 0 > end && (end = 0)) : end > len && (end = len), start > end && (end = start);
                var newBuf;
                if (Buffer.TYPED_ARRAY_SUPPORT)newBuf = this.subarray(start, end), newBuf.__proto__ = Buffer.prototype; else {
                    var sliceLen = end - start;
                    newBuf = new Buffer(sliceLen, void 0);
                    for (var i = 0; sliceLen > i; i++)newBuf[i] = this[i + start]
                }
                return newBuf
            }, Buffer.prototype.readUIntLE = function (offset, byteLength, noAssert) {
                offset = 0 | offset, byteLength = 0 | byteLength, noAssert || checkOffset(offset, byteLength, this.length);
                for (var val = this[offset], mul = 1, i = 0; ++i < byteLength && (mul *= 256);)val += this[offset + i] * mul;
                return val
            }, Buffer.prototype.readUIntBE = function (offset, byteLength, noAssert) {
                offset = 0 | offset, byteLength = 0 | byteLength, noAssert || checkOffset(offset, byteLength, this.length);
                for (var val = this[offset + --byteLength], mul = 1; byteLength > 0 && (mul *= 256);)val += this[offset + --byteLength] * mul;
                return val
            }, Buffer.prototype.readUInt8 = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 1, this.length), this[offset]
            }, Buffer.prototype.readUInt16LE = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 2, this.length), this[offset] | this[offset + 1] << 8
            }, Buffer.prototype.readUInt16BE = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 2, this.length), this[offset] << 8 | this[offset + 1]
            }, Buffer.prototype.readUInt32LE = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 4, this.length), (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + 16777216 * this[offset + 3]
            }, Buffer.prototype.readUInt32BE = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 4, this.length), 16777216 * this[offset] + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3])
            }, Buffer.prototype.readIntLE = function (offset, byteLength, noAssert) {
                offset = 0 | offset, byteLength = 0 | byteLength, noAssert || checkOffset(offset, byteLength, this.length);
                for (var val = this[offset], mul = 1, i = 0; ++i < byteLength && (mul *= 256);)val += this[offset + i] * mul;
                return mul *= 128, val >= mul && (val -= Math.pow(2, 8 * byteLength)), val
            }, Buffer.prototype.readIntBE = function (offset, byteLength, noAssert) {
                offset = 0 | offset, byteLength = 0 | byteLength, noAssert || checkOffset(offset, byteLength, this.length);
                for (var i = byteLength, mul = 1, val = this[offset + --i]; i > 0 && (mul *= 256);)val += this[offset + --i] * mul;
                return mul *= 128, val >= mul && (val -= Math.pow(2, 8 * byteLength)), val
            }, Buffer.prototype.readInt8 = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 1, this.length), 128 & this[offset] ? -1 * (255 - this[offset] + 1) : this[offset]
            }, Buffer.prototype.readInt16LE = function (offset, noAssert) {
                noAssert || checkOffset(offset, 2, this.length);
                var val = this[offset] | this[offset + 1] << 8;
                return 32768 & val ? 4294901760 | val : val
            }, Buffer.prototype.readInt16BE = function (offset, noAssert) {
                noAssert || checkOffset(offset, 2, this.length);
                var val = this[offset + 1] | this[offset] << 8;
                return 32768 & val ? 4294901760 | val : val
            }, Buffer.prototype.readInt32LE = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 4, this.length), this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24
            }, Buffer.prototype.readInt32BE = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 4, this.length), this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]
            }, Buffer.prototype.readFloatLE = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !0, 23, 4)
            }, Buffer.prototype.readFloatBE = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !1, 23, 4)
            }, Buffer.prototype.readDoubleLE = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !0, 52, 8)
            }, Buffer.prototype.readDoubleBE = function (offset, noAssert) {
                return noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !1, 52, 8)
            }, Buffer.prototype.writeUIntLE = function (value, offset, byteLength, noAssert) {
                if (value = +value, offset = 0 | offset, byteLength = 0 | byteLength, !noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                }
                var mul = 1, i = 0;
                for (this[offset] = 255 & value; ++i < byteLength && (mul *= 256);)this[offset + i] = value / mul & 255;
                return offset + byteLength
            }, Buffer.prototype.writeUIntBE = function (value, offset, byteLength, noAssert) {
                if (value = +value, offset = 0 | offset, byteLength = 0 | byteLength, !noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                }
                var i = byteLength - 1, mul = 1;
                for (this[offset + i] = 255 & value; --i >= 0 && (mul *= 256);)this[offset + i] = value / mul & 255;
                return offset + byteLength
            }, Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
                return value = +value, offset = 0 | offset, noAssert || checkInt(this, value, offset, 1, 255, 0), Buffer.TYPED_ARRAY_SUPPORT || (value = Math.floor(value)), this[offset] = 255 & value, offset + 1
            }, Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
                return value = +value, offset = 0 | offset, noAssert || checkInt(this, value, offset, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = 255 & value, this[offset + 1] = value >>> 8) : objectWriteUInt16(this, value, offset, !0), offset + 2
            }, Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
                return value = +value, offset = 0 | offset, noAssert || checkInt(this, value, offset, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 8, this[offset + 1] = 255 & value) : objectWriteUInt16(this, value, offset, !1), offset + 2
            }, Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
                return value = +value, offset = 0 | offset, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, this[offset] = 255 & value) : objectWriteUInt32(this, value, offset, !0), offset + 4
            }, Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
                return value = +value, offset = 0 | offset, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = 255 & value) : objectWriteUInt32(this, value, offset, !1), offset + 4
            }, Buffer.prototype.writeIntLE = function (value, offset, byteLength, noAssert) {
                if (value = +value, offset = 0 | offset, !noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }
                var i = 0, mul = 1, sub = 0;
                for (this[offset] = 255 & value; ++i < byteLength && (mul *= 256);)0 > value && 0 === sub && 0 !== this[offset + i - 1] && (sub = 1), this[offset + i] = (value / mul >> 0) - sub & 255;
                return offset + byteLength
            }, Buffer.prototype.writeIntBE = function (value, offset, byteLength, noAssert) {
                if (value = +value, offset = 0 | offset, !noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }
                var i = byteLength - 1, mul = 1, sub = 0;
                for (this[offset + i] = 255 & value; --i >= 0 && (mul *= 256);)0 > value && 0 === sub && 0 !== this[offset + i + 1] && (sub = 1), this[offset + i] = (value / mul >> 0) - sub & 255;
                return offset + byteLength
            }, Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
                return value = +value, offset = 0 | offset, noAssert || checkInt(this, value, offset, 1, 127, -128), Buffer.TYPED_ARRAY_SUPPORT || (value = Math.floor(value)), 0 > value && (value = 255 + value + 1), this[offset] = 255 & value, offset + 1
            }, Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
                return value = +value, offset = 0 | offset, noAssert || checkInt(this, value, offset, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = 255 & value, this[offset + 1] = value >>> 8) : objectWriteUInt16(this, value, offset, !0), offset + 2
            }, Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
                return value = +value, offset = 0 | offset, noAssert || checkInt(this, value, offset, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 8, this[offset + 1] = 255 & value) : objectWriteUInt16(this, value, offset, !1), offset + 2
            }, Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
                return value = +value, offset = 0 | offset, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = 255 & value, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, this[offset + 3] = value >>> 24) : objectWriteUInt32(this, value, offset, !0), offset + 4
            }, Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
                return value = +value, offset = 0 | offset, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), 0 > value && (value = 4294967295 + value + 1), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = 255 & value) : objectWriteUInt32(this, value, offset, !1), offset + 4
            }, Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
                return writeFloat(this, value, offset, !0, noAssert)
            }, Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
                return writeFloat(this, value, offset, !1, noAssert)
            }, Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
                return writeDouble(this, value, offset, !0, noAssert)
            }, Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
                return writeDouble(this, value, offset, !1, noAssert)
            }, Buffer.prototype.copy = function (target, targetStart, start, end) {
                if (start || (start = 0), end || 0 === end || (end = this.length), targetStart >= target.length && (targetStart = target.length), targetStart || (targetStart = 0), end > 0 && start > end && (end = start), end === start)return 0;
                if (0 === target.length || 0 === this.length)return 0;
                if (0 > targetStart)throw new RangeError("targetStart out of bounds");
                if (0 > start || start >= this.length)throw new RangeError("sourceStart out of bounds");
                if (0 > end)throw new RangeError("sourceEnd out of bounds");
                end > this.length && (end = this.length), target.length - targetStart < end - start && (end = target.length - targetStart + start);
                var i, len = end - start;
                if (this === target && targetStart > start && end > targetStart)for (i = len - 1; i >= 0; i--)target[i + targetStart] = this[i + start]; else if (1e3 > len || !Buffer.TYPED_ARRAY_SUPPORT)for (i = 0; len > i; i++)target[i + targetStart] = this[i + start]; else Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
                return len
            }, Buffer.prototype.fill = function (val, start, end, encoding) {
                if ("string" == typeof val) {
                    if ("string" == typeof start ? (encoding = start, start = 0, end = this.length) : "string" == typeof end && (encoding = end, end = this.length), 1 === val.length) {
                        var code = val.charCodeAt(0);
                        256 > code && (val = code)
                    }
                    if (void 0 !== encoding && "string" != typeof encoding)throw new TypeError("encoding must be a string");
                    if ("string" == typeof encoding && !Buffer.isEncoding(encoding))throw new TypeError("Unknown encoding: " + encoding)
                } else"number" == typeof val && (val = 255 & val);
                if (0 > start || this.length < start || this.length < end)throw new RangeError("Out of range index");
                if (start >= end)return this;
                start >>>= 0, end = void 0 === end ? this.length : end >>> 0, val || (val = 0);
                var i;
                if ("number" == typeof val)for (i = start; end > i; i++)this[i] = val; else {
                    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString()), len = bytes.length;
                    for (i = 0; end - start > i; i++)this[i + start] = bytes[i % len]
                }
                return this
            };
            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {"base64-js": 2, ieee754: 40, isarray: 43}],
    4: [function (require, module, exports) {
        (function (process) {
            var extend = function (child, parent) {
                function ctor() {
                    this.constructor = child
                }

                for (var key in parent)hasProp.call(parent, key) && (child[key] = parent[key]);
                return ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype, child
            }, hasProp = {}.hasOwnProperty;
            !function (root, factory) {
                return "function" == typeof define && define.amd ? define(["lodash"], factory) : "object" == typeof exports ? module.exports = factory(require("lodash")) : (root.cloudinary || (root.cloudinary = {}), root.cloudinary = factory(_))
            }(this, function (_) {
                var ArrayParam, Cloudinary, Condition, Configuration, HtmlTag, ImageTag, Param, RangeParam, RawParam, Transformation, TransformationBase, TransformationParam, Util, VideoTag, addClass, allStrings, augmentWidthOrHeight, cloudinary, contains, crc32, cssExpand, cssValue, curCSS, domStyle, getAttribute, getData, getStyles, getWidthOrHeight, hasClass, parameters, pnum, removeAttribute, rnumnonpx, setAttribute, setAttributes, setData, utf8_encode, width, without;
                return getData = function (element, name) {
                    return _.isElement(element) ? element.getAttribute("data-" + name) : void 0
                }, setData = function (element, name, value) {
                    return _.isElement(element) ? element.setAttribute("data-" + name, value) : void 0
                }, getAttribute = function (element, name) {
                    return _.isElement(element) ? element.getAttribute(name) : void 0
                }, setAttribute = function (element, name, value) {
                    return _.isElement(element) ? element.setAttribute(name, value) : void 0
                }, removeAttribute = function (element, name) {
                    return _.isElement(element) ? element.removeAttribute(name) : void 0
                }, setAttributes = function (element, attributes) {
                    var name, results, value;
                    results = [];
                    for (name in attributes)value = attributes[name], null != value ? results.push(setAttribute(element, name, value)) : results.push(element.removeAttribute(name));
                    return results
                }, hasClass = function (element, name) {
                    return _.isElement(element) ? element.className.match(new RegExp("\\b" + name + "\\b")) : void 0
                }, addClass = function (element, name) {
                    return element.className.match(new RegExp("\\b" + name + "\\b")) ? void 0 : element.className = _.trim(element.className + " " + name)
                }, getStyles = function (elem) {
                    return elem.ownerDocument.defaultView.opener ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : window.getComputedStyle(elem, null)
                }, cssExpand = ["Top", "Right", "Bottom", "Left"], contains = function (a, b) {
                    var adown, bup;
                    return adown = 9 === a.nodeType ? a.documentElement : a, bup = b && b.parentNode, a === bup || !(!bup || 1 !== bup.nodeType || !adown.contains(bup))
                }, domStyle = function (elem, name) {
                    return elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style ? elem.style[name] : void 0
                }, curCSS = function (elem, name, computed) {
                    var maxWidth, minWidth, ret, style, width;
                    return width = void 0, minWidth = void 0, maxWidth = void 0, ret = void 0, style = elem.style, computed = computed || getStyles(elem), computed && (ret = computed.getPropertyValue(name) || computed[name]), computed && ("" !== ret || contains(elem.ownerDocument, elem) || (ret = domStyle(elem, name)), rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), void 0 !== ret ? ret + "" : ret
                }, cssValue = function (elem, name, convert, styles) {
                    var val;
                    return val = curCSS(elem, name, styles), convert ? parseFloat(val) : val
                }, augmentWidthOrHeight = function (elem, name, extra, isBorderBox, styles) {
                    var j, len, side, sides, val;
                    if (extra === (isBorderBox ? "border" : "content"))return 0;
                    for (sides = "width" === name ? ["Right", "Left"] : ["Top", "Bottom"], val = 0, j = 0, len = sides.length; len > j; j++)side = sides[j], "margin" === extra && (val += cssValue(elem, extra + side, !0, styles)), isBorderBox ? ("content" === extra && (val -= cssValue(elem, "padding" + side, !0, styles)), "margin" !== extra && (val -= cssValue(elem, "border" + side + "Width", !0, styles))) : (val += cssValue(elem, "padding" + side, !0, styles), "padding" !== extra && (val += cssValue(elem, "border" + side + "Width", !0, styles)));
                    return val
                }, pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"), getWidthOrHeight = function (elem, name, extra) {
                    var isBorderBox, styles, val, valueIsBorderBox;
                    if (valueIsBorderBox = !0, val = "width" === name ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = "border-box" === cssValue(elem, "boxSizing", !1, styles), 0 >= val || null == val) {
                        if (val = curCSS(elem, name, styles), (0 > val || null == val) && (val = elem.style[name]), rnumnonpx.test(val))return val;
                        valueIsBorderBox = isBorderBox && val === elem.style[name], val = parseFloat(val) || 0
                    }
                    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)
                }, width = function (element) {
                    return getWidthOrHeight(element, "width", "content")
                }, allStrings = function (list) {
                    var item, j, len;
                    for (j = 0, len = list.length; len > j; j++)if (item = list[j], !Util.isString(item))return !1;
                    return !0
                }, without = function (array, item) {
                    var i, length, newArray;
                    for (newArray = [], i = -1, length = array.length; ++i < length;)array[i] !== item && newArray.push(array[i]);
                    return newArray
                }, Util = {
                    hasClass: hasClass,
                    addClass: addClass,
                    getAttribute: getAttribute,
                    setAttribute: setAttribute,
                    removeAttribute: removeAttribute,
                    setAttributes: setAttributes,
                    getData: getData,
                    setData: setData,
                    width: width,
                    allStrings: allStrings,
                    isString: _.isString,
                    isArray: _.isArray,
                    isEmpty: _.isEmpty,
                    assign: _.assign,
                    merge: _.merge,
                    camelCase: _.camelCase,
                    snakeCase: _.snakeCase,
                    cloneDeep: _.cloneDeep,
                    compact: _.compact,
                    contains: _.includes,
                    defaults: _.defaults,
                    difference: _.difference,
                    isFunction: _.isFunction,
                    functions: _.functions,
                    identity: _.identity,
                    isPlainObject: _.isPlainObject,
                    trim: _.trim,
                    without: without
                }, utf8_encode = function (argString) {
                    var c1, enc, end, n, start, string, stringl, utftext;
                    if (null === argString || "undefined" == typeof argString)return "";
                    for (string = argString + "", utftext = "", start = void 0, end = void 0, stringl = 0, start = end = 0, stringl = string.length, n = 0; stringl > n;)c1 = string.charCodeAt(n), enc = null, 128 > c1 ? end++ : enc = c1 > 127 && 2048 > c1 ? String.fromCharCode(c1 >> 6 | 192, 63 & c1 | 128) : String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, 63 & c1 | 128), null !== enc && (end > start && (utftext += string.slice(start, end)), utftext += enc, start = end = n + 1), n++;
                    return end > start && (utftext += string.slice(start, stringl)), utftext
                }, crc32 = function (str) {
                    var crc, i, iTop, table, x, y;
                    for (str = utf8_encode(str), table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D", crc = 0, x = 0, y = 0, crc = -1 ^ crc, i = 0, iTop = str.length; iTop > i;)y = 255 & (crc ^ str.charCodeAt(i)), x = "0x" + table.substr(9 * y, 8), crc = crc >>> 8 ^ x, i++;
                    return crc = -1 ^ crc, 0 > crc && (crc += 4294967296), crc
                }, Param = function () {
                    function Param(name, short, process) {
                        null == process && (process = Util.identity), this.name = name, this["short"] = short, this.process = process
                    }

                    return Param.prototype.set = function (origValue) {
                        return this.origValue = origValue, this
                    }, Param.prototype.serialize = function () {
                        var val, valid;
                        return val = this.value(), valid = Util.isArray(val) || Util.isPlainObject(val) || Util.isString(val) ? !Util.isEmpty(val) : null != val, null != this["short"] && valid ? this["short"] + "_" + val : ""
                    }, Param.prototype.value = function () {
                        return this.process(this.origValue)
                    }, Param.norm_color = function (value) {
                        return null != value ? value.replace(/^#/, "rgb:") : void 0
                    }, Param.prototype.build_array = function (arg) {
                        return null == arg && (arg = []), Util.isArray(arg) ? arg : [arg]
                    }, Param.process_video_params = function (param) {
                        var video;
                        switch (param.constructor) {
                            case Object:
                                return video = "", "codec" in param && (video = param.codec, "profile" in param && (video += ":" + param.profile, "level" in param && (video += ":" + param.level))), video;
                            case String:
                                return param;
                            default:
                                return null
                        }
                    }, Param
                }(), ArrayParam = function (superClass) {
                    function ArrayParam(name, short, sep, process) {
                        null == sep && (sep = "."), this.sep = sep, ArrayParam.__super__.constructor.call(this, name, short, process)
                    }

                    return extend(ArrayParam, superClass), ArrayParam.prototype.serialize = function () {
                        var array, flat, t;
                        return null != this["short"] ? (array = this.value(), Util.isEmpty(array) ? "" : (flat = function () {
                            var j, len, ref, results;
                            for (ref = this.value(), results = [], j = 0, len = ref.length; len > j; j++)t = ref[j], Util.isFunction(t.serialize) ? results.push(t.serialize()) : results.push(t);
                            return results
                        }.call(this), this["short"] + "_" + flat.join(this.sep))) : ""
                    }, ArrayParam.prototype.set = function (origValue) {
                        return null == origValue || Util.isArray(origValue) ? ArrayParam.__super__.set.call(this, origValue) : ArrayParam.__super__.set.call(this, [origValue])
                    }, ArrayParam
                }(Param), TransformationParam = function (superClass) {
                    function TransformationParam(name, short, sep, process) {
                        null == short && (short = "t"), null == sep && (sep = "."), this.sep = sep, TransformationParam.__super__.constructor.call(this, name, short, process)
                    }

                    return extend(TransformationParam, superClass), TransformationParam.prototype.serialize = function () {
                        var joined, result, t;
                        return Util.isEmpty(this.value()) ? "" : Util.allStrings(this.value()) ? (joined = this.value().join(this.sep), Util.isEmpty(joined) ? "" : this["short"] + "_" + joined) : (result = function () {
                            var j, len, ref, results;
                            for (ref = this.value(), results = [], j = 0, len = ref.length; len > j; j++)t = ref[j], null != t && (Util.isString(t) && !Util.isEmpty(t) ? results.push(this["short"] + "_" + t) : Util.isFunction(t.serialize) ? results.push(t.serialize()) : Util.isPlainObject(t) && !Util.isEmpty(t) ? results.push(new Transformation(t).serialize()) : results.push(void 0));
                            return results
                        }.call(this), Util.compact(result))
                    }, TransformationParam.prototype.set = function (origValue1) {
                        return this.origValue = origValue1, Util.isArray(this.origValue) ? TransformationParam.__super__.set.call(this, this.origValue) : TransformationParam.__super__.set.call(this, [this.origValue])
                    }, TransformationParam
                }(Param), RangeParam = function (superClass) {
                    function RangeParam(name, short, process) {
                        null == process && (process = this.norm_range_value), RangeParam.__super__.constructor.call(this, name, short, process)
                    }

                    return extend(RangeParam, superClass), RangeParam.norm_range_value = function (value) {
                        var modifier, offset;
                        return offset = String(value).match(new RegExp("^" + offset_any_pattern + "$")), offset && (modifier = null != offset[5] ? "p" : "", value = (offset[1] || offset[4]) + modifier), value
                    }, RangeParam
                }(Param), RawParam = function (superClass) {
                    function RawParam(name, short, process) {
                        null == process && (process = Util.identity), RawParam.__super__.constructor.call(this, name, short, process)
                    }

                    return extend(RawParam, superClass), RawParam.prototype.serialize = function () {
                        return this.value()
                    }, RawParam
                }(Param), parameters = {}, parameters.Param = Param, parameters.ArrayParam = ArrayParam, parameters.RangeParam = RangeParam, parameters.RawParam = RawParam, parameters.TransformationParam = TransformationParam, Condition = function () {
                    function Condition(conditionStr) {
                        this.predicate_list = [], null != conditionStr && this.predicate_list.push(this.normalize(conditionStr))
                    }

                    return Condition.OPERATORS = {
                        "=": "eq",
                        "!=": "ne",
                        "<": "lt",
                        ">": "gt",
                        "<=": "lte",
                        ">=": "gte",
                        "&&": "and",
                        "||": "or"
                    }, Condition.PARAMETERS = {
                        width: "w",
                        height: "h",
                        aspect_ratio: "ar",
                        aspectRatio: "ar",
                        page_count: "pc",
                        pageCount: "pc",
                        face_count: "fc",
                        faceCount: "fc"
                    }, Condition.BOUNDRY = "[ _]+", Condition["new"] = function (conditionStr) {
                        return new this(conditionStr)
                    }, Condition.prototype.normalize = function (value) {
                        var replaceRE;
                        return replaceRE = new RegExp("(" + Object.keys(Condition.PARAMETERS).join("|") + "|[=<>&|!]+)", "g"), value = value.replace(replaceRE, function (match) {
                            return Condition.OPERATORS[match] || Condition.PARAMETERS[match]
                        }), value.replace(/[ _]+/g, "_")
                    }, Condition.prototype.getParent = function () {
                        return this.parent
                    }, Condition.prototype.setParent = function (parent) {
                        return this.parent = parent, this
                    }, Condition.prototype.toString = function () {
                        return this.predicate_list.join("_")
                    }, Condition.prototype.predicate = function (name, operator, value) {
                        return null != Condition.OPERATORS[operator] && (operator = Condition.OPERATORS[operator]), this.predicate_list.push(name + "_" + operator + "_" + value), this
                    }, Condition.prototype.and = function () {
                        return this.predicate_list.push("and"), this
                    }, Condition.prototype.or = function () {
                        return this.predicate_list.push("or"), this
                    }, Condition.prototype.then = function () {
                        return this.getParent()["if"](this.toString())
                    }, Condition.prototype.height = function (operator, value) {
                        return this.predicate("h", operator, value)
                    }, Condition.prototype.width = function (operator, value) {
                        return this.predicate("w", operator, value)
                    }, Condition.prototype.aspectRatio = function (operator, value) {
                        return this.predicate("ar", operator, value)
                    }, Condition.prototype.pageCount = function (operator, value) {
                        return this.predicate("pc", operator, value)
                    }, Condition.prototype.faceCount = function (operator, value) {
                        return this.predicate("fc", operator, value)
                    }, Condition
                }(), TransformationBase = function () {
                    function TransformationBase(options) {
                        var m, parent, trans;
                        null == options && (options = {}), parent = void 0, trans = {}, this.toOptions || (this.toOptions = function (withChain) {
                            var key, list, opt, ref, tr, value;
                            null == withChain && (withChain = !0), opt = {};
                            for (key in trans)value = trans[key], opt[key] = value.origValue;
                            ref = this.otherOptions;
                            for (key in ref)value = ref[key], void 0 !== value && (opt[key] = value);
                            return withChain && !Util.isEmpty(this.chained) && (list = function () {
                                var j, len, ref1, results;
                                for (ref1 = this.chained, results = [], j = 0, len = ref1.length; len > j; j++)tr = ref1[j], results.push(tr.toOptions());
                                return results
                            }.call(this), list.push(opt), opt = {transformation: list}), opt
                        }), this.setParent || (this.setParent = function (object) {
                            return parent = object, null != object && this.fromOptions("function" == typeof object.toOptions ? object.toOptions() : void 0), this
                        }), this.getParent || (this.getParent = function () {
                            return parent
                        }), this.param || (this.param = function (value, name, abbr, defaultValue, process) {
                            return null == process && (process = Util.isFunction(defaultValue) ? defaultValue : Util.identity), trans[name] = new Param(name, abbr, process).set(value), this
                        }), this.rawParam || (this.rawParam = function (value, name, abbr, defaultValue, process) {
                            return null == process && (process = Util.identity), process = lastArgCallback(arguments), trans[name] = new RawParam(name, abbr, process).set(value), this
                        }), this.rangeParam || (this.rangeParam = function (value, name, abbr, defaultValue, process) {
                            return null == process && (process = Util.identity), process = lastArgCallback(arguments), trans[name] = new RangeParam(name, abbr, process).set(value), this
                        }), this.arrayParam || (this.arrayParam = function (value, name, abbr, sep, defaultValue, process) {
                            return null == sep && (sep = ":"), null == defaultValue && (defaultValue = []), null == process && (process = Util.identity), process = lastArgCallback(arguments), trans[name] = new ArrayParam(name, abbr, sep, process).set(value), this
                        }), this.transformationParam || (this.transformationParam = function (value, name, abbr, sep, defaultValue, process) {
                            return null == sep && (sep = "."), null == process && (process = Util.identity), process = lastArgCallback(arguments), trans[name] = new TransformationParam(name, abbr, sep, process).set(value), this
                        }), this.getValue || (this.getValue = function (name) {
                            var ref, ref1;
                            return null != (ref = null != (ref1 = trans[name]) ? ref1.value() : void 0) ? ref : this.otherOptions[name]
                        }), this.get || (this.get = function (name) {
                            return trans[name]
                        }), this.remove || (this.remove = function (name) {
                            var temp;
                            switch (!1) {
                                case null == trans[name]:
                                    return temp = trans[name], delete trans[name], temp.origValue;
                                case null == this.otherOptions[name]:
                                    return temp = this.otherOptions[name], delete this.otherOptions[name], temp;
                                default:
                                    return null
                            }
                        }), this.keys || (this.keys = function () {
                            var key;
                            return function () {
                                var results;
                                results = [];
                                for (key in trans)results.push(Util.snakeCase(key));
                                return results
                            }().sort()
                        }), this.toPlainObject || (this.toPlainObject = function () {
                            var hash, key, list, tr;
                            hash = {};
                            for (key in trans)hash[key] = trans[key].value(), Util.isPlainObject(hash[key]) && (hash[key] = Util.cloneDeep(hash[key]));
                            return Util.isEmpty(this.chained) || (list = function () {
                                var j, len, ref, results;
                                for (ref = this.chained, results = [], j = 0, len = ref.length; len > j; j++)tr = ref[j], results.push(tr.toPlainObject());
                                return results
                            }.call(this), list.push(hash), hash = {transformation: list}), hash
                        }), this.chain || (this.chain = function () {
                            var names, tr;
                            return names = Object.getOwnPropertyNames(trans), 0 !== names.length && (tr = new this.constructor(this.toOptions(!1)), this.resetTransformations(), this.chained.push(tr)), this
                        }), this.resetTransformations || (this.resetTransformations = function () {
                            return trans = {}, this
                        }), this.otherOptions || (this.otherOptions = {}), this.methods || (this.methods = Util.difference(Util.functions(Transformation.prototype), Util.functions(TransformationBase.prototype))), this.PARAM_NAMES || (this.PARAM_NAMES = function () {
                            var j, len, ref, results;
                            for (ref = this.methods, results = [], j = 0, len = ref.length; len > j; j++)m = ref[j], results.push(Util.snakeCase(m));
                            return results
                        }.call(this).concat(Configuration.CONFIG_PARAMS)), this.chained = [], Util.isEmpty(options) || this.fromOptions(options)
                    }

                    var lastArgCallback;
                    return TransformationBase.prototype.trans_separator = "/", TransformationBase.prototype.param_separator = ",", lastArgCallback = function (args) {
                        var callback;
                        return callback = null != args ? args[args.length - 1] : void 0, Util.isFunction(callback) ? callback : void 0
                    }, TransformationBase.prototype.fromOptions = function (options) {
                        var key, opt;
                        if (options instanceof TransformationBase)this.fromTransformation(options); else {
                            options || (options = {}), (Util.isString(options) || Util.isArray(options)) && (options = {transformation: options}), options = Util.cloneDeep(options, function (value) {
                                return value instanceof TransformationBase ? new value.constructor(value.toOptions()) : void 0
                            });
                            for (key in options)opt = options[key], this.set(key, opt)
                        }
                        return this
                    }, TransformationBase.prototype.fromTransformation = function (other) {
                        var j, key, len, ref;
                        if (other instanceof TransformationBase)for (ref = other.keys(), j = 0, len = ref.length; len > j; j++)key = ref[j], this.set(key, other.get(key).origValue);
                        return this
                    }, TransformationBase.prototype.set = function (key, value) {
                        var camelKey;
                        return camelKey = Util.camelCase(key), Util.contains(this.methods, camelKey) ? this[camelKey](value) : this.otherOptions[key] = value, this
                    }, TransformationBase.prototype.hasLayer = function () {
                        return this.getValue("overlay") || this.getValue("underlay")
                    }, TransformationBase.prototype.serialize = function () {
                        var ifParam, paramList, ref, ref1, resultArray, t, tr, transformationList, transformationString, transformations, value;
                        switch (resultArray = function () {
                            var j, len, ref, results;
                            for (ref = this.chained, results = [], j = 0, len = ref.length; len > j; j++)tr = ref[j], results.push(tr.serialize());
                            return results
                        }.call(this), paramList = this.keys(), transformations = null != (ref = this.get("transformation")) ? ref.serialize() : void 0, ifParam = null != (ref1 = this.get("if")) ? ref1.serialize() : void 0, paramList = Util.difference(paramList, ["transformation", "if"]), transformationList = function () {
                            var j, len, ref2, results;
                            for (results = [], j = 0, len = paramList.length; len > j; j++)t = paramList[j], results.push(null != (ref2 = this.get(t)) ? ref2.serialize() : void 0);
                            return results
                        }.call(this), !1) {
                            case!Util.isString(transformations):
                                transformationList.push(transformations);
                                break;
                            case!Util.isArray(transformations):
                                resultArray = resultArray.concat(transformations)
                        }
                        return transformationList = function () {
                            var j, len, results;
                            for (results = [], j = 0, len = transformationList.length; len > j; j++)value = transformationList[j], (Util.isArray(value) && !Util.isEmpty(value) || !Util.isArray(value) && value) && results.push(value);
                            return results
                        }().sort(), "if_end" === ifParam ? transformationList.push(ifParam) : Util.isEmpty(ifParam) || transformationList.unshift(ifParam), transformationString = transformationList.join(this.param_separator), Util.isEmpty(transformationString) || resultArray.push(transformationString), Util.compact(resultArray).join(this.trans_separator)
                    }, TransformationBase.prototype.listNames = function () {
                        return this.methods
                    }, TransformationBase.prototype.toHtmlAttributes = function () {
                        var attrName, height, j, key, len, options, ref, ref1, ref2, ref3, value;
                        options = {}, ref = this.otherOptions;
                        for (key in ref)value = ref[key], Util.contains(this.PARAM_NAMES, key) || (attrName = /^html_/.test(key) ? key.slice(5) : key, options[attrName] = value);
                        for (ref1 = this.keys(), j = 0, len = ref1.length; len > j; j++)key = ref1[j], /^html_/.test(key) && (options[key.slice(5)] = this.getValue(key));
                        return this.hasLayer() || this.getValue("angle") || Util.contains(["fit", "limit", "lfill"], this.getValue("crop")) || (width = null != (ref2 = this.get("width")) ? ref2.origValue : void 0, height = null != (ref3 = this.get("height")) ? ref3.origValue : void 0, parseFloat(width) >= 1 && null == options.width && (options.width = width), parseFloat(height) >= 1 && null == options.height && (options.height = height)), options
                    }, TransformationBase.prototype.isValidParamName = function (name) {
                        return this.methods.indexOf(Util.camelCase(name)) >= 0
                    }, TransformationBase.prototype.toHtml = function () {
                        var ref;
                        return null != (ref = this.getParent()) && "function" == typeof ref.toHtml ? ref.toHtml() : void 0
                    }, TransformationBase.prototype.toString = function () {
                        return this.serialize()
                    }, TransformationBase
                }(), Transformation = function (superClass) {
                    function Transformation(options) {
                        null == options && (options = {}), Transformation.__super__.constructor.call(this, options)
                    }

                    return extend(Transformation, superClass), Transformation["new"] = function (args) {
                        return new Transformation(args)
                    }, Transformation.prototype.angle = function (value) {
                        return this.arrayParam(value, "angle", "a", ".")
                    }, Transformation.prototype.audioCodec = function (value) {
                        return this.param(value, "audio_codec", "ac")
                    }, Transformation.prototype.audioFrequency = function (value) {
                        return this.param(value, "audio_frequency", "af")
                    }, Transformation.prototype.aspectRatio = function (value) {
                        return this.param(value, "aspect_ratio", "ar")
                    }, Transformation.prototype.background = function (value) {
                        return this.param(value, "background", "b", Param.norm_color)
                    }, Transformation.prototype.bitRate = function (value) {
                        return this.param(value, "bit_rate", "br")
                    }, Transformation.prototype.border = function (value) {
                        return this.param(value, "border", "bo", function (border) {
                            return Util.isPlainObject(border) ? (border = Util.assign({}, {
                                color: "black",
                                width: 2
                            }, border), border.width + "px_solid_" + Param.norm_color(border.color)) : border
                        })
                    }, Transformation.prototype.color = function (value) {
                        return this.param(value, "color", "co", Param.norm_color)
                    }, Transformation.prototype.colorSpace = function (value) {
                        return this.param(value, "color_space", "cs")
                    }, Transformation.prototype.crop = function (value) {
                        return this.param(value, "crop", "c")
                    }, Transformation.prototype.defaultImage = function (value) {
                        return this.param(value, "default_image", "d")
                    }, Transformation.prototype.delay = function (value) {
                        return this.param(value, "delay", "l")
                    }, Transformation.prototype.density = function (value) {
                        return this.param(value, "density", "dn")
                    }, Transformation.prototype.duration = function (value) {
                        return this.rangeParam(value, "duration", "du")
                    }, Transformation.prototype.dpr = function (value) {
                        return this.param(value, "dpr", "dpr", function (dpr) {
                            return dpr = dpr.toString(), "auto" === dpr ? "1.0" : (null != dpr ? dpr.match(/^\d+$/) : void 0) ? dpr + ".0" : dpr
                        })
                    }, Transformation.prototype.effect = function (value) {
                        return this.arrayParam(value, "effect", "e", ":")
                    }, Transformation.prototype["else"] = function () {
                        return this["if"]("else")
                    }, Transformation.prototype.endIf = function () {
                        return this["if"]("end")
                    }, Transformation.prototype.endOffset = function (value) {
                        return this.rangeParam(value, "end_offset", "eo")
                    }, Transformation.prototype.fallbackContent = function (value) {
                        return this.param(value, "fallback_content")
                    }, Transformation.prototype.fetchFormat = function (value) {
                        return this.param(value, "fetch_format", "f")
                    }, Transformation.prototype.format = function (value) {
                        return this.param(value, "format")
                    }, Transformation.prototype.flags = function (value) {
                        return this.arrayParam(value, "flags", "fl", ".")
                    }, Transformation.prototype.gravity = function (value) {
                        return this.param(value, "gravity", "g")
                    }, Transformation.prototype.height = function (value) {
                        return this.param(value, "height", "h", function (_this) {
                            return function () {
                                return _this.getValue("crop") || _this.getValue("overlay") || _this.getValue("underlay") ? value : null
                            }
                        }(this))
                    }, Transformation.prototype.htmlHeight = function (value) {
                        return this.param(value, "html_height")
                    }, Transformation.prototype.htmlWidth = function (value) {
                        return this.param(value, "html_width")
                    }, Transformation.prototype["if"] = function (value) {
                        var i, ifVal, j, ref, trIf, trRest;
                        switch (null == value && (value = ""), value) {
                            case"else":
                                return this.chain(), this.param(value, "if", "if");
                            case"end":
                                for (this.chain(), i = j = ref = this.chained.length - 1; j >= 0 && (ifVal = this.chained[i].getValue("if"), "end" !== ifVal) && (null == ifVal || (trIf = Transformation["new"]()["if"](ifVal), this.chained[i].remove("if"), trRest = this.chained[i], this.chained[i] = Transformation["new"]().transformation([trIf, trRest]), "else" === ifVal)); i = j += -1);
                                return this.param(value, "if", "if");
                            case"":
                                return Condition["new"]().setParent(this);
                            default:
                                return this.param(value, "if", "if", function (value) {
                                    return Condition["new"](value).toString()
                                })
                        }
                    }, Transformation.prototype.offset = function (value) {
                        var end_o, ref, start_o;
                        return ref = Util.isFunction(null != value ? value.split : void 0) ? value.split("..") : Util.isArray(value) ? value : [null, null], start_o = ref[0], end_o = ref[1], null != start_o && this.startOffset(start_o), null != end_o ? this.endOffset(end_o) : void 0
                    }, Transformation.prototype.opacity = function (value) {
                        return this.param(value, "opacity", "o")
                    }, Transformation.prototype.overlay = function (value) {
                        return this.param(value, "overlay", "l")
                    }, Transformation.prototype.page = function (value) {
                        return this.param(value, "page", "pg")
                    }, Transformation.prototype.poster = function (value) {
                        return this.param(value, "poster")
                    }, Transformation.prototype.prefix = function (value) {
                        return this.param(value, "prefix", "p")
                    }, Transformation.prototype.quality = function (value) {
                        return this.param(value, "quality", "q")
                    }, Transformation.prototype.radius = function (value) {
                        return this.param(value, "radius", "r")
                    }, Transformation.prototype.rawTransformation = function (value) {
                        return this.rawParam(value, "raw_transformation")
                    }, Transformation.prototype.size = function (value) {
                        var height, ref;
                        return Util.isFunction(null != value ? value.split : void 0) ? (ref = value.split("x"), width = ref[0], height = ref[1], this.width(width), this.height(height)) : void 0
                    }, Transformation.prototype.sourceTypes = function (value) {
                        return this.param(value, "source_types")
                    }, Transformation.prototype.sourceTransformation = function (value) {
                        return this.param(value, "source_transformation")
                    }, Transformation.prototype.startOffset = function (value) {
                        return this.rangeParam(value, "start_offset", "so")
                    }, Transformation.prototype.transformation = function (value) {
                        return this.transformationParam(value, "transformation", "t")
                    }, Transformation.prototype.underlay = function (value) {
                        return this.param(value, "underlay", "u")
                    }, Transformation.prototype.videoCodec = function (value) {
                        return this.param(value, "video_codec", "vc", Param.process_video_params)
                    }, Transformation.prototype.videoSampling = function (value) {
                        return this.param(value, "video_sampling", "vs")
                    }, Transformation.prototype.width = function (value) {
                        return this.param(value, "width", "w", function (_this) {
                            return function () {
                                return _this.getValue("crop") || _this.getValue("overlay") || _this.getValue("underlay") ? value : null
                            }
                        }(this))
                    }, Transformation.prototype.x = function (value) {
                        return this.param(value, "x", "x")
                    }, Transformation.prototype.y = function (value) {
                        return this.param(value, "y", "y")
                    }, Transformation.prototype.zoom = function (value) {
                        return this.param(value, "zoom", "z")
                    }, Transformation
                }(TransformationBase), Configuration = function () {
                    function Configuration(options) {
                        null == options && (options = {}), this.configuration = Util.cloneDeep(options), Util.defaults(this.configuration, DEFAULT_CONFIGURATION_PARAMS)
                    }

                    var DEFAULT_CONFIGURATION_PARAMS, ref;
                    return DEFAULT_CONFIGURATION_PARAMS = {
                        responsive_class: "cld-responsive",
                        responsive_use_breakpoints: !0,
                        round_dpr: !0,
                        secure: "https:" === ("undefined" != typeof window && null !== window && null != (ref = window.location) ? ref.protocol : void 0)
                    }, Configuration.CONFIG_PARAMS = ["api_key", "api_secret", "cdn_subdomain", "cloud_name", "cname", "private_cdn", "protocol", "resource_type", "responsive_class", "responsive_use_breakpoints", "responsive_width", "round_dpr", "secure", "secure_cdn_subdomain", "secure_distribution", "shorten", "type", "url_suffix", "use_root_path", "version"], Configuration.prototype.init = function () {
                        return this.fromEnvironment(), this.fromDocument(), this
                    }, Configuration.prototype.set = function (name, value) {
                        return this.configuration[name] = value, this
                    }, Configuration.prototype.get = function (name) {
                        return this.configuration[name]
                    }, Configuration.prototype.merge = function (config) {
                        return null == config && (config = {}), Util.assign(this.configuration, Util.cloneDeep(config)), this
                    }, Configuration.prototype.fromDocument = function () {
                        var el, j, len, meta_elements;
                        if (meta_elements = "undefined" != typeof document && null !== document ? document.querySelectorAll('meta[name^="cloudinary_"]') : void 0)for (j = 0, len = meta_elements.length; len > j; j++)el = meta_elements[j], this.configuration[el.getAttribute("name").replace("cloudinary_", "")] = el.getAttribute("content");
                        return this
                    }, Configuration.prototype.fromEnvironment = function () {
                        var cloudinary_url, k, ref1, ref2, uri, v;
                        if (cloudinary_url = "undefined" != typeof process && null !== process && null != (ref1 = process.env) ? ref1.CLOUDINARY_URL : void 0, null != cloudinary_url && (uri = require("url").parse(cloudinary_url, !0), this.configuration = {
                                cloud_name: uri.host,
                                api_key: uri.auth && uri.auth.split(":")[0],
                                api_secret: uri.auth && uri.auth.split(":")[1],
                                private_cdn: null != uri.pathname,
                                secure_distribution: uri.pathname && uri.pathname.substring(1)
                            }, null != uri.query)) {
                            ref2 = uri.query;
                            for (k in ref2)v = ref2[k],
                                this.configuration[k] = v
                        }
                        return this
                    }, Configuration.prototype.config = function (new_config, new_value) {
                        switch (!1) {
                            case void 0 === new_value:
                                return this.set(new_config, new_value), this.configuration;
                            case!Util.isString(new_config):
                                return this.get(new_config);
                            case!Util.isPlainObject(new_config):
                                return this.merge(new_config), this.configuration;
                            default:
                                return this.configuration
                        }
                    }, Configuration.prototype.toOptions = function () {
                        return Util.cloneDeep(this.configuration)
                    }, Configuration
                }(), HtmlTag = function () {
                    function HtmlTag(name, publicId, options) {
                        var transformation;
                        this.name = name, this.publicId = publicId, null == options && (Util.isPlainObject(publicId) ? (options = publicId, this.publicId = void 0) : options = {}), transformation = new Transformation(options), transformation.setParent(this), this.transformation = function () {
                            return transformation
                        }
                    }

                    var toAttribute;
                    return HtmlTag["new"] = function (name, publicId, options) {
                        return new this(name, publicId, options)
                    }, toAttribute = function (key, value) {
                        return value ? value === !0 ? key : key + '="' + value + '"' : void 0
                    }, HtmlTag.prototype.htmlAttrs = function (attrs) {
                        var key, pairs, value;
                        return pairs = function () {
                            var results;
                            results = [];
                            for (key in attrs)value = attrs[key], value && results.push(toAttribute(key, value));
                            return results
                        }().sort().join(" ")
                    }, HtmlTag.prototype.getOptions = function () {
                        return this.transformation().toOptions()
                    }, HtmlTag.prototype.getOption = function (name) {
                        return this.transformation().getValue(name)
                    }, HtmlTag.prototype.attributes = function () {
                        return this.transformation().toHtmlAttributes()
                    }, HtmlTag.prototype.setAttr = function (name, value) {
                        return this.transformation().set("html_" + name, value), this
                    }, HtmlTag.prototype.getAttr = function (name) {
                        return this.attributes()["html_" + name] || this.attributes()[name]
                    }, HtmlTag.prototype.removeAttr = function (name) {
                        var ref;
                        return null != (ref = this.transformation().remove("html_" + name)) ? ref : this.transformation().remove(name)
                    }, HtmlTag.prototype.content = function () {
                        return ""
                    }, HtmlTag.prototype.openTag = function () {
                        return "<" + this.name + " " + this.htmlAttrs(this.attributes()) + ">"
                    }, HtmlTag.prototype.closeTag = function () {
                        return "</" + this.name + ">"
                    }, HtmlTag.prototype.toHtml = function () {
                        return this.openTag() + this.content() + this.closeTag()
                    }, HtmlTag.prototype.toDOM = function () {
                        var element, name, ref, value;
                        if (!Util.isFunction("undefined" != typeof document && null !== document ? document.createElement : void 0))throw"Can't create DOM if document is not present!";
                        element = document.createElement(this.name), ref = this.attributes();
                        for (name in ref)value = ref[name], element[name] = value;
                        return element
                    }, HtmlTag
                }(), ImageTag = function (superClass) {
                    function ImageTag(publicId, options) {
                        null == options && (options = {}), ImageTag.__super__.constructor.call(this, "img", publicId, options)
                    }

                    return extend(ImageTag, superClass), ImageTag.prototype.closeTag = function () {
                        return ""
                    }, ImageTag.prototype.attributes = function () {
                        var attr;
                        return attr = ImageTag.__super__.attributes.call(this) || [], null == attr.src && (attr.src = new Cloudinary(this.getOptions()).url(this.publicId)), attr
                    }, ImageTag
                }(HtmlTag), VideoTag = function (superClass) {
                    function VideoTag(publicId, options) {
                        null == options && (options = {}), options = Util.defaults({}, options, Cloudinary.DEFAULT_VIDEO_PARAMS), VideoTag.__super__.constructor.call(this, "video", publicId.replace(/\.(mp4|ogv|webm)$/, ""), options)
                    }

                    var DEFAULT_POSTER_OPTIONS, DEFAULT_VIDEO_SOURCE_TYPES, VIDEO_TAG_PARAMS;
                    return extend(VideoTag, superClass), VIDEO_TAG_PARAMS = ["source_types", "source_transformation", "fallback_content", "poster"], DEFAULT_VIDEO_SOURCE_TYPES = ["webm", "mp4", "ogv"], DEFAULT_POSTER_OPTIONS = {
                        format: "jpg",
                        resource_type: "video"
                    }, VideoTag.prototype.setSourceTransformation = function (value) {
                        return this.transformation().sourceTransformation(value), this
                    }, VideoTag.prototype.setSourceTypes = function (value) {
                        return this.transformation().sourceTypes(value), this
                    }, VideoTag.prototype.setPoster = function (value) {
                        return this.transformation().poster(value), this
                    }, VideoTag.prototype.setFallbackContent = function (value) {
                        return this.transformation().fallbackContent(value), this
                    }, VideoTag.prototype.content = function () {
                        var cld, fallback, innerTags, mimeType, sourceTransformation, sourceTypes, src, srcType, transformation, videoType;
                        return sourceTypes = this.transformation().getValue("source_types"), sourceTransformation = this.transformation().getValue("source_transformation"), fallback = this.transformation().getValue("fallback_content"), Util.isArray(sourceTypes) ? (cld = new Cloudinary(this.getOptions()), innerTags = function () {
                            var j, len, results;
                            for (results = [], j = 0, len = sourceTypes.length; len > j; j++)srcType = sourceTypes[j], transformation = sourceTransformation[srcType] || {}, src = cld.url("" + this.publicId, Util.defaults({}, transformation, {
                                resource_type: "video",
                                format: srcType
                            })), videoType = "ogv" === srcType ? "ogg" : srcType, mimeType = "video/" + videoType, results.push("<source " + this.htmlAttrs({
                                    src: src,
                                    type: mimeType
                                }) + ">");
                            return results
                        }.call(this)) : innerTags = [], innerTags.join("") + fallback
                    }, VideoTag.prototype.attributes = function () {
                        var a, attr, defaults, j, len, poster, ref, ref1, sourceTypes;
                        for (sourceTypes = this.getOption("source_types"), poster = null != (ref = this.getOption("poster")) ? ref : {}, Util.isPlainObject(poster) && (defaults = null != poster.public_id ? Cloudinary.DEFAULT_IMAGE_PARAMS : DEFAULT_POSTER_OPTIONS, poster = new Cloudinary(this.getOptions()).url(null != (ref1 = poster.public_id) ? ref1 : this.publicId, Util.defaults({}, poster, defaults))), attr = VideoTag.__super__.attributes.call(this) || [], j = 0, len = attr.length; len > j; j++)a = attr[j], Util.contains(VIDEO_TAG_PARAMS) || (attr = a);
                        return Util.isArray(sourceTypes) || (attr.src = new Cloudinary(this.getOptions()).url(this.publicId, {
                            resource_type: "video",
                            format: sourceTypes
                        })), null != poster && (attr.poster = poster), attr
                    }, VideoTag
                }(HtmlTag), Cloudinary = function () {
                    function Cloudinary(options) {
                        var configuration;
                        this.devicePixelRatioCache = {}, this.responsiveConfig = {}, this.responsiveResizeInitialized = !1, configuration = new Configuration(options), this.config = function (newConfig, newValue) {
                            return configuration.config(newConfig, newValue)
                        }, this.fromDocument = function () {
                            return configuration.fromDocument(), this
                        }, this.fromEnvironment = function () {
                            return configuration.fromEnvironment(), this
                        }, this.init = function () {
                            return configuration.init(), this
                        }
                    }

                    var AKAMAI_SHARED_CDN, CF_SHARED_CDN, DEFAULT_POSTER_OPTIONS, DEFAULT_VIDEO_SOURCE_TYPES, OLD_AKAMAI_SHARED_CDN, SHARED_CDN, VERSION, absolutize, applyBreakpoints, cdnSubdomainNumber, closestAbove, cloudinaryUrlPrefix, defaultBreakpoints, finalizeResourceType, parentWidth;
                    return VERSION = "2.0.8", CF_SHARED_CDN = "d3jpl91pxevbkh.cloudfront.net", OLD_AKAMAI_SHARED_CDN = "cloudinary-a.akamaihd.net", AKAMAI_SHARED_CDN = "res.cloudinary.com", SHARED_CDN = AKAMAI_SHARED_CDN, DEFAULT_POSTER_OPTIONS = {
                        format: "jpg",
                        resource_type: "video"
                    }, DEFAULT_VIDEO_SOURCE_TYPES = ["webm", "mp4", "ogv"], Cloudinary.DEFAULT_IMAGE_PARAMS = {
                        resource_type: "image",
                        transformation: [],
                        type: "upload"
                    }, Cloudinary.DEFAULT_VIDEO_PARAMS = {
                        fallback_content: "",
                        resource_type: "video",
                        source_transformation: {},
                        source_types: DEFAULT_VIDEO_SOURCE_TYPES,
                        transformation: [],
                        type: "upload"
                    }, Cloudinary["new"] = function (options) {
                        return new this(options)
                    }, finalizeResourceType = function (resourceType, type, urlSuffix, useRootPath, shorten) {
                        var options;
                        if (Util.isPlainObject(resourceType) && (options = resourceType, resourceType = options.resource_type, type = options.type, urlSuffix = options.url_suffix, useRootPath = options.use_root_path, shorten = options.shorten), null == type && (type = "upload"), null != urlSuffix)if ("image" === resourceType && "upload" === type)resourceType = "images", type = null; else {
                            if ("raw" !== resourceType || "upload" !== type)throw new Error("URL Suffix only supported for image/upload and raw/upload");
                            resourceType = "files", type = null
                        }
                        if (useRootPath) {
                            if (("image" !== resourceType || "upload" !== type) && "images" !== resourceType)throw new Error("Root path only supported for image/upload");
                            resourceType = null, type = null
                        }
                        return shorten && "image" === resourceType && "upload" === type && (resourceType = "iu", type = null), [resourceType, type].join("/")
                    }, absolutize = function (url) {
                        var prefix;
                        return url.match(/^https?:\//) || (prefix = document.location.protocol + "//" + document.location.host, "?" === url[0] ? prefix += document.location.pathname : "/" !== url[0] && (prefix += document.location.pathname.replace(/\/[^\/]*$/, "/")), url = prefix + url), url
                    }, Cloudinary.prototype.url = function (publicId, options) {
                        var prefix, ref, resourceTypeAndType, transformation, transformationString, url, version;
                        if (null == options && (options = {}), !publicId)return publicId;
                        if (options instanceof Transformation && (options = options.toOptions()), options = Util.defaults({}, options, this.config(), Cloudinary.DEFAULT_IMAGE_PARAMS), "fetch" === options.type && (options.fetch_format = options.fetch_format || options.format, publicId = absolutize(publicId)), transformation = new Transformation(options), transformationString = transformation.serialize(), !options.cloud_name)throw"Unknown cloud_name";
                        if (options.url_suffix && !options.private_cdn)throw"URL Suffix only supported in private CDN";
                        if (publicId.search("/") >= 0 && !publicId.match(/^v[0-9]+/) && !publicId.match(/^https?:\//) && !(null != (ref = options.version) ? ref.toString() : void 0) && (options.version = 1), publicId.match(/^https?:/))"upload" === options.type || "asset" === options.type ? url = publicId : publicId = encodeURIComponent(publicId).replace(/%3A/g, ":").replace(/%2F/g, "/"); else {
                            if (publicId = encodeURIComponent(decodeURIComponent(publicId)).replace(/%3A/g, ":").replace(/%2F/g, "/"), options.url_suffix) {
                                if (options.url_suffix.match(/[\.\/]/))throw"url_suffix should not include . or /";
                                publicId = publicId + "/" + options.url_suffix
                            }
                            options.format && (options.trust_public_id || (publicId = publicId.replace(/\.(jpg|png|gif|webp)$/, "")), publicId = publicId + "." + options.format)
                        }
                        return prefix = cloudinaryUrlPrefix(publicId, options), resourceTypeAndType = finalizeResourceType(options.resource_type, options.type, options.url_suffix, options.use_root_path, options.shorten), version = options.version ? "v" + options.version : "", url || Util.compact([prefix, resourceTypeAndType, transformationString, version, publicId]).join("/").replace(/([^:])\/+/g, "$1/")
                    }, Cloudinary.prototype.video_url = function (publicId, options) {
                        return options = Util.assign({resource_type: "video"}, options), this.url(publicId, options)
                    }, Cloudinary.prototype.video_thumbnail_url = function (publicId, options) {
                        return options = Util.assign({}, DEFAULT_POSTER_OPTIONS, options), this.url(publicId, options)
                    }, Cloudinary.prototype.transformation_string = function (options) {
                        return new Transformation(options).serialize()
                    }, Cloudinary.prototype.image = function (publicId, options) {
                        var img;
                        return null == options && (options = {}), img = this.imageTag(publicId, options), null == options.src && img.setAttr("src", ""), img = img.toDOM(), Util.setData(img, "src-cache", this.url(publicId, options)), this.cloudinary_update(img, options), img
                    }, Cloudinary.prototype.imageTag = function (publicId, options) {
                        var tag;
                        return tag = new ImageTag(publicId, this.config()), tag.transformation().fromOptions(options), tag
                    }, Cloudinary.prototype.video_thumbnail = function (publicId, options) {
                        return this.image(publicId, Util.merge({}, DEFAULT_POSTER_OPTIONS, options))
                    }, Cloudinary.prototype.facebook_profile_image = function (publicId, options) {
                        return this.image(publicId, Util.assign({type: "facebook"}, options))
                    }, Cloudinary.prototype.twitter_profile_image = function (publicId, options) {
                        return this.image(publicId, Util.assign({type: "twitter"}, options))
                    }, Cloudinary.prototype.twitter_name_profile_image = function (publicId, options) {
                        return this.image(publicId, Util.assign({type: "twitter_name"}, options))
                    }, Cloudinary.prototype.gravatar_image = function (publicId, options) {
                        return this.image(publicId, Util.assign({type: "gravatar"}, options))
                    }, Cloudinary.prototype.fetch_image = function (publicId, options) {
                        return this.image(publicId, Util.assign({type: "fetch"}, options))
                    }, Cloudinary.prototype.video = function (publicId, options) {
                        return null == options && (options = {}), this.videoTag(publicId, options).toHtml()
                    }, Cloudinary.prototype.videoTag = function (publicId, options) {
                        return options = Util.defaults({}, options, this.config()), new VideoTag(publicId, options)
                    }, Cloudinary.prototype.sprite_css = function (publicId, options) {
                        return options = Util.assign({type: "sprite"}, options), publicId.match(/.css$/) || (options.format = "css"), this.url(publicId, options)
                    }, Cloudinary.prototype.responsive = function (options, bootstrap) {
                        var ref, ref1, ref2, responsiveClass, responsiveResize, timeout;
                        return null == bootstrap && (bootstrap = !0), this.responsiveConfig = Util.merge(this.responsiveConfig || {}, options), responsiveClass = null != (ref = this.responsiveConfig.responsive_class) ? ref : this.config("responsive_class"), bootstrap && this.cloudinary_update("img." + responsiveClass + ", img.cld-hidpi", this.responsiveConfig), responsiveResize = null != (ref1 = null != (ref2 = this.responsiveConfig.responsive_resize) ? ref2 : this.config("responsive_resize")) ? ref1 : !0, responsiveResize && !this.responsiveResizeInitialized ? (this.responsiveConfig.resizing = this.responsiveResizeInitialized = !0, timeout = null, window.addEventListener("resize", function (_this) {
                            return function () {
                                var debounce, ref3, ref4, reset, run, wait, waitFunc;
                                return debounce = null != (ref3 = null != (ref4 = _this.responsiveConfig.responsive_debounce) ? ref4 : _this.config("responsive_debounce")) ? ref3 : 100, reset = function () {
                                    return timeout ? (clearTimeout(timeout), timeout = null) : void 0
                                }, run = function () {
                                    return _this.cloudinary_update("img." + responsiveClass, _this.responsiveConfig)
                                }, waitFunc = function () {
                                    return reset(), run()
                                }, wait = function () {
                                    return reset(), timeout = setTimeout(waitFunc, debounce)
                                }, debounce ? wait() : run()
                            }
                        }(this))) : void 0
                    }, Cloudinary.prototype.calc_breakpoint = function (element, width) {
                        var breakpoints, point;
                        return breakpoints = Util.getData(element, "breakpoints") || Util.getData(element, "stoppoints") || this.config("breakpoints") || this.config("stoppoints") || defaultBreakpoints, Util.isFunction(breakpoints) ? breakpoints(width) : (Util.isString(breakpoints) && (breakpoints = function () {
                            var j, len, ref, results;
                            for (ref = breakpoints.split(","), results = [], j = 0, len = ref.length; len > j; j++)point = ref[j], results.push(parseInt(point));
                            return results
                        }().sort(function (a, b) {
                            return a - b
                        })), closestAbove(breakpoints, width))
                    }, Cloudinary.prototype.calc_stoppoint = Cloudinary.prototype.calc_breakpoint, Cloudinary.prototype.device_pixel_ratio = function (roundDpr) {
                        var dpr, dprString;
                        return null == roundDpr && (roundDpr = !0), dpr = ("undefined" != typeof window && null !== window ? window.devicePixelRatio : void 0) || 1, roundDpr && (dpr = Math.ceil(dpr)), (0 >= dpr || NaN === dpr) && (dpr = 1), dprString = dpr.toString(), dprString.match(/^\d+$/) && (dprString += ".0"), dprString
                    }, defaultBreakpoints = function (width) {
                        return 100 * Math.ceil(width / 100)
                    }, closestAbove = function (list, value) {
                        var i;
                        for (i = list.length - 2; i >= 0 && list[i] >= value;)i--;
                        return list[i + 1]
                    }, cdnSubdomainNumber = function (publicId) {
                        return crc32(publicId) % 5 + 1
                    }, cloudinaryUrlPrefix = function (publicId, options) {
                        var cdnPart, host, path, protocol, ref, subdomain;
                        return 0 === (null != (ref = options.cloud_name) ? ref.indexOf("/") : void 0) ? "/res" + options.cloud_name : (protocol = "http://", cdnPart = "", subdomain = "res", host = ".cloudinary.com", path = "/" + options.cloud_name, options.protocol && (protocol = options.protocol + "//"), options.private_cdn && (cdnPart = options.cloud_name + "-", path = ""), options.cdn_subdomain && (subdomain = "res-" + cdnSubdomainNumber(publicId)), options.secure ? (protocol = "https://", options.secure_cdn_subdomain === !1 && (subdomain = "res"), null != options.secure_distribution && options.secure_distribution !== OLD_AKAMAI_SHARED_CDN && options.secure_distribution !== SHARED_CDN && (cdnPart = "", subdomain = "", host = options.secure_distribution)) : options.cname && (protocol = "http://", cdnPart = "", subdomain = options.cdn_subdomain ? "a" + (crc32(publicId) % 5 + 1) + "." : "", host = options.cname), [protocol, cdnPart, subdomain, host, path].join(""))
                    }, Cloudinary.prototype.processImageTags = function (nodes, options) {
                        var images, imgOptions, node, publicId, url;
                        return null == options && (options = {}), options = Util.defaults({}, options, this.config()), images = function () {
                            var j, len, ref, results;
                            for (results = [], j = 0, len = nodes.length; len > j; j++)node = nodes[j], "IMG" === (null != (ref = node.tagName) ? ref.toUpperCase() : void 0) && (imgOptions = Util.assign({
                                width: node.getAttribute("width"),
                                height: node.getAttribute("height"),
                                src: node.getAttribute("src")
                            }, options), publicId = imgOptions.source || imgOptions.src, delete imgOptions.source, delete imgOptions.src, url = this.url(publicId, imgOptions), imgOptions = new Transformation(imgOptions).toHtmlAttributes(), Util.setData(node, "src-cache", url), node.setAttribute("width", imgOptions.width), results.push(node.setAttribute("height", imgOptions.height)));
                            return results
                        }.call(this), this.cloudinary_update(images, options), this
                    }, applyBreakpoints = function (tag, width, options) {
                        var ref, ref1, ref2, responsive_use_breakpoints;
                        return responsive_use_breakpoints = null != (ref = null != (ref1 = null != (ref2 = options.responsive_use_breakpoints) ? ref2 : options.responsive_use_stoppoints) ? ref1 : this.config("responsive_use_breakpoints")) ? ref : this.config("responsive_use_stoppoints"), !responsive_use_breakpoints || "resize" === responsive_use_breakpoints && !options.resizing ? width : this.calc_breakpoint(tag, width)
                    }, parentWidth = function (element) {
                        var containerWidth, style;
                        for (containerWidth = 0; (element = null != element ? element.parentNode : void 0) instanceof Element && !containerWidth;)style = window.getComputedStyle(element), /^inline/.test(style.display) || (containerWidth = Util.width(element));
                        return containerWidth
                    }, Cloudinary.prototype.cloudinary_update = function (elements, options) {
                        var containerWidth, imageWidth, j, len, ref, ref1, ref2, ref3, requestedWidth, responsiveClass, roundDpr, setUrl, src, tag;
                        for (null == options && (options = {}), elements = function () {
                            switch (!1) {
                                case!Util.isArray(elements):
                                    return elements;
                                case"NodeList" !== elements.constructor.name:
                                    return elements;
                                case!Util.isString(elements):
                                    return document.querySelectorAll(elements);
                                default:
                                    return [elements]
                            }
                        }(), responsiveClass = null != (ref = null != (ref1 = this.responsiveConfig.responsive_class) ? ref1 : options.responsive_class) ? ref : this.config("responsive_class"), roundDpr = null != (ref2 = options.round_dpr) ? ref2 : this.config("round_dpr"), j = 0, len = elements.length; len > j; j++)tag = elements[j], (null != (ref3 = tag.tagName) ? ref3.match(/img/i) : void 0) && (setUrl = !0, options.responsive && Util.addClass(tag, responsiveClass), src = Util.getData(tag, "src-cache") || Util.getData(tag, "src"), Util.isEmpty(src) || (src = src.replace(/\bdpr_(1\.0|auto)\b/g, "dpr_" + this.device_pixel_ratio(roundDpr)), Util.hasClass(tag, responsiveClass) && /\bw_auto\b/.exec(src) && (containerWidth = parentWidth(tag), 0 !== containerWidth ? (requestedWidth = applyBreakpoints.call(this, tag, containerWidth, options), imageWidth = Util.getData(tag, "width") || 0, requestedWidth > imageWidth && (imageWidth = requestedWidth, Util.setData(tag, "width", requestedWidth)), src = src.replace(/\bw_auto\b/g, "w_" + imageWidth), Util.removeAttribute(tag, "width"), options.responsive_preserve_height || Util.removeAttribute(tag, "height")) : setUrl = !1), setUrl && Util.setAttribute(tag, "src", src)));
                        return this
                    }, Cloudinary.prototype.transformation = function (options) {
                        return Transformation["new"](this.config()).fromOptions(options).setParent(this)
                    }, Cloudinary
                }(), cloudinary = {
                    utf8_encode: utf8_encode,
                    crc32: crc32,
                    Util: Util,
                    Condition: Condition,
                    Transformation: Transformation,
                    Configuration: Configuration,
                    HtmlTag: HtmlTag,
                    ImageTag: ImageTag,
                    VideoTag: VideoTag,
                    Cloudinary: Cloudinary,
                    VERSION: "2.0.8"
                }
            })
        }).call(this, require("_process"))
    }, {_process: 48, lodash: 46, url: 55}],
    5: [function (require, module, exports) {
        function es() {
            throw new Error('Looks like you are expecting the previous "elasticsearch" module. It is now the "es" module. To create a client with this module use `new es.Client(params)`.')
        }

        es.Client = require("./lib/client"), es.ConnectionPool = require("./lib/connection_pool"), es.Transport = require("./lib/transport"), es.errors = require("./lib/errors"), module.exports = es
    }, {"./lib/client": 14, "./lib/connection_pool": 17, "./lib/errors": 22, "./lib/transport": 35}],
    6: [function (require, module, exports) {
        var ca = require("../client_action").makeFactoryWithModifier(function (spec) {
            return require("../utils").merge(spec, {params: {filterPath: {type: "list", name: "filter_path"}}})
        }), namespace = require("../client_action").namespaceFactory, api = module.exports = {};
        api._namespaces = ["cat", "cluster", "indices", "nodes", "snapshot"], api.bulk = ca({
            params: {
                consistency: {
                    type: "enum",
                    options: ["one", "quorum", "all"]
                },
                refresh: {type: "boolean"},
                replication: {type: "enum", "default": "sync", options: ["sync", "async"]},
                routing: {type: "string"},
                timeout: {type: "time"},
                type: {type: "string"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_bulk",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_bulk", req: {index: {type: "string"}}}, {fmt: "/_bulk"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.cat = namespace(), api.cat.prototype.aliases = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/aliases/<%=name%>", req: {name: {type: "list"}}}, {fmt: "/_cat/aliases"}]
        }), api.cat.prototype.allocation = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/allocation/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cat/allocation"}]
        }), api.cat.prototype.count = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/count/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/count"}]
        }), api.cat.prototype.fielddata = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1},
                fields: {type: "list"}
            }, urls: [{fmt: "/_cat/fielddata/<%=fields%>", req: {fields: {type: "list"}}}, {fmt: "/_cat/fielddata"}]
        }), api.cat.prototype.health = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                ts: {type: "boolean", "default": !0},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/health"}
        }), api.cat.prototype.help = ca({
            params: {help: {type: "boolean", "default": !1}},
            url: {fmt: "/_cat"}
        }), api.cat.prototype.indices = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                pri: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/indices/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/indices"}]
        }), api.cat.prototype.master = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/master"}
        }), api.cat.prototype.nodes = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/nodes"}
        }), api.cat.prototype.pendingTasks = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/pending_tasks"}
        }), api.cat.prototype.plugins = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/plugins"}
        }), api.cat.prototype.recovery = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/recovery/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/recovery"}]
        }), api.cat.prototype.segments = ca({
            params: {
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !0}
            }, urls: [{fmt: "/_cat/segments/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/segments"}]
        }), api.cat.prototype.shards = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/shards/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/shards"}]
        }), api.cat.prototype.threadPool = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1},
                fullId: {type: "boolean", "default": !1, name: "full_id"}
            }, url: {fmt: "/_cat/thread_pool"}
        }), api.clearScroll = ca({
            urls: [{
                fmt: "/_search/scroll/<%=scrollId%>",
                req: {scrollId: {type: "list"}}
            }, {fmt: "/_search/scroll"}], method: "DELETE"
        }), api.cluster = namespace(), api.cluster.prototype.getSettings = ca({
            params: {
                flatSettings: {
                    type: "boolean",
                    name: "flat_settings"
                }, masterTimeout: {type: "time", name: "master_timeout"}, timeout: {type: "time"}
            }, url: {fmt: "/_cluster/settings"}
        }), api.cluster.prototype.health = ca({
            params: {
                level: {
                    type: "enum",
                    "default": "cluster",
                    options: ["cluster", "indices", "shards"]
                },
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                waitForActiveShards: {type: "number", name: "wait_for_active_shards"},
                waitForNodes: {type: "string", name: "wait_for_nodes"},
                waitForRelocatingShards: {type: "number", name: "wait_for_relocating_shards"},
                waitForStatus: {
                    type: "enum",
                    "default": null,
                    options: ["green", "yellow", "red"],
                    name: "wait_for_status"
                }
            }, urls: [{fmt: "/_cluster/health/<%=index%>", req: {index: {type: "string"}}}, {fmt: "/_cluster/health"}]
        }), api.cluster.prototype.pendingTasks = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_cluster/pending_tasks"}
        }), api.cluster.prototype.putSettings = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/settings"}, method: "PUT"
        }), api.cluster.prototype.reroute = ca({
            params: {
                dryRun: {type: "boolean", name: "dry_run"},
                explain: {type: "boolean"},
                metric: {
                    type: "list",
                    options: ["_all", "blocks", "metadata", "nodes", "routing_table", "master_node", "version"]
                },
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/reroute"}, method: "POST"
        }), api.cluster.prototype.state = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/_cluster/state/<%=metric%>/<%=index%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }, index: {type: "list"}
                }
            }, {
                fmt: "/_cluster/state/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }
                }
            }, {fmt: "/_cluster/state"}]
        }), api.cluster.prototype.stats = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_cluster/stats/nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cluster/stats"}]
        }), api.count = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                minScore: {type: "number", name: "min_score"},
                preference: {type: "string"},
                routing: {type: "string"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_count",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_count", req: {index: {type: "list"}}}, {fmt: "/_count"}],
            method: "POST"
        }), api.countPercolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate/count",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate/count", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api["delete"] = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                replication: {type: "enum", "default": "sync", options: ["sync", "async"]},
                routing: {type: "string"},
                timeout: {type: "time"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "DELETE"
        }), api.deleteByQuery = ca({
            params: {
                analyzer: {type: "string"},
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                replication: {type: "enum", "default": "sync", options: ["sync", "async"]},
                q: {type: "string"},
                routing: {type: "string"},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_query",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_query", req: {index: {type: "list"}}}],
            method: "DELETE"
        }), api.deleteScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            method: "DELETE"
        }), api.deleteTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, method: "DELETE"
        }), api.exists = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "HEAD"
        }), api.explain = ca({
            params: {
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                analyzer: {type: "string"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                fields: {type: "list"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                parent: {type: "string"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_explain",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }), api.fieldStats = ca({
            params: {
                fields: {type: "list"},
                level: {type: "enum", "default": "cluster", options: ["indices", "cluster"]},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{fmt: "/<%=index%>/_field_stats", req: {index: {type: "list"}}}, {fmt: "/_field_stats"}],
            method: "POST"
        }), api.get = ca({
            params: {
                fields: {type: "list"},
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {
                    type: "list",
                    name: "_source_include"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}}
        }), api.getSource = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_source",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}
        }), api.index = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                opType: {type: "enum", "default": "index", options: ["index", "create"], name: "op_type"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                replication: {type: "enum", "default": "sync", options: ["sync", "async"]},
                routing: {type: "string"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "string"}, type: {type: "string"}}}],
            needBody: !0,
            method: "POST"
        }), api.indices = namespace(), api.indices.prototype.analyze = ca({
            params: {
                analyzer: {type: "string"},
                charFilters: {type: "list", name: "char_filters"},
                field: {type: "string"},
                filters: {type: "list"},
                index: {type: "string"},
                preferLocal: {type: "boolean", name: "prefer_local"},
                text: {type: "string"},
                tokenizer: {type: "string"},
                format: {type: "enum", "default": "detailed", options: ["detailed", "text"]}
            }, urls: [{fmt: "/<%=index%>/_analyze", req: {index: {type: "string"}}}, {fmt: "/_analyze"}], method: "POST"
        }), api.indices.prototype.clearCache = ca({
            params: {
                fieldData: {type: "boolean", name: "field_data"},
                fielddata: {type: "boolean"},
                fields: {type: "list"},
                filter: {type: "boolean"},
                filterCache: {type: "boolean", name: "filter_cache"},
                filterKeys: {type: "boolean", name: "filter_keys"},
                id: {type: "boolean"},
                idCache: {type: "boolean", name: "id_cache"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                index: {type: "list"},
                recycler: {type: "boolean"},
                queryCache: {type: "boolean", name: "query_cache"}
            },
            urls: [{fmt: "/<%=index%>/_cache/clear", req: {index: {type: "list"}}}, {fmt: "/_cache/clear"}],
            method: "POST"
        }), api.indices.prototype.close = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_close", req: {index: {type: "string"}}}, method: "POST"
        }), api.indices.prototype.create = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "string"}}}, method: "POST"
        }), api.indices.prototype["delete"] = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "DELETE"
        }), api.indices.prototype.deleteAlias = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            },
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.deleteMapping = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {fmt: "/<%=index%>/<%=type%>/_mapping", req: {index: {type: "list"}, type: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.deleteTemplate = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "DELETE"
        }), api.indices.prototype.deleteWarmer = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                name: {type: "list"}
            },
            url: {fmt: "/<%=index%>/_warmer/<%=name%>", req: {index: {type: "list"}, name: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.exists = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.existsAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }],
            method: "HEAD"
        }), api.indices.prototype.existsTemplate = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "HEAD"
        }), api.indices.prototype.existsType = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "list"}, type: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.flush = ca({
            params: {
                force: {type: "boolean"},
                waitIfOngoing: {type: "boolean", name: "wait_if_ongoing"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, urls: [{fmt: "/<%=index%>/_flush", req: {index: {type: "list"}}}, {fmt: "/_flush"}], method: "POST"
        }), api.indices.prototype.flushSynced = ca({
            urls: [{
                fmt: "/<%=index%>/_flush/synced",
                req: {index: {type: "list"}}
            }, {fmt: "/_flush/synced"}], method: "POST"
        }), api.indices.prototype.get = ca({
            params: {
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=feature%>",
                req: {index: {type: "list"}, feature: {type: "list"}}
            }, {fmt: "/<%=index%>", req: {index: {type: "list"}}}]
        }), api.indices.prototype.getAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }, {fmt: "/_alias"}]
        }), api.indices.prototype.getAliases = ca({
            params: {timeout: {type: "time"}, local: {type: "boolean"}},
            urls: [{
                fmt: "/<%=index%>/_aliases/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_aliases", req: {index: {type: "list"}}}, {
                fmt: "/_aliases/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_aliases"}]
        }), api.indices.prototype.getFieldMapping = ca({
            params: {
                includeDefaults: {
                    type: "boolean",
                    name: "include_defaults"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>/field/<%=field%>",
                req: {index: {type: "list"}, type: {type: "list"}, field: {type: "list"}}
            }, {
                fmt: "/<%=index%>/_mapping/field/<%=field%>",
                req: {index: {type: "list"}, field: {type: "list"}}
            }, {
                fmt: "/_mapping/<%=type%>/field/<%=field%>",
                req: {type: {type: "list"}, field: {type: "list"}}
            }, {fmt: "/_mapping/field/<%=field%>", req: {field: {type: "list"}}}]
        }), api.indices.prototype.getMapping = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_mapping", req: {index: {type: "list"}}}, {
                fmt: "/_mapping/<%=type%>",
                req: {type: {type: "list"}}
            }, {fmt: "/_mapping"}]
        }), api.indices.prototype.getSettings = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"},
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_settings/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {
                fmt: "/_settings/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_settings"}]
        }), api.indices.prototype.getTemplate = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, {fmt: "/_template"}]
        }), api.indices.prototype.getUpgrade = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}]
        }), api.indices.prototype.getWarmer = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, type: {type: "list"}, name: {type: "list"}}
            }, {
                fmt: "/<%=index%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_warmer", req: {index: {type: "list"}}}, {
                fmt: "/_warmer/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_warmer"}]
        }), api.indices.prototype.open = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "closed",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_open", req: {index: {type: "string"}}}, method: "POST"
        }), api.indices.prototype.optimize = ca({
            params: {
                flush: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                maxNumSegments: {type: "number", name: "max_num_segments"},
                onlyExpungeDeletes: {type: "boolean", name: "only_expunge_deletes"},
                operationThreading: {name: "operation_threading"},
                waitForMerge: {type: "boolean", name: "wait_for_merge"},
                force: {type: "boolean"}
            }, urls: [{fmt: "/<%=index%>/_optimize", req: {index: {type: "list"}}}, {fmt: "/_optimize"}], method: "POST"
        }), api.indices.prototype.putAlias = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            },
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "string"}}},
            method: "PUT"
        }), api.indices.prototype.putMapping = ca({
            params: {
                ignoreConflicts: {
                    type: "boolean",
                    name: "ignore_conflicts"
                },
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "string"}}
            }, {fmt: "/_mapping/<%=type%>", req: {type: {type: "string"}}}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putSettings = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"}
            },
            urls: [{fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {fmt: "/_settings"}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putTemplate = ca({
            params: {
                order: {type: "number"},
                create: {type: "boolean", "default": !1},
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.indices.prototype.putWarmer = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, type: {type: "list"}, name: {type: "string"}}
            }, {
                fmt: "/<%=index%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, name: {type: "string"}}
            }, {fmt: "/_warmer/<%=name%>", req: {name: {type: "string"}}}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.recovery = ca({
            params: {
                detailed: {type: "boolean", "default": !1},
                activeOnly: {type: "boolean", "default": !1, name: "active_only"},
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_recovery", req: {index: {type: "list"}}}, {fmt: "/_recovery"}]
        }), api.indices.prototype.refresh = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                force: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_refresh", req: {index: {type: "list"}}}, {fmt: "/_refresh"}], method: "POST"
        }), api.indices.prototype.segments = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_segments", req: {index: {type: "list"}}}, {fmt: "/_segments"}]
        }), api.indices.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "list"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "indices", options: ["cluster", "indices", "shards"]},
                types: {type: "list"}
            },
            urls: [{
                fmt: "/<%=index%>/_stats/<%=metric%>",
                req: {
                    index: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "filter_cache", "flush", "get", "id_cache", "indexing", "merge", "percolate", "query_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "filter_cache", "flush", "get", "id_cache", "indexing", "merge", "percolate", "query_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/<%=index%>/_stats", req: {index: {type: "list"}}}, {fmt: "/_stats"}]
        }), api.indices.prototype.status = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"},
                recovery: {type: "boolean"},
                snapshot: {type: "boolean"}
            }, urls: [{fmt: "/<%=index%>/_status", req: {index: {type: "list"}}}, {fmt: "/_status"}]
        }), api.indices.prototype.updateAliases = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_aliases"}, needBody: !0, method: "POST"
        }), api.indices.prototype.upgrade = ca({
            params: {
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                waitForCompletion: {type: "boolean", name: "wait_for_completion"},
                onlyAncientSegments: {type: "boolean", name: "only_ancient_segments"}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}], method: "POST"
        }), api.indices.prototype.validateQuery = ca({
            params: {
                explain: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                operationThreading: {name: "operation_threading"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                rewrite: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_validate/query",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_validate/query", req: {index: {type: "list"}}}, {fmt: "/_validate/query"}],
            method: "POST"
        }), api.info = ca({url: {fmt: "/"}}), api.mget = ca({
            params: {
                fields: {type: "list"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mget",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mget", req: {index: {type: "string"}}}, {fmt: "/_mget"}],
            needBody: !0,
            method: "POST"
        }), api.mlt = ca({
            params: {
                boostTerms: {type: "number", name: "boost_terms"},
                maxDocFreq: {type: "number", name: "max_doc_freq"},
                maxQueryTerms: {type: "number", name: "max_query_terms"},
                maxWordLength: {type: "number", name: "max_word_length"},
                minDocFreq: {type: "number", name: "min_doc_freq"},
                minTermFreq: {type: "number", name: "min_term_freq"},
                minWordLength: {type: "number", name: "min_word_length"},
                mltFields: {type: "list", name: "mlt_fields"},
                percentTermsToMatch: {type: "number", name: "percent_terms_to_match"},
                routing: {type: "string"},
                searchFrom: {type: "number", name: "search_from"},
                searchIndices: {type: "list", name: "search_indices"},
                searchScroll: {type: "string", name: "search_scroll"},
                searchSize: {type: "number", name: "search_size"},
                searchSource: {type: "string", name: "search_source"},
                searchType: {type: "string", name: "search_type"},
                searchTypes: {type: "list", name: "search_types"},
                stopWords: {type: "list", name: "stop_words"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_mlt",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }), api.mpercolate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mpercolate",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mpercolate", req: {index: {type: "string"}}}, {fmt: "/_mpercolate"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.msearch = ca({
            params: {
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch", "count", "scan"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_msearch",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_msearch", req: {index: {type: "list"}}}, {fmt: "/_msearch"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.mtermvectors = ca({
            params: {
                ids: {type: "list", required: !1},
                termStatistics: {type: "boolean", "default": !1, required: !1, name: "term_statistics"},
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mtermvectors",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mtermvectors", req: {index: {type: "string"}}}, {fmt: "/_mtermvectors"}],
            method: "POST"
        }), api.nodes = namespace(), api.nodes.prototype.hotThreads = ca({
            params: {
                interval: {type: "time"},
                snapshots: {type: "number"},
                threads: {type: "number"},
                ignoreIdleThreads: {type: "boolean", name: "ignore_idle_threads"},
                type: {type: "enum", options: ["cpu", "wait", "block"]},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_nodes/<%=nodeId%>/hotthreads", req: {nodeId: {type: "list"}}}, {fmt: "/_nodes/hotthreads"}]
        }), api.nodes.prototype.info = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "network", "transport", "http", "plugins"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "network", "transport", "http", "plugins"]
                    }
                }
            }, {fmt: "/_nodes"}]
        }), api.nodes.prototype.shutdown = ca({
            params: {delay: {type: "time"}, exit: {type: "boolean"}},
            urls: [{fmt: "/_cluster/nodes/<%=nodeId%>/_shutdown", req: {nodeId: {type: "list"}}}, {fmt: "/_shutdown"}],
            method: "POST"
        }), api.nodes.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "boolean"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "node", options: ["node", "indices", "shards"]},
                types: {type: "list"},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "network", "os", "process", "thread_pool", "transport"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "filter_cache", "flush", "get", "id_cache", "indexing", "merge", "percolate", "query_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "network", "os", "process", "thread_pool", "transport"]
                    }
                }
            }, {
                fmt: "/_nodes/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "network", "os", "process", "thread_pool", "transport"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "filter_cache", "flush", "get", "id_cache", "indexing", "merge", "percolate", "query_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>/stats", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "network", "os", "process", "thread_pool", "transport"]
                    }
                }
            }, {fmt: "/_nodes/stats"}]
        }), api.percolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateFormat: {type: "enum", options: ["ids"], name: "percolate_format"},
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                percolateRouting: {type: "string", name: "percolate_routing"},
                percolatePreference: {type: "string", name: "percolate_preference"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api.ping = ca({
            url: {fmt: "/"},
            requestTimeout: 3e3,
            method: "HEAD"
        }), api.putScript = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            needBody: !0,
            method: "PUT"
        }), api.putTemplate = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.scroll = ca({
            params: {scroll: {type: "duration"}, scrollId: {type: "string", name: "scroll_id"}},
            urls: [{fmt: "/_search/scroll/<%=scrollId%>", req: {scrollId: {type: "string"}}}, {fmt: "/_search/scroll"}],
            paramAsBody: "scrollId",
            method: "POST"
        }), api.search = ca({
            params: {
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                explain: {type: "boolean"},
                fields: {type: "list"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                from: {type: "number"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch", "count", "scan"],
                    name: "search_type"
                },
                size: {type: "number"},
                sort: {type: "list"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                stats: {type: "list"},
                suggestField: {type: "string", name: "suggest_field"},
                suggestMode: {
                    type: "enum",
                    "default": "missing",
                    options: ["missing", "popular", "always"],
                    name: "suggest_mode"
                },
                suggestSize: {type: "number", name: "suggest_size"},
                suggestText: {type: "text", name: "suggest_text"},
                timeout: {type: "time"},
                trackScores: {type: "boolean", name: "track_scores"},
                version: {type: "boolean"},
                queryCache: {type: "boolean", name: "query_cache"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search", req: {index: {type: "list"}}}, {fmt: "/_search"}],
            method: "POST"
        }), api.searchExists = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                minScore: {type: "number", name: "min_score"},
                preference: {type: "string"},
                routing: {type: "string"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search/exists",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search/exists", req: {index: {type: "list"}}}, {fmt: "/_search/exists"}],
            method: "POST"
        }), api.searchShards = ca({
            params: {
                preference: {type: "string"},
                routing: {type: "string"},
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search_shards",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_search_shards", req: {index: {type: "string"}}}, {fmt: "/_search_shards"}],
            method: "POST"
        }), api.searchTemplate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch", "count", "scan"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search/template",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search/template", req: {index: {type: "list"}}}, {fmt: "/_search/template"}],
            method: "POST"
        }),api.snapshot = namespace(),api.snapshot.prototype.create = ca({
            params: {
                masterTimeout: {
                    type: "time",
                    name: "master_timeout"
                }, waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.createRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                verify: {type: "boolean"}
            },
            url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "string"}}},
            needBody: !0,
            method: "POST"
        }),api.snapshot.prototype["delete"] = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "DELETE"
        }),api.snapshot.prototype.deleteRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, method: "DELETE"
        }),api.snapshot.prototype.get = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }
        }),api.snapshot.prototype.getRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, {fmt: "/_snapshot"}]
        }),api.snapshot.prototype.restore = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_restore",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.status = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}}, urls: [{
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_status",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }, {
                fmt: "/_snapshot/<%=repository%>/_status",
                req: {repository: {type: "string"}}
            }, {fmt: "/_snapshot/_status"}]
        }),api.snapshot.prototype.verifyRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>/_verify", req: {repository: {type: "string"}}}, method: "POST"
        }),api.suggest = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "string"}
            },
            urls: [{fmt: "/<%=index%>/_suggest", req: {index: {type: "list"}}}, {fmt: "/_suggest"}],
            needBody: !0,
            method: "POST"
        }),api.termvector = ca({
            params: {
                termStatistics: {
                    type: "boolean",
                    "default": !1,
                    required: !1,
                    name: "term_statistics"
                },
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_termvector",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_termvector", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }),api.update = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                fields: {type: "list"},
                lang: {type: "string"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                replication: {type: "enum", "default": "sync", options: ["sync", "async"]},
                retryOnConflict: {type: "number", name: "retry_on_conflict"},
                routing: {type: "string"},
                script: {},
                scriptId: {name: "script_id"},
                scriptedUpsert: {type: "boolean", name: "scripted_upsert"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {type: "enum", options: ["internal", "force"], name: "version_type"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_update",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }),api.create = ca.proxy(api.index, {
            transform: function (params) {
                params.op_type = "create"
            }
        })
    }, {"../client_action": 15, "../utils": 38}],
    7: [function (require, module, exports) {
        var ca = require("../client_action").makeFactoryWithModifier(function (spec) {
            return require("../utils").merge(spec, {params: {filterPath: {type: "list", name: "filter_path"}}})
        }), namespace = require("../client_action").namespaceFactory, api = module.exports = {};
        api._namespaces = ["cat", "cluster", "indices", "nodes", "snapshot"], api.bulk = ca({
            params: {
                consistency: {
                    type: "enum",
                    options: ["one", "quorum", "all"]
                },
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                type: {type: "string"},
                fields: {type: "list"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_bulk",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_bulk", req: {index: {type: "string"}}}, {fmt: "/_bulk"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.cat = namespace(), api.cat.prototype.aliases = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/aliases/<%=name%>", req: {name: {type: "list"}}}, {fmt: "/_cat/aliases"}]
        }), api.cat.prototype.allocation = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/allocation/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cat/allocation"}]
        }), api.cat.prototype.count = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/count/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/count"}]
        }), api.cat.prototype.fielddata = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1},
                fields: {type: "list"}
            }, urls: [{fmt: "/_cat/fielddata/<%=fields%>", req: {fields: {type: "list"}}}, {fmt: "/_cat/fielddata"}]
        }), api.cat.prototype.health = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                ts: {type: "boolean", "default": !0},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/health"}
        }), api.cat.prototype.help = ca({
            params: {help: {type: "boolean", "default": !1}},
            url: {fmt: "/_cat"}
        }), api.cat.prototype.indices = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                pri: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/indices/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/indices"}]
        }), api.cat.prototype.master = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/master"}
        }), api.cat.prototype.nodeattrs = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/nodeattrs"}
        }), api.cat.prototype.nodes = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/nodes"}
        }), api.cat.prototype.pendingTasks = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/pending_tasks"}
        }), api.cat.prototype.plugins = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/plugins"}
        }), api.cat.prototype.recovery = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/recovery/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/recovery"}]
        }), api.cat.prototype.segments = ca({
            params: {
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/segments/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/segments"}]
        }), api.cat.prototype.shards = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/shards/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/shards"}]
        }), api.cat.prototype.threadPool = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1},
                fullId: {type: "boolean", "default": !1, name: "full_id"}
            }, url: {fmt: "/_cat/thread_pool"}
        }), api.clearScroll = ca({
            urls: [{
                fmt: "/_search/scroll/<%=scrollId%>",
                req: {scrollId: {type: "list"}}
            }, {fmt: "/_search/scroll"}], method: "DELETE"
        }), api.cluster = namespace(), api.cluster.prototype.getSettings = ca({
            params: {
                flatSettings: {
                    type: "boolean",
                    name: "flat_settings"
                }, masterTimeout: {type: "time", name: "master_timeout"}, timeout: {type: "time"}
            }, url: {fmt: "/_cluster/settings"}
        }), api.cluster.prototype.health = ca({
            params: {
                level: {
                    type: "enum",
                    "default": "cluster",
                    options: ["cluster", "indices", "shards"]
                },
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                waitForActiveShards: {type: "number", name: "wait_for_active_shards"},
                waitForNodes: {type: "string", name: "wait_for_nodes"},
                waitForRelocatingShards: {type: "number", name: "wait_for_relocating_shards"},
                waitForStatus: {
                    type: "enum",
                    "default": null,
                    options: ["green", "yellow", "red"],
                    name: "wait_for_status"
                }
            }, urls: [{fmt: "/_cluster/health/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cluster/health"}]
        }), api.cluster.prototype.pendingTasks = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_cluster/pending_tasks"}
        }), api.cluster.prototype.putSettings = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/settings"}, method: "PUT"
        }), api.cluster.prototype.reroute = ca({
            params: {
                dryRun: {type: "boolean", name: "dry_run"},
                explain: {type: "boolean"},
                metric: {
                    type: "list",
                    options: ["_all", "blocks", "metadata", "nodes", "routing_table", "master_node", "version"]
                },
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/reroute"}, method: "POST"
        }), api.cluster.prototype.state = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/_cluster/state/<%=metric%>/<%=index%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }, index: {type: "list"}
                }
            }, {
                fmt: "/_cluster/state/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }
                }
            }, {fmt: "/_cluster/state"}]
        }), api.cluster.prototype.stats = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_cluster/stats/nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cluster/stats"}]
        }), api.count = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                minScore: {type: "number", name: "min_score"},
                preference: {type: "string"},
                routing: {type: "string"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_count",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_count", req: {index: {type: "list"}}}, {fmt: "/_count"}],
            method: "POST"
        }), api.countPercolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate/count",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate/count", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api["delete"] = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "DELETE"
        }), api.deleteScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            method: "DELETE"
        }), api.deleteTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, method: "DELETE"
        }), api.exists = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "HEAD"
        }), api.explain = ca({
            params: {
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                analyzer: {type: "string"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                fields: {type: "list"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                parent: {type: "string"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_explain",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }), api.fieldStats = ca({
            params: {
                fields: {type: "list"},
                level: {type: "enum", "default": "cluster", options: ["indices", "cluster"]},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{fmt: "/<%=index%>/_field_stats", req: {index: {type: "list"}}}, {fmt: "/_field_stats"}],
            method: "POST"
        }), api.get = ca({
            params: {
                fields: {type: "list"},
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}}
        }), api.getSource = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_source",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}
        }), api.index = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                opType: {type: "enum", "default": "index", options: ["index", "create"], name: "op_type"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "string"}, type: {type: "string"}}}],
            needBody: !0,
            method: "POST"
        }), api.indices = namespace(), api.indices.prototype.analyze = ca({
            params: {
                analyzer: {type: "string"},
                charFilters: {type: "list", name: "char_filters"},
                field: {type: "string"},
                filters: {type: "list"},
                index: {type: "string"},
                preferLocal: {type: "boolean", name: "prefer_local"},
                text: {type: "list"},
                tokenizer: {type: "string"},
                format: {type: "enum", "default": "detailed", options: ["detailed", "text"]}
            }, urls: [{fmt: "/<%=index%>/_analyze", req: {index: {type: "string"}}}, {fmt: "/_analyze"}], method: "POST"
        }), api.indices.prototype.clearCache = ca({
            params: {
                fieldData: {type: "boolean", name: "field_data"},
                fielddata: {type: "boolean"},
                fields: {type: "list"},
                query: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                index: {type: "list"},
                recycler: {type: "boolean"},
                request: {type: "boolean"}
            },
            urls: [{fmt: "/<%=index%>/_cache/clear", req: {index: {type: "list"}}}, {fmt: "/_cache/clear"}],
            method: "POST"
        }), api.indices.prototype.close = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_close", req: {index: {type: "list"}}}, method: "POST"
        }), api.indices.prototype.create = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                updateAllTypes: {type: "boolean", name: "update_all_types"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "string"}}}, method: "POST"
        }), api.indices.prototype["delete"] = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "DELETE"
        }), api.indices.prototype.deleteAlias = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            },
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.deleteTemplate = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "DELETE"
        }), api.indices.prototype.deleteWarmer = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                name: {type: "list"}
            },
            url: {fmt: "/<%=index%>/_warmer/<%=name%>", req: {index: {type: "list"}, name: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.exists = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.existsAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }],
            method: "HEAD"
        }), api.indices.prototype.existsTemplate = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "HEAD"
        }), api.indices.prototype.existsType = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "list"}, type: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.flush = ca({
            params: {
                force: {type: "boolean"},
                waitIfOngoing: {type: "boolean", name: "wait_if_ongoing"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, urls: [{fmt: "/<%=index%>/_flush", req: {index: {type: "list"}}}, {fmt: "/_flush"}], method: "POST"
        }), api.indices.prototype.flushSynced = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{fmt: "/<%=index%>/_flush/synced", req: {index: {type: "list"}}}, {fmt: "/_flush/synced"}],
            method: "POST"
        }), api.indices.prototype.get = ca({
            params: {
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1}
            },
            urls: [{
                fmt: "/<%=index%>/<%=feature%>",
                req: {
                    index: {type: "list"},
                    feature: {type: "list", options: ["_settings", "_mappings", "_warmers", "_aliases"]}
                }
            }, {fmt: "/<%=index%>", req: {index: {type: "list"}}}]
        }), api.indices.prototype.getAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }, {fmt: "/_alias"}]
        }), api.indices.prototype.getAliases = ca({
            params: {timeout: {type: "time"}, local: {type: "boolean"}},
            urls: [{
                fmt: "/<%=index%>/_aliases/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_aliases", req: {index: {type: "list"}}}, {
                fmt: "/_aliases/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_aliases"}]
        }), api.indices.prototype.getFieldMapping = ca({
            params: {
                includeDefaults: {
                    type: "boolean",
                    name: "include_defaults"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>/field/<%=fields%>",
                req: {index: {type: "list"}, type: {type: "list"}, fields: {type: "list"}}
            }, {
                fmt: "/<%=index%>/_mapping/field/<%=fields%>",
                req: {index: {type: "list"}, fields: {type: "list"}}
            }, {
                fmt: "/_mapping/<%=type%>/field/<%=fields%>",
                req: {type: {type: "list"}, fields: {type: "list"}}
            }, {fmt: "/_mapping/field/<%=fields%>", req: {fields: {type: "list"}}}]
        }), api.indices.prototype.getMapping = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_mapping", req: {index: {type: "list"}}}, {
                fmt: "/_mapping/<%=type%>",
                req: {type: {type: "list"}}
            }, {fmt: "/_mapping"}]
        }), api.indices.prototype.getSettings = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"},
                local: {type: "boolean"},
                human: {type: "boolean", "default": !1}
            },
            urls: [{
                fmt: "/<%=index%>/_settings/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {
                fmt: "/_settings/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_settings"}]
        }), api.indices.prototype.getTemplate = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_template/<%=name%>", req: {name: {type: "list"}}}, {fmt: "/_template"}]
        }), api.indices.prototype.getUpgrade = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}]
        }), api.indices.prototype.getWarmer = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, type: {type: "list"}, name: {type: "list"}}
            }, {
                fmt: "/<%=index%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_warmer", req: {index: {type: "list"}}}, {
                fmt: "/_warmer/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_warmer"}]
        }), api.indices.prototype.open = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "closed",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_open", req: {index: {type: "list"}}}, method: "POST"
        }), api.indices.prototype.optimize = ca({
            params: {
                flush: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                maxNumSegments: {type: "number", name: "max_num_segments"},
                onlyExpungeDeletes: {type: "boolean", name: "only_expunge_deletes"},
                operationThreading: {name: "operation_threading"},
                waitForMerge: {type: "boolean", name: "wait_for_merge"}
            }, urls: [{fmt: "/<%=index%>/_optimize", req: {index: {type: "list"}}}, {fmt: "/_optimize"}], method: "POST"
        }), api.indices.prototype.putAlias = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            },
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "string"}}},
            method: "PUT"
        }), api.indices.prototype.putMapping = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                updateAllTypes: {type: "boolean", name: "update_all_types"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "string"}}
            }, {fmt: "/_mapping/<%=type%>", req: {type: {type: "string"}}}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putSettings = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"}
            },
            urls: [{fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {fmt: "/_settings"}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putTemplate = ca({
            params: {
                order: {type: "number"},
                create: {type: "boolean", "default": !1},
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.indices.prototype.putWarmer = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                requestCache: {type: "boolean", name: "request_cache"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, type: {type: "list"}, name: {type: "string"}}
            }, {
                fmt: "/<%=index%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, name: {type: "string"}}
            }, {fmt: "/_warmer/<%=name%>", req: {name: {type: "string"}}}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.recovery = ca({
            params: {
                detailed: {type: "boolean", "default": !1},
                activeOnly: {type: "boolean", "default": !1, name: "active_only"},
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_recovery", req: {index: {type: "list"}}}, {fmt: "/_recovery"}]
        }), api.indices.prototype.refresh = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                force: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_refresh", req: {index: {type: "list"}}}, {fmt: "/_refresh"}], method: "POST"
        }), api.indices.prototype.segments = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"},
                verbose: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_segments", req: {index: {type: "list"}}}, {fmt: "/_segments"}]
        }), api.indices.prototype.shardStores = ca({
            params: {
                status: {
                    type: "list",
                    options: ["green", "yellow", "red", "all"]
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_shard_stores", req: {index: {type: "list"}}}, {fmt: "/_shard_stores"}]
        }), api.indices.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "list"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "indices", options: ["cluster", "indices", "shards"]},
                types: {type: "list"}
            },
            urls: [{
                fmt: "/<%=index%>/_stats/<%=metric%>",
                req: {
                    index: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/<%=index%>/_stats", req: {index: {type: "list"}}}, {fmt: "/_stats"}]
        }), api.indices.prototype.updateAliases = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_aliases"}, needBody: !0, method: "POST"
        }), api.indices.prototype.upgrade = ca({
            params: {
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                waitForCompletion: {type: "boolean", name: "wait_for_completion"},
                onlyAncientSegments: {type: "boolean", name: "only_ancient_segments"}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}], method: "POST"
        }), api.indices.prototype.validateQuery = ca({
            params: {
                explain: {type: "boolean"},
                ignoreUnavailable: {
                    type: "boolean", name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                operationThreading: {name: "operation_threading"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                rewrite: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_validate/query",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_validate/query", req: {index: {type: "list"}}}, {fmt: "/_validate/query"}],
            method: "POST"
        }), api.info = ca({url: {fmt: "/"}}), api.mget = ca({
            params: {
                fields: {type: "list"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mget",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mget", req: {index: {type: "string"}}}, {fmt: "/_mget"}],
            needBody: !0,
            method: "POST"
        }), api.mpercolate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mpercolate",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mpercolate", req: {index: {type: "string"}}}, {fmt: "/_mpercolate"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.msearch = ca({
            params: {
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch", "count", "scan"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_msearch",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_msearch", req: {index: {type: "list"}}}, {fmt: "/_msearch"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.mtermvectors = ca({
            params: {
                ids: {type: "list", required: !1},
                termStatistics: {type: "boolean", "default": !1, required: !1, name: "term_statistics"},
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mtermvectors",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mtermvectors", req: {index: {type: "string"}}}, {fmt: "/_mtermvectors"}],
            method: "POST"
        }), api.nodes = namespace(), api.nodes.prototype.hotThreads = ca({
            params: {
                interval: {type: "time"},
                snapshots: {type: "number"},
                threads: {type: "number"},
                ignoreIdleThreads: {type: "boolean", name: "ignore_idle_threads"},
                type: {type: "enum", options: ["cpu", "wait", "block"]},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_nodes/<%=nodeId%>/hotthreads", req: {nodeId: {type: "list"}}}, {fmt: "/_nodes/hotthreads"}]
        }), api.nodes.prototype.info = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "transport", "http", "plugins"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "transport", "http", "plugins"]
                    }
                }
            }, {fmt: "/_nodes"}]
        }), api.nodes.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "boolean"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "node", options: ["node", "indices", "shards"]},
                types: {type: "list"},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    }
                }
            }, {
                fmt: "/_nodes/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>/stats", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    }
                }
            }, {fmt: "/_nodes/stats"}]
        }), api.percolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                percolateRouting: {type: "string", name: "percolate_routing"},
                percolatePreference: {type: "string", name: "percolate_preference"},
                percolateFormat: {type: "enum", options: ["ids"], name: "percolate_format"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api.ping = ca({
            url: {fmt: "/"},
            requestTimeout: 3e3,
            method: "HEAD"
        }), api.putScript = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            needBody: !0,
            method: "PUT"
        }), api.putTemplate = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.renderSearchTemplate = ca({
            urls: [{
                fmt: "/_render/template/<%=id%>",
                req: {id: {type: "string"}}
            }, {fmt: "/_render/template"}], method: "POST"
        }), api.scroll = ca({
            params: {scroll: {type: "duration"}, scrollId: {type: "string", name: "scroll_id"}},
            urls: [{fmt: "/_search/scroll/<%=scrollId%>", req: {scrollId: {type: "string"}}}, {fmt: "/_search/scroll"}],
            paramAsBody: "scrollId",
            method: "POST"
        }), api.search = ca({
            params: {
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                explain: {type: "boolean"},
                fields: {type: "list"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                from: {type: "number"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "dfs_query_then_fetch", "count", "scan"],
                    name: "search_type"
                },
                size: {type: "number"},
                sort: {type: "list"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                terminateAfter: {type: "number", name: "terminate_after"},
                stats: {type: "list"},
                suggestField: {type: "string", name: "suggest_field"},
                suggestMode: {
                    type: "enum",
                    "default": "missing",
                    options: ["missing", "popular", "always"],
                    name: "suggest_mode"
                },
                suggestSize: {type: "number", name: "suggest_size"},
                suggestText: {type: "text", name: "suggest_text"},
                timeout: {type: "time"},
                trackScores: {type: "boolean", name: "track_scores"},
                version: {type: "boolean"},
                requestCache: {type: "boolean", name: "request_cache"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search", req: {index: {type: "list"}}}, {fmt: "/_search"}],
            method: "POST"
        }), api.searchExists = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                minScore: {type: "number", name: "min_score"},
                preference: {type: "string"},
                routing: {type: "string"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search/exists",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search/exists", req: {index: {type: "list"}}}, {fmt: "/_search/exists"}],
            method: "POST"
        }), api.searchShards = ca({
            params: {
                preference: {type: "string"},
                routing: {type: "string"},
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search_shards",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search_shards", req: {index: {type: "list"}}}, {fmt: "/_search_shards"}],
            method: "POST"
        }), api.searchTemplate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch", "count", "scan"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search/template",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search/template", req: {index: {type: "list"}}}, {fmt: "/_search/template"}],
            method: "POST"
        }), api.snapshot = namespace(), api.snapshot.prototype.create = ca({
            params: {
                masterTimeout: {
                    type: "time",
                    name: "master_timeout"
                }, waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.createRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                verify: {type: "boolean"}
            },
            url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "string"}}},
            needBody: !0,
            method: "POST"
        }),api.snapshot.prototype["delete"] = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "DELETE"
        }),api.snapshot.prototype.deleteRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, method: "DELETE"
        }),api.snapshot.prototype.get = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }
        }),api.snapshot.prototype.getRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, {fmt: "/_snapshot"}]
        }),api.snapshot.prototype.restore = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_restore",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.status = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            urls: [{
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_status",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }, {
                fmt: "/_snapshot/<%=repository%>/_status",
                req: {repository: {type: "string"}}
            }, {fmt: "/_snapshot/_status"}]
        }),api.snapshot.prototype.verifyRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>/_verify", req: {repository: {type: "string"}}}, method: "POST"
        }),api.suggest = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "string"}
            },
            urls: [{fmt: "/<%=index%>/_suggest", req: {index: {type: "list"}}}, {fmt: "/_suggest"}],
            needBody: !0,
            method: "POST"
        }),api.termvectors = ca({
            params: {
                termStatistics: {
                    type: "boolean",
                    "default": !1,
                    required: !1,
                    name: "term_statistics"
                },
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                dfs: {type: "boolean", "default": !1, required: !1},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_termvectors",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_termvectors", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }),api.update = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                fields: {type: "list"},
                lang: {type: "string"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                retryOnConflict: {type: "number", name: "retry_on_conflict"},
                routing: {type: "string"},
                script: {},
                scriptId: {name: "script_id"},
                scriptedUpsert: {type: "boolean", name: "scripted_upsert"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {type: "enum", options: ["internal", "force"], name: "version_type"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_update",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }),api.create = ca.proxy(api.index, {
            transform: function (params) {
                params.op_type = "create"
            }
        })
    }, {"../client_action": 15, "../utils": 38}],
    8: [function (require, module, exports) {
        var ca = require("../client_action").makeFactoryWithModifier(function (spec) {
            return require("../utils").merge(spec, {params: {filterPath: {type: "list", name: "filter_path"}}})
        }), namespace = require("../client_action").namespaceFactory, api = module.exports = {};
        api._namespaces = ["cat", "cluster", "indices", "nodes", "snapshot"], api.bulk = ca({
            params: {
                consistency: {
                    type: "enum",
                    options: ["one", "quorum", "all"]
                },
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                type: {type: "string"},
                fields: {type: "list"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_bulk",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_bulk", req: {index: {type: "string"}}}, {fmt: "/_bulk"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.cat = namespace(), api.cat.prototype.aliases = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/aliases/<%=name%>", req: {name: {type: "list"}}}, {fmt: "/_cat/aliases"}]
        }), api.cat.prototype.allocation = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/allocation/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cat/allocation"}]
        }), api.cat.prototype.count = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/count/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/count"}]
        }), api.cat.prototype.fielddata = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1},
                fields: {type: "list"}
            }, urls: [{fmt: "/_cat/fielddata/<%=fields%>", req: {fields: {type: "list"}}}, {fmt: "/_cat/fielddata"}]
        }), api.cat.prototype.health = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                ts: {type: "boolean", "default": !0},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/health"}
        }), api.cat.prototype.help = ca({
            params: {help: {type: "boolean", "default": !1}},
            url: {fmt: "/_cat"}
        }), api.cat.prototype.indices = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                pri: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/indices/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/indices"}]
        }), api.cat.prototype.master = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/master"}
        }), api.cat.prototype.nodeattrs = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/nodeattrs"}
        }), api.cat.prototype.nodes = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/nodes"}
        }), api.cat.prototype.pendingTasks = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/pending_tasks"}
        }), api.cat.prototype.plugins = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/plugins"}
        }), api.cat.prototype.recovery = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/recovery/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/recovery"}]
        }), api.cat.prototype.repositories = ca({
            params: {
                local: {type: "boolean", "default": !1},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/repositories"}
        }), api.cat.prototype.segments = ca({
            params: {
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/segments/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/segments"}]
        }), api.cat.prototype.shards = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/shards/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/shards"}]
        }), api.cat.prototype.snapshots = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/snapshots/<%=repository%>", req: {repository: {type: "list"}}}
        }), api.cat.prototype.threadPool = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1},
                fullId: {type: "boolean", "default": !1, name: "full_id"}
            }, url: {fmt: "/_cat/thread_pool"}
        }), api.clearScroll = ca({
            urls: [{
                fmt: "/_search/scroll/<%=scrollId%>",
                req: {scrollId: {type: "list"}}
            }, {fmt: "/_search/scroll"}], method: "DELETE"
        }), api.cluster = namespace(), api.cluster.prototype.getSettings = ca({
            params: {
                flatSettings: {
                    type: "boolean",
                    name: "flat_settings"
                }, masterTimeout: {type: "time", name: "master_timeout"}, timeout: {type: "time"}
            }, url: {fmt: "/_cluster/settings"}
        }), api.cluster.prototype.health = ca({
            params: {
                level: {
                    type: "enum",
                    "default": "cluster",
                    options: ["cluster", "indices", "shards"]
                },
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                waitForActiveShards: {type: "number", name: "wait_for_active_shards"},
                waitForNodes: {type: "string", name: "wait_for_nodes"},
                waitForRelocatingShards: {type: "number", name: "wait_for_relocating_shards"},
                waitForStatus: {
                    type: "enum",
                    "default": null,
                    options: ["green", "yellow", "red"],
                    name: "wait_for_status"
                }
            }, urls: [{fmt: "/_cluster/health/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cluster/health"}]
        }), api.cluster.prototype.pendingTasks = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_cluster/pending_tasks"}
        }), api.cluster.prototype.putSettings = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/settings"}, method: "PUT"
        }), api.cluster.prototype.reroute = ca({
            params: {
                dryRun: {type: "boolean", name: "dry_run"},
                explain: {type: "boolean"},
                metric: {
                    type: "list",
                    options: ["_all", "blocks", "metadata", "nodes", "routing_table", "master_node", "version"]
                },
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/reroute"}, method: "POST"
        }), api.cluster.prototype.state = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/_cluster/state/<%=metric%>/<%=index%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }, index: {type: "list"}
                }
            }, {
                fmt: "/_cluster/state/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }
                }
            }, {fmt: "/_cluster/state"}]
        }), api.cluster.prototype.stats = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_cluster/stats/nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cluster/stats"}]
        }), api.count = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                minScore: {type: "number", name: "min_score"},
                preference: {type: "string"},
                routing: {type: "string"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_count",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_count", req: {index: {type: "list"}}}, {fmt: "/_count"}],
            method: "POST"
        }), api.countPercolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate/count",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate/count", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api["delete"] = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "DELETE"
        }), api.deleteScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            method: "DELETE"
        }), api.deleteTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, method: "DELETE"
        }), api.exists = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "HEAD"
        }), api.explain = ca({
            params: {
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                analyzer: {type: "string"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                fields: {type: "list"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                parent: {type: "string"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_explain",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }), api.fieldStats = ca({
            params: {
                fields: {type: "list"},
                level: {type: "enum", "default": "cluster", options: ["indices", "cluster"]},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{fmt: "/<%=index%>/_field_stats", req: {index: {type: "list"}}}, {fmt: "/_field_stats"}],
            method: "POST"
        }), api.get = ca({
            params: {
                fields: {type: "list"},
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}}
        }), api.getSource = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_source",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}
        }), api.index = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                opType: {type: "enum", "default": "index", options: ["index", "create"], name: "op_type"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "string"}, type: {type: "string"}}}],
            needBody: !0,
            method: "POST"
        }), api.indices = namespace(), api.indices.prototype.analyze = ca({
            params: {
                analyzer: {type: "string"},
                charFilters: {type: "list", name: "char_filters"},
                field: {type: "string"},
                filters: {type: "list"},
                index: {type: "string"},
                preferLocal: {type: "boolean", name: "prefer_local"},
                text: {type: "list"},
                tokenizer: {type: "string"},
                format: {type: "enum", "default": "detailed", options: ["detailed", "text"]}
            }, urls: [{fmt: "/<%=index%>/_analyze", req: {index: {type: "string"}}}, {fmt: "/_analyze"}], method: "POST"
        }), api.indices.prototype.clearCache = ca({
            params: {
                fieldData: {type: "boolean", name: "field_data"},
                fielddata: {type: "boolean"},
                fields: {type: "list"},
                query: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                index: {type: "list"},
                recycler: {type: "boolean"},
                request: {type: "boolean"}
            },
            urls: [{fmt: "/<%=index%>/_cache/clear", req: {index: {type: "list"}}}, {fmt: "/_cache/clear"}],
            method: "POST"
        }), api.indices.prototype.close = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_close", req: {index: {type: "list"}}}, method: "POST"
        }), api.indices.prototype.create = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                updateAllTypes: {type: "boolean", name: "update_all_types"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "string"}}}, method: "POST"
        }), api.indices.prototype["delete"] = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "DELETE"
        }), api.indices.prototype.deleteAlias = ca({
            params: {timeout: {type: "time"}, masterTimeout: {type: "time", name: "master_timeout"}},
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.deleteTemplate = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "DELETE"
        }), api.indices.prototype.deleteWarmer = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                name: {type: "list"}
            },
            url: {fmt: "/<%=index%>/_warmer/<%=name%>", req: {index: {type: "list"}, name: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.exists = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.existsAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }],
            method: "HEAD"
        }), api.indices.prototype.existsTemplate = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "HEAD"
        }), api.indices.prototype.existsType = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "list"}, type: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.flush = ca({
            params: {
                force: {type: "boolean"},
                waitIfOngoing: {type: "boolean", name: "wait_if_ongoing"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, urls: [{fmt: "/<%=index%>/_flush", req: {index: {type: "list"}}}, {fmt: "/_flush"}], method: "POST"
        }), api.indices.prototype.flushSynced = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{fmt: "/<%=index%>/_flush/synced", req: {index: {type: "list"}}}, {fmt: "/_flush/synced"}],
            method: "POST"
        }), api.indices.prototype.forcemerge = ca({
            params: {
                flush: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                maxNumSegments: {type: "number", name: "max_num_segments"},
                onlyExpungeDeletes: {type: "boolean", name: "only_expunge_deletes"},
                operationThreading: {name: "operation_threading"},
                waitForMerge: {type: "boolean", name: "wait_for_merge"}
            },
            urls: [{fmt: "/<%=index%>/_forcemerge", req: {index: {type: "list"}}}, {fmt: "/_forcemerge"}],
            method: "POST"
        }), api.indices.prototype.get = ca({
            params: {
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1}
            },
            urls: [{
                fmt: "/<%=index%>/<%=feature%>",
                req: {
                    index: {type: "list"},
                    feature: {type: "list", options: ["_settings", "_mappings", "_warmers", "_aliases"]}
                }
            }, {fmt: "/<%=index%>", req: {index: {type: "list"}}}]
        }), api.indices.prototype.getAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }, {fmt: "/_alias"}]
        }), api.indices.prototype.getAliases = ca({
            params: {timeout: {type: "time"}, local: {type: "boolean"}},
            urls: [{
                fmt: "/<%=index%>/_aliases/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_aliases", req: {index: {type: "list"}}}, {
                fmt: "/_aliases/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_aliases"}]
        }), api.indices.prototype.getFieldMapping = ca({
            params: {
                includeDefaults: {
                    type: "boolean",
                    name: "include_defaults"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>/field/<%=fields%>",
                req: {index: {type: "list"}, type: {type: "list"}, fields: {type: "list"}}
            }, {
                fmt: "/<%=index%>/_mapping/field/<%=fields%>",
                req: {index: {type: "list"}, fields: {type: "list"}}
            }, {
                fmt: "/_mapping/<%=type%>/field/<%=fields%>",
                req: {type: {type: "list"}, fields: {type: "list"}}
            }, {fmt: "/_mapping/field/<%=fields%>", req: {fields: {type: "list"}}}]
        }), api.indices.prototype.getMapping = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_mapping", req: {index: {type: "list"}}}, {
                fmt: "/_mapping/<%=type%>",
                req: {type: {type: "list"}}
            }, {fmt: "/_mapping"}]
        }), api.indices.prototype.getSettings = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"},
                local: {type: "boolean"},
                human: {type: "boolean", "default": !1}
            },
            urls: [{
                fmt: "/<%=index%>/_settings/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {
                fmt: "/_settings/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_settings"}]
        }), api.indices.prototype.getTemplate = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_template/<%=name%>", req: {name: {type: "list"}}}, {fmt: "/_template"}]
        }), api.indices.prototype.getUpgrade = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}]
        }), api.indices.prototype.getWarmer = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, type: {type: "list"}, name: {type: "list"}}
            }, {
                fmt: "/<%=index%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_warmer", req: {index: {type: "list"}}}, {
                fmt: "/_warmer/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_warmer"}]
        }), api.indices.prototype.open = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "closed",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_open", req: {index: {type: "list"}}}, method: "POST"
        }), api.indices.prototype.optimize = ca({
            params: {
                flush: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                maxNumSegments: {type: "number", name: "max_num_segments"},
                onlyExpungeDeletes: {type: "boolean", name: "only_expunge_deletes"},
                operationThreading: {name: "operation_threading"},
                waitForMerge: {type: "boolean", name: "wait_for_merge"}
            }, urls: [{fmt: "/<%=index%>/_optimize", req: {index: {type: "list"}}}, {fmt: "/_optimize"}], method: "POST"
        }), api.indices.prototype.putAlias = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            },
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "string"}}},
            method: "PUT"
        }), api.indices.prototype.putMapping = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                updateAllTypes: {type: "boolean", name: "update_all_types"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "string"}}
            }, {fmt: "/_mapping/<%=type%>", req: {type: {type: "string"}}}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putSettings = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"}
            },
            urls: [{fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {fmt: "/_settings"}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putTemplate = ca({
            params: {
                order: {type: "number"},
                create: {type: "boolean", "default": !1},
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.indices.prototype.putWarmer = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                requestCache: {type: "boolean", name: "request_cache"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, type: {type: "list"}, name: {type: "string"}}
            }, {
                fmt: "/<%=index%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, name: {type: "string"}}
            }, {fmt: "/_warmer/<%=name%>", req: {name: {type: "string"}}}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.recovery = ca({
            params: {
                detailed: {type: "boolean", "default": !1},
                activeOnly: {type: "boolean", "default": !1, name: "active_only"},
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_recovery", req: {index: {type: "list"}}}, {fmt: "/_recovery"}]
        }), api.indices.prototype.refresh = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                force: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_refresh", req: {index: {type: "list"}}}, {fmt: "/_refresh"}], method: "POST"
        }), api.indices.prototype.segments = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"},
                verbose: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_segments", req: {index: {type: "list"}}}, {fmt: "/_segments"}]
        }), api.indices.prototype.shardStores = ca({
            params: {
                status: {
                    type: "list",
                    options: ["green", "yellow", "red", "all"]
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_shard_stores", req: {index: {type: "list"}}}, {fmt: "/_shard_stores"}]
        }), api.indices.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "list"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "indices", options: ["cluster", "indices", "shards"]},
                types: {type: "list"}
            },
            urls: [{
                fmt: "/<%=index%>/_stats/<%=metric%>",
                req: {
                    index: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/<%=index%>/_stats", req: {index: {type: "list"}}}, {fmt: "/_stats"}]
        }), api.indices.prototype.updateAliases = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_aliases"}, needBody: !0, method: "POST"
        }), api.indices.prototype.upgrade = ca({
            params: {
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                waitForCompletion: {type: "boolean", name: "wait_for_completion"},
                onlyAncientSegments: {type: "boolean", name: "only_ancient_segments"}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}], method: "POST"
        }), api.indices.prototype.validateQuery = ca({
            params: {
                explain: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                operationThreading: {name: "operation_threading"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                rewrite: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_validate/query",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_validate/query", req: {index: {type: "list"}}}, {fmt: "/_validate/query"}],
            method: "POST"
        }), api.info = ca({url: {fmt: "/"}}), api.mget = ca({
            params: {
                fields: {type: "list"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mget",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mget", req: {index: {type: "string"}}}, {fmt: "/_mget"}],
            needBody: !0,
            method: "POST"
        }), api.mpercolate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mpercolate",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mpercolate", req: {index: {type: "string"}}}, {fmt: "/_mpercolate"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.msearch = ca({
            params: {
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch", "count", "scan"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_msearch",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_msearch", req: {index: {type: "list"}}}, {fmt: "/_msearch"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.mtermvectors = ca({
            params: {
                ids: {type: "list", required: !1},
                termStatistics: {type: "boolean", "default": !1, required: !1, name: "term_statistics"},
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mtermvectors",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mtermvectors", req: {index: {type: "string"}}}, {fmt: "/_mtermvectors"}],
            method: "POST"
        }), api.nodes = namespace(), api.nodes.prototype.hotThreads = ca({
            params: {
                interval: {type: "time"},
                snapshots: {type: "number"},
                threads: {type: "number"},
                ignoreIdleThreads: {type: "boolean", name: "ignore_idle_threads"},
                type: {type: "enum", options: ["cpu", "wait", "block"]},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_nodes/<%=nodeId%>/hotthreads", req: {nodeId: {type: "list"}}}, {fmt: "/_nodes/hotthreads"}]
        }), api.nodes.prototype.info = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "transport", "http", "plugins"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "transport", "http", "plugins"]
                    }
                }
            }, {fmt: "/_nodes"}]
        }), api.nodes.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "boolean"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "node", options: ["node", "indices", "shards"]},
                types: {type: "list"},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    }
                }
            }, {
                fmt: "/_nodes/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>/stats", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    }
                }
            }, {fmt: "/_nodes/stats"}]
        }), api.percolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                percolateRouting: {type: "string", name: "percolate_routing"},
                percolatePreference: {type: "string", name: "percolate_preference"},
                percolateFormat: {type: "enum", options: ["ids"], name: "percolate_format"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api.ping = ca({
            url: {fmt: "/"},
            requestTimeout: 3e3,
            method: "HEAD"
        }), api.putScript = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            needBody: !0,
            method: "PUT"
        }), api.putTemplate = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.renderSearchTemplate = ca({
            urls: [{
                fmt: "/_render/template/<%=id%>",
                req: {id: {type: "string"}}
            }, {fmt: "/_render/template"}], method: "POST"
        }), api.scroll = ca({
            params: {scroll: {type: "duration"}, scrollId: {type: "string", name: "scroll_id"}},
            urls: [{fmt: "/_search/scroll/<%=scrollId%>", req: {scrollId: {type: "string"}}}, {fmt: "/_search/scroll"}],
            paramAsBody: "scrollId",
            method: "POST"
        }), api.search = ca({
            params: {
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                explain: {type: "boolean"},
                fields: {type: "list"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                from: {type: "number"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "dfs_query_then_fetch", "count", "scan"],
                    name: "search_type"
                },
                size: {type: "number"},
                sort: {type: "list"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                terminateAfter: {type: "number", name: "terminate_after"},
                stats: {type: "list"},
                suggestField: {type: "string", name: "suggest_field"},
                suggestMode: {
                    type: "enum",
                    "default": "missing",
                    options: ["missing", "popular", "always"],
                    name: "suggest_mode"
                },
                suggestSize: {type: "number", name: "suggest_size"},
                suggestText: {type: "text", name: "suggest_text"},
                timeout: {type: "time"},
                trackScores: {type: "boolean", name: "track_scores"},
                version: {type: "boolean"},
                requestCache: {type: "boolean", name: "request_cache"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search", req: {index: {type: "list"}}}, {fmt: "/_search"}],
            method: "POST"
        }), api.searchExists = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                minScore: {type: "number", name: "min_score"},
                preference: {type: "string"},
                routing: {type: "string"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search/exists",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search/exists", req: {index: {type: "list"}}}, {fmt: "/_search/exists"}],
            method: "POST"
        }), api.searchShards = ca({
            params: {
                preference: {type: "string"},
                routing: {type: "string"},
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search_shards",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search_shards", req: {index: {type: "list"}}}, {fmt: "/_search_shards"}],
            method: "POST"
        }),api.searchTemplate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch", "count", "scan"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search/template",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search/template", req: {index: {type: "list"}}}, {fmt: "/_search/template"}],
            method: "POST"
        }),api.snapshot = namespace(),api.snapshot.prototype.create = ca({
            params: {
                masterTimeout: {
                    type: "time",
                    name: "master_timeout"
                }, waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.createRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                verify: {type: "boolean"}
            },
            url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "string"}}},
            needBody: !0,
            method: "POST"
        }),api.snapshot.prototype["delete"] = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "DELETE"
        }),api.snapshot.prototype.deleteRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, method: "DELETE"
        }),api.snapshot.prototype.get = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }
        }),api.snapshot.prototype.getRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, {fmt: "/_snapshot"}]
        }),api.snapshot.prototype.restore = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_restore",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.status = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            urls: [{
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_status",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }, {
                fmt: "/_snapshot/<%=repository%>/_status",
                req: {repository: {type: "string"}}
            }, {fmt: "/_snapshot/_status"}]
        }),api.snapshot.prototype.verifyRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>/_verify", req: {repository: {type: "string"}}}, method: "POST"
        }),api.suggest = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "string"}
            },
            urls: [{fmt: "/<%=index%>/_suggest", req: {index: {type: "list"}}}, {fmt: "/_suggest"}],
            needBody: !0,
            method: "POST"
        }),api.termvectors = ca({
            params: {
                termStatistics: {
                    type: "boolean",
                    "default": !1,
                    required: !1,
                    name: "term_statistics"
                },
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                dfs: {type: "boolean", "default": !1, required: !1},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_termvectors",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_termvectors", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }),api.update = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                fields: {type: "list"},
                lang: {type: "string"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                retryOnConflict: {type: "number", name: "retry_on_conflict"},
                routing: {type: "string"},
                script: {},
                scriptId: {name: "script_id"},
                scriptedUpsert: {type: "boolean", name: "scripted_upsert"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {type: "enum", options: ["internal", "force"], name: "version_type"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_update",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }),api.create = ca.proxy(api.index, {
            transform: function (params) {
                params.op_type = "create"
            }
        })
    }, {"../client_action": 15, "../utils": 38}],
    9: [function (require, module, exports) {
        var ca = require("../client_action").makeFactoryWithModifier(function (spec) {
            return require("../utils").merge(spec, {params: {filterPath: {type: "list", name: "filter_path"}}})
        }), namespace = require("../client_action").namespaceFactory, api = module.exports = {};
        api._namespaces = ["cat", "cluster", "indices", "nodes", "snapshot"], api.bulk = ca({
            params: {
                consistency: {
                    type: "enum",
                    options: ["one", "quorum", "all"]
                },
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                type: {type: "string"},
                fields: {type: "list"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_bulk",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_bulk", req: {index: {type: "string"}}}, {fmt: "/_bulk"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.cat = namespace(), api.cat.prototype.aliases = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/aliases/<%=name%>", req: {name: {type: "list"}}}, {fmt: "/_cat/aliases"}]
        }), api.cat.prototype.allocation = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/allocation/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cat/allocation"}]
        }), api.cat.prototype.count = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/count/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/count"}]
        }), api.cat.prototype.fielddata = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {
                    type: "boolean",
                    "default": !1
                },
                fields: {type: "list"}
            }, urls: [{fmt: "/_cat/fielddata/<%=fields%>", req: {fields: {type: "list"}}}, {fmt: "/_cat/fielddata"}]
        }), api.cat.prototype.health = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                ts: {type: "boolean", "default": !0},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/health"}
        }), api.cat.prototype.help = ca({
            params: {help: {type: "boolean", "default": !1}},
            url: {fmt: "/_cat"}
        }), api.cat.prototype.indices = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                pri: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/indices/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/indices"}]
        }), api.cat.prototype.master = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/master"}
        }), api.cat.prototype.nodeattrs = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/nodeattrs"}
        }), api.cat.prototype.nodes = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/nodes"}
        }), api.cat.prototype.pendingTasks = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/pending_tasks"}
        }), api.cat.prototype.plugins = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/plugins"}
        }), api.cat.prototype.recovery = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/recovery/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/recovery"}]
        }), api.cat.prototype.repositories = ca({
            params: {
                local: {type: "boolean", "default": !1},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/repositories"}
        }), api.cat.prototype.segments = ca({
            params: {
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/segments/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/segments"}]
        }), api.cat.prototype.shards = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/shards/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/shards"}]
        }), api.cat.prototype.snapshots = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    "default": !1,
                    name: "ignore_unavailable"
                },
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/snapshots/<%=repository%>", req: {repository: {type: "list"}}}
        }), api.cat.prototype.threadPool = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1},
                fullId: {type: "boolean", "default": !1, name: "full_id"}
            }, url: {fmt: "/_cat/thread_pool"}
        }), api.clearScroll = ca({
            urls: [{
                fmt: "/_search/scroll/<%=scrollId%>",
                req: {scrollId: {type: "list"}}
            }, {fmt: "/_search/scroll"}], method: "DELETE"
        }), api.cluster = namespace(), api.cluster.prototype.getSettings = ca({
            params: {
                flatSettings: {
                    type: "boolean",
                    name: "flat_settings"
                }, masterTimeout: {type: "time", name: "master_timeout"}, timeout: {type: "time"}
            }, url: {fmt: "/_cluster/settings"}
        }), api.cluster.prototype.health = ca({
            params: {
                level: {
                    type: "enum",
                    "default": "cluster",
                    options: ["cluster", "indices", "shards"]
                },
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                waitForActiveShards: {type: "number", name: "wait_for_active_shards"},
                waitForNodes: {type: "string", name: "wait_for_nodes"},
                waitForRelocatingShards: {type: "number", name: "wait_for_relocating_shards"},
                waitForStatus: {
                    type: "enum",
                    "default": null,
                    options: ["green", "yellow", "red"],
                    name: "wait_for_status"
                }
            }, urls: [{fmt: "/_cluster/health/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cluster/health"}]
        }), api.cluster.prototype.pendingTasks = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_cluster/pending_tasks"}
        }), api.cluster.prototype.putSettings = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/settings"}, method: "PUT"
        }), api.cluster.prototype.reroute = ca({
            params: {
                dryRun: {type: "boolean", name: "dry_run"},
                explain: {type: "boolean"},
                metric: {
                    type: "list",
                    options: ["_all", "blocks", "metadata", "nodes", "routing_table", "master_node", "version"]
                },
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/reroute"}, method: "POST"
        }), api.cluster.prototype.state = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/_cluster/state/<%=metric%>/<%=index%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }, index: {type: "list"}
                }
            }, {
                fmt: "/_cluster/state/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }
                }
            }, {fmt: "/_cluster/state"}]
        }), api.cluster.prototype.stats = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_cluster/stats/nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cluster/stats"}]
        }), api.count = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                minScore: {type: "number", name: "min_score"},
                preference: {type: "string"},
                routing: {type: "string"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_count",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_count", req: {index: {type: "list"}}}, {fmt: "/_count"}],
            method: "POST"
        }), api.countPercolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate/count",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate/count", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api["delete"] = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "DELETE"
        }), api.deleteScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            method: "DELETE"
        }), api.deleteTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, method: "DELETE"
        }), api.exists = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "HEAD"
        }), api.explain = ca({
            params: {
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                analyzer: {type: "string"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                fields: {type: "list"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                parent: {type: "string"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_explain",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }), api.fieldStats = ca({
            params: {
                fields: {type: "list"},
                level: {type: "enum", "default": "cluster", options: ["indices", "cluster"]},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{fmt: "/<%=index%>/_field_stats", req: {index: {type: "list"}}}, {fmt: "/_field_stats"}],
            method: "POST"
        }), api.get = ca({
            params: {
                fields: {type: "list"},
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}}
        }), api.getSource = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_source",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}
        }), api.index = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                opType: {type: "enum", "default": "index", options: ["index", "create"], name: "op_type"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "string"}, type: {type: "string"}}}],
            needBody: !0,
            method: "POST"
        }), api.indices = namespace(), api.indices.prototype.analyze = ca({
            params: {
                analyzer: {type: "string"},
                charFilters: {type: "list", name: "char_filters"},
                field: {type: "string"},
                filters: {type: "list"},
                index: {type: "string"},
                preferLocal: {type: "boolean", name: "prefer_local"},
                text: {type: "list"},
                tokenizer: {type: "string"},
                detail: {type: "boolean"},
                attributes: {type: "list"},
                format: {type: "enum", "default": "detailed", options: ["detailed", "text"]}
            }, urls: [{fmt: "/<%=index%>/_analyze", req: {index: {type: "string"}}}, {fmt: "/_analyze"}], method: "POST"
        }), api.indices.prototype.clearCache = ca({
            params: {
                fieldData: {type: "boolean", name: "field_data"},
                fielddata: {type: "boolean"},
                fields: {type: "list"},
                query: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                index: {type: "list"},
                recycler: {type: "boolean"},
                request: {type: "boolean"}
            },
            urls: [{fmt: "/<%=index%>/_cache/clear", req: {index: {type: "list"}}}, {fmt: "/_cache/clear"}],
            method: "POST"
        }), api.indices.prototype.close = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_close", req: {index: {type: "list"}}}, method: "POST"
        }), api.indices.prototype.create = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                updateAllTypes: {type: "boolean", name: "update_all_types"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "string"}}}, method: "POST"
        }), api.indices.prototype["delete"] = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "DELETE"
        }), api.indices.prototype.deleteAlias = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            },
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.deleteTemplate = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "DELETE"
        }), api.indices.prototype.deleteWarmer = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                name: {type: "list"}
            },
            url: {fmt: "/<%=index%>/_warmer/<%=name%>", req: {index: {type: "list"}, name: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.exists = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.existsAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }],
            method: "HEAD"
        }), api.indices.prototype.existsTemplate = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "HEAD"
        }), api.indices.prototype.existsType = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "list"}, type: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.flush = ca({
            params: {
                force: {type: "boolean"},
                waitIfOngoing: {type: "boolean", name: "wait_if_ongoing"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, urls: [{fmt: "/<%=index%>/_flush", req: {index: {type: "list"}}}, {fmt: "/_flush"}], method: "POST"
        }), api.indices.prototype.flushSynced = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{fmt: "/<%=index%>/_flush/synced", req: {index: {type: "list"}}}, {fmt: "/_flush/synced"}],
            method: "POST"
        }), api.indices.prototype.forcemerge = ca({
            params: {
                flush: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                maxNumSegments: {type: "number", name: "max_num_segments"},
                onlyExpungeDeletes: {type: "boolean", name: "only_expunge_deletes"},
                operationThreading: {name: "operation_threading"},
                waitForMerge: {type: "boolean", name: "wait_for_merge"}
            },
            urls: [{fmt: "/<%=index%>/_forcemerge", req: {index: {type: "list"}}}, {fmt: "/_forcemerge"}],
            method: "POST"
        }), api.indices.prototype.get = ca({
            params: {
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1}
            },
            urls: [{
                fmt: "/<%=index%>/<%=feature%>",
                req: {
                    index: {type: "list"},
                    feature: {type: "list", options: ["_settings", "_mappings", "_warmers", "_aliases"]}
                }
            }, {fmt: "/<%=index%>", req: {index: {type: "list"}}}]
        }), api.indices.prototype.getAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }, {fmt: "/_alias"}]
        }), api.indices.prototype.getAliases = ca({
            params: {timeout: {type: "time"}, local: {type: "boolean"}},
            urls: [{
                fmt: "/<%=index%>/_aliases/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_aliases", req: {index: {type: "list"}}}, {
                fmt: "/_aliases/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_aliases"}]
        }), api.indices.prototype.getFieldMapping = ca({
            params: {
                includeDefaults: {
                    type: "boolean",
                    name: "include_defaults"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>/field/<%=fields%>",
                req: {index: {type: "list"}, type: {type: "list"}, fields: {type: "list"}}
            }, {
                fmt: "/<%=index%>/_mapping/field/<%=fields%>",
                req: {index: {type: "list"}, fields: {type: "list"}}
            }, {
                fmt: "/_mapping/<%=type%>/field/<%=fields%>",
                req: {type: {type: "list"}, fields: {type: "list"}}
            }, {fmt: "/_mapping/field/<%=fields%>", req: {fields: {type: "list"}}}]
        }), api.indices.prototype.getMapping = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_mapping", req: {index: {type: "list"}}}, {
                fmt: "/_mapping/<%=type%>",
                req: {type: {type: "list"}}
            }, {fmt: "/_mapping"}]
        }), api.indices.prototype.getSettings = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"},
                local: {type: "boolean"},
                human: {type: "boolean", "default": !1}
            },
            urls: [{
                fmt: "/<%=index%>/_settings/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {
                fmt: "/_settings/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_settings"}]
        }), api.indices.prototype.getTemplate = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_template/<%=name%>", req: {name: {type: "list"}}}, {fmt: "/_template"}]
        }), api.indices.prototype.getUpgrade = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}]
        }), api.indices.prototype.getWarmer = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, type: {type: "list"}, name: {type: "list"}}
            }, {
                fmt: "/<%=index%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_warmer", req: {index: {type: "list"}}}, {
                fmt: "/_warmer/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_warmer"}]
        }), api.indices.prototype.open = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "closed",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_open", req: {index: {type: "list"}}}, method: "POST"
        }), api.indices.prototype.optimize = ca({
            params: {
                flush: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                maxNumSegments: {type: "number", name: "max_num_segments"},
                onlyExpungeDeletes: {type: "boolean", name: "only_expunge_deletes"},
                operationThreading: {name: "operation_threading"},
                waitForMerge: {type: "boolean", name: "wait_for_merge"}
            }, urls: [{fmt: "/<%=index%>/_optimize", req: {index: {type: "list"}}}, {fmt: "/_optimize"}], method: "POST"
        }), api.indices.prototype.putAlias = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            },
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "string"}}},
            method: "PUT"
        }), api.indices.prototype.putMapping = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                updateAllTypes: {type: "boolean", name: "update_all_types"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "string"}}
            }, {fmt: "/_mapping/<%=type%>", req: {type: {type: "string"}}}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putSettings = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"}
            },
            urls: [{fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {fmt: "/_settings"}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putTemplate = ca({
            params: {
                order: {type: "number"},
                create: {type: "boolean", "default": !1},
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.indices.prototype.putWarmer = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                requestCache: {type: "boolean", name: "request_cache"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, type: {type: "list"}, name: {type: "string"}}
            }, {
                fmt: "/<%=index%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, name: {type: "string"}}
            }, {fmt: "/_warmer/<%=name%>", req: {name: {type: "string"}}}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.recovery = ca({
            params: {
                detailed: {type: "boolean", "default": !1},
                activeOnly: {type: "boolean", "default": !1, name: "active_only"},
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_recovery", req: {index: {type: "list"}}}, {fmt: "/_recovery"}]
        }), api.indices.prototype.refresh = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                force: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_refresh", req: {index: {type: "list"}}}, {fmt: "/_refresh"}], method: "POST"
        }), api.indices.prototype.segments = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"},
                verbose: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_segments", req: {index: {type: "list"}}}, {fmt: "/_segments"}]
        }), api.indices.prototype.shardStores = ca({
            params: {
                status: {
                    type: "list",
                    options: ["green", "yellow", "red", "all"]
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_shard_stores", req: {index: {type: "list"}}}, {fmt: "/_shard_stores"}]
        }), api.indices.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "list"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "indices", options: ["cluster", "indices", "shards"]},
                types: {type: "list"}
            },
            urls: [{
                fmt: "/<%=index%>/_stats/<%=metric%>",
                req: {
                    index: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/<%=index%>/_stats", req: {index: {type: "list"}}}, {fmt: "/_stats"}]
        }), api.indices.prototype.updateAliases = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_aliases"}, needBody: !0, method: "POST"
        }), api.indices.prototype.upgrade = ca({
            params: {
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                waitForCompletion: {type: "boolean", name: "wait_for_completion"},
                onlyAncientSegments: {type: "boolean", name: "only_ancient_segments"}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}], method: "POST"
        }), api.indices.prototype.validateQuery = ca({
            params: {
                explain: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                operationThreading: {name: "operation_threading"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                rewrite: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_validate/query",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_validate/query", req: {index: {type: "list"}}}, {fmt: "/_validate/query"}],
            method: "POST"
        }), api.info = ca({url: {fmt: "/"}}), api.mget = ca({
            params: {
                fields: {type: "list"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mget",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mget", req: {index: {type: "string"}}}, {fmt: "/_mget"}],
            needBody: !0,
            method: "POST"
        }), api.mpercolate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mpercolate",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mpercolate", req: {index: {type: "string"}}}, {fmt: "/_mpercolate"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.msearch = ca({
            params: {
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch", "count", "scan"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_msearch",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_msearch", req: {index: {type: "list"}}}, {fmt: "/_msearch"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.mtermvectors = ca({
            params: {
                ids: {type: "list", required: !1},
                termStatistics: {type: "boolean", "default": !1, required: !1, name: "term_statistics"},
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mtermvectors",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mtermvectors", req: {index: {type: "string"}}}, {fmt: "/_mtermvectors"}],
            method: "POST"
        }), api.nodes = namespace(), api.nodes.prototype.hotThreads = ca({
            params: {
                interval: {type: "time"},
                snapshots: {type: "number"},
                threads: {type: "number"},
                ignoreIdleThreads: {type: "boolean", name: "ignore_idle_threads"},
                type: {type: "enum", options: ["cpu", "wait", "block"]},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_nodes/<%=nodeId%>/hotthreads", req: {nodeId: {type: "list"}}}, {fmt: "/_nodes/hotthreads"}]
        }), api.nodes.prototype.info = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "transport", "http", "plugins"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "transport", "http", "plugins"]
                    }
                }
            }, {fmt: "/_nodes"}]
        }), api.nodes.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "boolean"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "node", options: ["node", "indices", "shards"]},
                types: {type: "list"},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    }
                }
            }, {
                fmt: "/_nodes/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>/stats", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    }
                }
            }, {fmt: "/_nodes/stats"}]
        }), api.percolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                percolateRouting: {type: "string", name: "percolate_routing"},
                percolatePreference: {type: "string", name: "percolate_preference"},
                percolateFormat: {type: "enum", options: ["ids"], name: "percolate_format"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api.ping = ca({
            url: {fmt: "/"},
            requestTimeout: 3e3,
            method: "HEAD"
        }), api.putScript = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            needBody: !0,
            method: "PUT"
        }), api.putTemplate = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.renderSearchTemplate = ca({
            urls: [{
                fmt: "/_render/template/<%=id%>",
                req: {id: {type: "string"}}
            }, {fmt: "/_render/template"}], method: "POST"
        }), api.scroll = ca({
            params: {scroll: {type: "duration"}, scrollId: {type: "string", name: "scroll_id"}},
            urls: [{fmt: "/_search/scroll/<%=scrollId%>", req: {scrollId: {type: "string"}}}, {fmt: "/_search/scroll"}],
            paramAsBody: "scrollId",
            method: "POST"
        }), api.search = ca({
            params: {
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                explain: {type: "boolean"},
                fields: {type: "list"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                from: {type: "number"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "dfs_query_then_fetch", "count", "scan"],
                    name: "search_type"
                },
                size: {type: "number"},
                sort: {type: "list"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                terminateAfter: {type: "number", name: "terminate_after"},
                stats: {type: "list"},
                suggestField: {type: "string", name: "suggest_field"},
                suggestMode: {
                    type: "enum",
                    "default": "missing",
                    options: ["missing", "popular", "always"],
                    name: "suggest_mode"
                },
                suggestSize: {type: "number", name: "suggest_size"},
                suggestText: {type: "text", name: "suggest_text"},
                timeout: {type: "time"},
                trackScores: {type: "boolean", name: "track_scores"},
                version: {type: "boolean"},
                requestCache: {type: "boolean", name: "request_cache"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search", req: {index: {type: "list"}}}, {fmt: "/_search"}],
            method: "POST"
        }), api.searchExists = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                minScore: {type: "number", name: "min_score"},
                preference: {type: "string"},
                routing: {type: "string"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search/exists",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search/exists", req: {index: {type: "list"}}}, {fmt: "/_search/exists"}],
            method: "POST"
        }), api.searchShards = ca({
            params: {
                preference: {type: "string"},
                routing: {type: "string"},
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search_shards",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search_shards", req: {index: {type: "list"}}}, {fmt: "/_search_shards"}],
            method: "POST"
        }),api.searchTemplate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch", "count", "scan"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search/template",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search/template", req: {index: {type: "list"}}}, {fmt: "/_search/template"}],
            method: "POST"
        }),api.snapshot = namespace(),api.snapshot.prototype.create = ca({
            params: {
                masterTimeout: {
                    type: "time",
                    name: "master_timeout"
                }, waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.createRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                verify: {type: "boolean"}
            },
            url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "string"}}},
            needBody: !0,
            method: "POST"
        }),api.snapshot.prototype["delete"] = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "DELETE"
        }),api.snapshot.prototype.deleteRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, method: "DELETE"
        }),api.snapshot.prototype.get = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }
        }),api.snapshot.prototype.getRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, {fmt: "/_snapshot"}]
        }),api.snapshot.prototype.restore = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_restore",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.status = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            urls: [{
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_status",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }, {
                fmt: "/_snapshot/<%=repository%>/_status",
                req: {repository: {type: "string"}}
            }, {fmt: "/_snapshot/_status"}]
        }),api.snapshot.prototype.verifyRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>/_verify", req: {repository: {type: "string"}}}, method: "POST"
        }),api.suggest = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "string"}
            },
            urls: [{fmt: "/<%=index%>/_suggest", req: {index: {type: "list"}}}, {fmt: "/_suggest"}],
            needBody: !0,
            method: "POST"
        }),api.termvectors = ca({
            params: {
                termStatistics: {
                    type: "boolean",
                    "default": !1,
                    required: !1,
                    name: "term_statistics"
                },
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                dfs: {type: "boolean", "default": !1, required: !1},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_termvectors",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_termvectors", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }),api.update = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                fields: {type: "list"},
                lang: {type: "string"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                retryOnConflict: {type: "number", name: "retry_on_conflict"},
                routing: {type: "string"},
                script: {},
                scriptId: {name: "script_id"},
                scriptedUpsert: {type: "boolean", name: "scripted_upsert"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {type: "enum", options: ["internal", "force"], name: "version_type"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_update",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }),api.create = ca.proxy(api.index, {
            transform: function (params) {
                params.op_type = "create"
            }
        })
    }, {"../client_action": 15, "../utils": 38}],
    10: [function (require, module, exports) {
        var ca = require("../client_action").makeFactoryWithModifier(function (spec) {
            return require("../utils").merge(spec, {params: {filterPath: {type: "list", name: "filter_path"}}})
        }), namespace = require("../client_action").namespaceFactory, api = module.exports = {};
        api._namespaces = ["cat", "cluster", "indices", "nodes", "snapshot", "tasks"], api.bulk = ca({
            params: {
                consistency: {
                    type: "enum",
                    options: ["one", "quorum", "all"]
                },
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                type: {type: "string"},
                fields: {type: "list"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_bulk",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_bulk", req: {index: {type: "string"}}}, {fmt: "/_bulk"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.cat = namespace(), api.cat.prototype.aliases = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/aliases/<%=name%>", req: {name: {type: "list"}}}, {fmt: "/_cat/aliases"}]
        }), api.cat.prototype.allocation = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/allocation/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cat/allocation"}]
        }), api.cat.prototype.count = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/count/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/count"}]
        }), api.cat.prototype.fielddata = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1},
                fields: {type: "list"}
            }, urls: [{fmt: "/_cat/fielddata/<%=fields%>", req: {fields: {type: "list"}}}, {fmt: "/_cat/fielddata"}]
        }), api.cat.prototype.health = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                ts: {type: "boolean", "default": !0},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/health"}
        }), api.cat.prototype.help = ca({
            params: {help: {type: "boolean", "default": !1}},
            url: {fmt: "/_cat"}
        }), api.cat.prototype.indices = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                pri: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/indices/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/indices"}]
        }), api.cat.prototype.master = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/master"}
        }), api.cat.prototype.nodeattrs = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/nodeattrs"}
        }), api.cat.prototype.nodes = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/nodes"}
        }), api.cat.prototype.pendingTasks = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/pending_tasks"}
        }), api.cat.prototype.plugins = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/plugins"}
        }), api.cat.prototype.recovery = ca({
            params: {
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/recovery/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/recovery"}]
        }), api.cat.prototype.repositories = ca({
            params: {
                local: {type: "boolean", "default": !1},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/repositories"}
        }), api.cat.prototype.segments = ca({
            params: {
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/segments/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/segments"}]
        }), api.cat.prototype.shards = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/shards/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/shards"}]
        }), api.cat.prototype.snapshots = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    "default": !1,
                    name: "ignore_unavailable"
                },
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/snapshots/<%=repository%>", req: {repository: {type: "list"}}}
        }), api.cat.prototype.threadPool = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1},
                fullId: {type: "boolean", "default": !1, name: "full_id"}
            }, url: {fmt: "/_cat/thread_pool"}
        }), api.clearScroll = ca({
            urls: [{
                fmt: "/_search/scroll/<%=scrollId%>",
                req: {scrollId: {type: "list"}}
            }, {fmt: "/_search/scroll"}], method: "DELETE"
        }), api.cluster = namespace(), api.cluster.prototype.getSettings = ca({
            params: {
                flatSettings: {
                    type: "boolean",
                    name: "flat_settings"
                }, masterTimeout: {type: "time", name: "master_timeout"}, timeout: {type: "time"}
            }, url: {fmt: "/_cluster/settings"}
        }), api.cluster.prototype.health = ca({
            params: {
                level: {
                    type: "enum",
                    "default": "cluster",
                    options: ["cluster", "indices", "shards"]
                },
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                waitForActiveShards: {type: "number", name: "wait_for_active_shards"},
                waitForNodes: {type: "string", name: "wait_for_nodes"},
                waitForRelocatingShards: {type: "number", name: "wait_for_relocating_shards"},
                waitForStatus: {
                    type: "enum",
                    "default": null,
                    options: ["green", "yellow", "red"],
                    name: "wait_for_status"
                }
            }, urls: [{fmt: "/_cluster/health/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cluster/health"}]
        }), api.cluster.prototype.pendingTasks = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_cluster/pending_tasks"}
        }), api.cluster.prototype.putSettings = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/settings"}, method: "PUT"
        }), api.cluster.prototype.reroute = ca({
            params: {
                dryRun: {type: "boolean", name: "dry_run"},
                explain: {type: "boolean"},
                metric: {
                    type: "list",
                    options: ["_all", "blocks", "metadata", "nodes", "routing_table", "master_node", "version"]
                },
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/reroute"}, method: "POST"
        }), api.cluster.prototype.state = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/_cluster/state/<%=metric%>/<%=index%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }, index: {type: "list"}
                }
            }, {
                fmt: "/_cluster/state/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }
                }
            }, {fmt: "/_cluster/state"}]
        }), api.cluster.prototype.stats = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_cluster/stats/nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cluster/stats"}]
        }), api.count = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                minScore: {type: "number", name: "min_score"},
                preference: {type: "string"},
                routing: {type: "string"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_count",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_count", req: {index: {type: "list"}}}, {fmt: "/_count"}],
            method: "POST"
        }), api.countPercolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate/count",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate/count", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api["delete"] = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "DELETE"
        }), api.deleteScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            method: "DELETE"
        }), api.deleteTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, method: "DELETE"
        }), api.exists = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "HEAD"
        }), api.explain = ca({
            params: {
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                analyzer: {type: "string"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                fields: {type: "list"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                parent: {type: "string"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_explain",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }), api.fieldStats = ca({
            params: {
                fields: {type: "list"},
                level: {type: "enum", "default": "cluster", options: ["indices", "cluster"]},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{fmt: "/<%=index%>/_field_stats", req: {index: {type: "list"}}}, {fmt: "/_field_stats"}],
            method: "POST"
        }), api.get = ca({
            params: {
                fields: {type: "list"},
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}}
        }), api.getSource = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_source",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}
        }), api.index = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                opType: {type: "enum", "default": "index", options: ["index", "create"], name: "op_type"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "string"}, type: {type: "string"}}}],
            needBody: !0,
            method: "POST"
        }), api.indices = namespace(), api.indices.prototype.analyze = ca({
            params: {
                analyzer: {type: "string"},
                charFilters: {type: "list", name: "char_filters"},
                field: {type: "string"},
                filters: {type: "list"},
                index: {type: "string"},
                preferLocal: {type: "boolean", name: "prefer_local"},
                text: {type: "list"},
                tokenizer: {type: "string"},
                explain: {type: "boolean"},
                attributes: {type: "list"},
                format: {type: "enum", "default": "detailed", options: ["detailed", "text"]}
            }, urls: [{fmt: "/<%=index%>/_analyze", req: {index: {type: "string"}}}, {fmt: "/_analyze"}], method: "POST"
        }), api.indices.prototype.clearCache = ca({
            params: {
                fieldData: {type: "boolean", name: "field_data"},
                fielddata: {type: "boolean"},
                fields: {type: "list"},
                query: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                index: {type: "list"},
                recycler: {type: "boolean"},
                request: {type: "boolean"}
            },
            urls: [{fmt: "/<%=index%>/_cache/clear", req: {index: {type: "list"}}}, {fmt: "/_cache/clear"}],
            method: "POST"
        }), api.indices.prototype.close = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_close", req: {index: {type: "list"}}}, method: "POST"
        }), api.indices.prototype.create = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                updateAllTypes: {type: "boolean", name: "update_all_types"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "string"}}}, method: "POST"
        }), api.indices.prototype["delete"] = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "DELETE"
        }), api.indices.prototype.deleteAlias = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            },
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.deleteTemplate = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "DELETE"
        }), api.indices.prototype.deleteWarmer = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                name: {type: "list"}
            },
            url: {fmt: "/<%=index%>/_warmer/<%=name%>", req: {index: {type: "list"}, name: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.exists = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.existsAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }],
            method: "HEAD"
        }), api.indices.prototype.existsTemplate = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "HEAD"
        }), api.indices.prototype.existsType = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "list"}, type: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.flush = ca({
            params: {
                force: {type: "boolean"},
                waitIfOngoing: {type: "boolean", name: "wait_if_ongoing"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, urls: [{fmt: "/<%=index%>/_flush", req: {index: {type: "list"}}}, {fmt: "/_flush"}], method: "POST"
        }), api.indices.prototype.flushSynced = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{fmt: "/<%=index%>/_flush/synced", req: {index: {type: "list"}}}, {fmt: "/_flush/synced"}],
            method: "POST"
        }), api.indices.prototype.forcemerge = ca({
            params: {
                flush: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {
                    type: "boolean", name: "allow_no_indices"
                },
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                maxNumSegments: {type: "number", name: "max_num_segments"},
                onlyExpungeDeletes: {type: "boolean", name: "only_expunge_deletes"},
                operationThreading: {name: "operation_threading"},
                waitForMerge: {type: "boolean", name: "wait_for_merge"}
            },
            urls: [{fmt: "/<%=index%>/_forcemerge", req: {index: {type: "list"}}}, {fmt: "/_forcemerge"}],
            method: "POST"
        }), api.indices.prototype.get = ca({
            params: {
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1}
            },
            urls: [{
                fmt: "/<%=index%>/<%=feature%>",
                req: {
                    index: {type: "list"},
                    feature: {type: "list", options: ["_settings", "_mappings", "_warmers", "_aliases"]}
                }
            }, {fmt: "/<%=index%>", req: {index: {type: "list"}}}]
        }), api.indices.prototype.getAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }, {fmt: "/_alias"}]
        }), api.indices.prototype.getAliases = ca({
            params: {timeout: {type: "time"}, local: {type: "boolean"}},
            urls: [{
                fmt: "/<%=index%>/_aliases/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_aliases", req: {index: {type: "list"}}}, {
                fmt: "/_aliases/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_aliases"}]
        }), api.indices.prototype.getFieldMapping = ca({
            params: {
                includeDefaults: {
                    type: "boolean",
                    name: "include_defaults"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>/field/<%=fields%>",
                req: {index: {type: "list"}, type: {type: "list"}, fields: {type: "list"}}
            }, {
                fmt: "/<%=index%>/_mapping/field/<%=fields%>",
                req: {index: {type: "list"}, fields: {type: "list"}}
            }, {
                fmt: "/_mapping/<%=type%>/field/<%=fields%>",
                req: {type: {type: "list"}, fields: {type: "list"}}
            }, {fmt: "/_mapping/field/<%=fields%>", req: {fields: {type: "list"}}}]
        }), api.indices.prototype.getMapping = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_mapping", req: {index: {type: "list"}}}, {
                fmt: "/_mapping/<%=type%>",
                req: {type: {type: "list"}}
            }, {fmt: "/_mapping"}]
        }), api.indices.prototype.getSettings = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"},
                local: {type: "boolean"},
                human: {type: "boolean", "default": !1}
            },
            urls: [{
                fmt: "/<%=index%>/_settings/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {
                fmt: "/_settings/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_settings"}]
        }), api.indices.prototype.getTemplate = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_template/<%=name%>", req: {name: {type: "list"}}}, {fmt: "/_template"}]
        }), api.indices.prototype.getUpgrade = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}]
        }), api.indices.prototype.getWarmer = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, type: {type: "list"}, name: {type: "list"}}
            }, {
                fmt: "/<%=index%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_warmer", req: {index: {type: "list"}}}, {
                fmt: "/_warmer/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_warmer"}]
        }), api.indices.prototype.open = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "closed",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_open", req: {index: {type: "list"}}}, method: "POST"
        }), api.indices.prototype.optimize = ca({
            params: {
                flush: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                maxNumSegments: {type: "number", name: "max_num_segments"},
                onlyExpungeDeletes: {type: "boolean", name: "only_expunge_deletes"},
                operationThreading: {name: "operation_threading"},
                waitForMerge: {type: "boolean", name: "wait_for_merge"}
            }, urls: [{fmt: "/<%=index%>/_optimize", req: {index: {type: "list"}}}, {fmt: "/_optimize"}], method: "POST"
        }), api.indices.prototype.putAlias = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            },
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "string"}}},
            method: "PUT"
        }), api.indices.prototype.putMapping = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                updateAllTypes: {type: "boolean", name: "update_all_types"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "string"}}
            }, {fmt: "/_mapping/<%=type%>", req: {type: {type: "string"}}}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putSettings = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"}
            },
            urls: [{fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {fmt: "/_settings"}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putTemplate = ca({
            params: {
                order: {type: "number"},
                create: {type: "boolean", "default": !1},
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.indices.prototype.putWarmer = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                requestCache: {type: "boolean", name: "request_cache"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, type: {type: "list"}, name: {type: "string"}}
            }, {
                fmt: "/<%=index%>/_warmer/<%=name%>",
                req: {index: {type: "list"}, name: {type: "string"}}
            }, {fmt: "/_warmer/<%=name%>", req: {name: {type: "string"}}}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.recovery = ca({
            params: {
                detailed: {type: "boolean", "default": !1},
                activeOnly: {type: "boolean", "default": !1, name: "active_only"},
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_recovery", req: {index: {type: "list"}}}, {fmt: "/_recovery"}]
        }), api.indices.prototype.refresh = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                force: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_refresh", req: {index: {type: "list"}}}, {fmt: "/_refresh"}], method: "POST"
        }), api.indices.prototype.segments = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"},
                verbose: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_segments", req: {index: {type: "list"}}}, {fmt: "/_segments"}]
        }), api.indices.prototype.shardStores = ca({
            params: {
                status: {
                    type: "list",
                    options: ["green", "yellow", "red", "all"]
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_shard_stores", req: {index: {type: "list"}}}, {fmt: "/_shard_stores"}]
        }), api.indices.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "list"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "indices", options: ["cluster", "indices", "shards"]},
                types: {type: "list"}
            },
            urls: [{
                fmt: "/<%=index%>/_stats/<%=metric%>",
                req: {
                    index: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/<%=index%>/_stats", req: {index: {type: "list"}}}, {fmt: "/_stats"}]
        }), api.indices.prototype.updateAliases = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_aliases"}, needBody: !0, method: "POST"
        }), api.indices.prototype.upgrade = ca({
            params: {
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                waitForCompletion: {type: "boolean", name: "wait_for_completion"},
                onlyAncientSegments: {type: "boolean", name: "only_ancient_segments"}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}], method: "POST"
        }), api.indices.prototype.validateQuery = ca({
            params: {
                explain: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                operationThreading: {name: "operation_threading"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                rewrite: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_validate/query",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_validate/query", req: {index: {type: "list"}}}, {fmt: "/_validate/query"}],
            method: "POST"
        }), api.info = ca({url: {fmt: "/"}}), api.mget = ca({
            params: {
                fields: {type: "list"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mget",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mget", req: {index: {type: "string"}}}, {fmt: "/_mget"}],
            needBody: !0,
            method: "POST"
        }), api.mpercolate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mpercolate",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mpercolate", req: {index: {type: "string"}}}, {fmt: "/_mpercolate"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.msearch = ca({
            params: {
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch", "count", "scan"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_msearch",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_msearch", req: {index: {type: "list"}}}, {fmt: "/_msearch"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.mtermvectors = ca({
            params: {
                ids: {type: "list", required: !1},
                termStatistics: {type: "boolean", "default": !1, required: !1, name: "term_statistics"},
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mtermvectors",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mtermvectors", req: {index: {type: "string"}}}, {fmt: "/_mtermvectors"}],
            method: "POST"
        }), api.nodes = namespace(), api.nodes.prototype.hotThreads = ca({
            params: {
                interval: {type: "time"},
                snapshots: {type: "number"},
                threads: {type: "number"},
                ignoreIdleThreads: {type: "boolean", name: "ignore_idle_threads"},
                type: {type: "enum", options: ["cpu", "wait", "block"]},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_nodes/<%=nodeId%>/hotthreads", req: {nodeId: {type: "list"}}}, {fmt: "/_nodes/hotthreads"}]
        }), api.nodes.prototype.info = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "transport", "http", "plugins"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "transport", "http", "plugins"]
                    }
                }
            }, {fmt: "/_nodes"}]
        }), api.nodes.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "boolean"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "node", options: ["node", "indices", "shards"]},
                types: {type: "list"},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    }
                }
            }, {
                fmt: "/_nodes/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>/stats", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport"]
                    }
                }
            }, {fmt: "/_nodes/stats"}]
        }), api.percolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                percolateRouting: {type: "string", name: "percolate_routing"},
                percolatePreference: {type: "string", name: "percolate_preference"},
                percolateFormat: {type: "enum", options: ["ids"], name: "percolate_format"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api.ping = ca({
            url: {fmt: "/"},
            requestTimeout: 3e3,
            method: "HEAD"
        }), api.putScript = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            needBody: !0,
            method: "PUT"
        }), api.putTemplate = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.reindex = ca({
            params: {
                refresh: {type: "boolean"},
                timeout: {type: "time", "default": "1m"},
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            }, url: {fmt: "/_reindex"}, needBody: !0, method: "POST"
        }), api.renderSearchTemplate = ca({
            urls: [{
                fmt: "/_render/template/<%=id%>",
                req: {id: {type: "string"}}
            }, {fmt: "/_render/template"}], method: "POST"
        }), api.scroll = ca({
            params: {scroll: {type: "duration"}, scrollId: {type: "string", name: "scroll_id"}},
            urls: [{fmt: "/_search/scroll/<%=scrollId%>", req: {scrollId: {type: "string"}}}, {fmt: "/_search/scroll"}],
            paramAsBody: "scrollId",
            method: "POST"
        }), api.search = ca({
            params: {
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                explain: {type: "boolean"},
                fields: {type: "list"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                from: {type: "number"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "dfs_query_then_fetch", "count", "scan"],
                    name: "search_type"
                },
                size: {type: "number"},
                sort: {type: "list"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                terminateAfter: {type: "number", name: "terminate_after"},
                stats: {type: "list"},
                suggestField: {type: "string", name: "suggest_field"},
                suggestMode: {
                    type: "enum",
                    "default": "missing",
                    options: ["missing", "popular", "always"],
                    name: "suggest_mode"
                },
                suggestSize: {type: "number", name: "suggest_size"},
                suggestText: {type: "text", name: "suggest_text"},
                timeout: {type: "time"},
                trackScores: {type: "boolean", name: "track_scores"},
                version: {type: "boolean"},
                requestCache: {type: "boolean", name: "request_cache"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search", req: {index: {type: "list"}}}, {fmt: "/_search"}],
            method: "POST"
        }), api.searchExists = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                minScore: {type: "number", name: "min_score"},
                preference: {type: "string"},
                routing: {type: "string"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search/exists",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search/exists", req: {index: {type: "list"}}}, {fmt: "/_search/exists"}],
            method: "POST"
        }),api.searchShards = ca({
            params: {
                preference: {type: "string"},
                routing: {type: "string"},
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search_shards",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search_shards", req: {index: {type: "list"}}}, {fmt: "/_search_shards"}],
            method: "POST"
        }),api.searchTemplate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch", "count", "scan"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search/template",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search/template", req: {index: {type: "list"}}}, {fmt: "/_search/template"}],
            method: "POST"
        }),api.snapshot = namespace(),api.snapshot.prototype.create = ca({
            params: {
                masterTimeout: {
                    type: "time",
                    name: "master_timeout"
                }, waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.createRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                verify: {type: "boolean"}
            },
            url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "string"}}},
            needBody: !0,
            method: "POST"
        }),api.snapshot.prototype["delete"] = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "DELETE"
        }),api.snapshot.prototype.deleteRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, method: "DELETE"
        }),api.snapshot.prototype.get = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }
        }),api.snapshot.prototype.getRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, {fmt: "/_snapshot"}]
        }),api.snapshot.prototype.restore = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_restore",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.status = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            urls: [{
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_status",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }, {
                fmt: "/_snapshot/<%=repository%>/_status",
                req: {repository: {type: "string"}}
            }, {fmt: "/_snapshot/_status"}]
        }),api.snapshot.prototype.verifyRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>/_verify", req: {repository: {type: "string"}}}, method: "POST"
        }),api.suggest = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "string"}
            },
            urls: [{fmt: "/<%=index%>/_suggest", req: {index: {type: "list"}}}, {fmt: "/_suggest"}],
            needBody: !0,
            method: "POST"
        }),api.tasks = namespace(),api.tasks.prototype.cancel = ca({
            params: {
                nodeId: {type: "list", name: "node_id"},
                actions: {type: "list"},
                parentNode: {type: "string", name: "parent_node"},
                parentTask: {type: "string", name: "parent_task"}
            },
            urls: [{fmt: "/_tasks/<%=taskId%>/_cancel", req: {taskId: {type: "number"}}}, {fmt: "/_tasks/_cancel"}],
            method: "POST"
        }),api.tasks.prototype.list = ca({
            params: {
                nodeId: {type: "list", name: "node_id"},
                actions: {type: "list"},
                detailed: {type: "boolean"},
                parentNode: {type: "string", name: "parent_node"},
                parentTask: {type: "string", name: "parent_task"},
                waitForCompletion: {type: "boolean", name: "wait_for_completion"}
            }, urls: [{fmt: "/_tasks/<%=taskId%>", req: {taskId: {type: "string"}}}, {fmt: "/_tasks"}]
        }),api.termvectors = ca({
            params: {
                termStatistics: {
                    type: "boolean",
                    "default": !1,
                    required: !1,
                    name: "term_statistics"
                },
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                dfs: {type: "boolean", "default": !1, required: !1},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_termvectors",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_termvectors", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }),api.update = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                fields: {type: "list"},
                lang: {type: "string"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                retryOnConflict: {type: "number", name: "retry_on_conflict"},
                routing: {type: "string"},
                script: {},
                scriptId: {name: "script_id"},
                scriptedUpsert: {type: "boolean", name: "scripted_upsert"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {type: "enum", options: ["internal", "force"], name: "version_type"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_update",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }),api.updateByQuery = ca({
            params: {
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                explain: {type: "boolean"},
                fields: {type: "list"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                from: {type: "number"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                conflicts: {type: "enum", "default": "abort", options: ["abort", "proceed"]},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {type: "enum", options: ["query_then_fetch", "dfs_query_then_fetch"], name: "search_type"},
                searchTimeout: {type: "time", name: "search_timeout"},
                size: {type: "number"},
                sort: {type: "list"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                terminateAfter: {type: "number", name: "terminate_after"},
                stats: {type: "list"},
                suggestField: {type: "string", name: "suggest_field"},
                suggestMode: {
                    type: "enum",
                    "default": "missing",
                    options: ["missing", "popular", "always"],
                    name: "suggest_mode"
                },
                suggestSize: {type: "number", name: "suggest_size"},
                suggestText: {type: "text", name: "suggest_text"},
                timeout: {type: "time", "default": "1m"},
                trackScores: {type: "boolean", name: "track_scores"},
                version: {type: "boolean"},
                versionType: {type: "boolean", name: "version_type"},
                requestCache: {type: "boolean", name: "request_cache"},
                refresh: {type: "boolean"},
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                scrollSize: {type: "integer", name: "scroll_size"},
                waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_update_by_query",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_update_by_query", req: {index: {type: "list"}}}],
            method: "POST"
        }),api.create = ca.proxy(api.index, {
            transform: function (params) {
                params.op_type = "create"
            }
        })
    }, {"../client_action": 15, "../utils": 38}],
    11: [function (require, module, exports) {
        arguments[4][10][0].apply(exports, arguments)
    }, {"../client_action": 15, "../utils": 38, dup: 10}],
    12: [function (require, module, exports) {
        module.exports = {
            _default: require("./2_3"),
            2.3: require("./2_3"),
            2.2: require("./2_2"),
            2.1: require("./2_1"),
            "2.0": require("./2_0"),
            1.7: require("./1_7"),
            "2.x": require("./2_x"),
            master: require("./master")
        }
    }, {"./1_7": 6, "./2_0": 7, "./2_1": 8, "./2_2": 9, "./2_3": 10, "./2_x": 11, "./master": 13}],
    13: [function (require, module, exports) {
        var ca = require("../client_action").makeFactoryWithModifier(function (spec) {
            return require("../utils").merge(spec, {params: {filterPath: {type: "list", name: "filter_path"}}})
        }), namespace = require("../client_action").namespaceFactory, api = module.exports = {};
        api._namespaces = ["cat", "cluster", "indices", "ingest", "nodes", "reindex", "snapshot", "tasks"], api.bulk = ca({
            params: {
                consistency: {
                    type: "enum",
                    options: ["one", "quorum", "all"]
                },
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                type: {type: "string"},
                fields: {type: "list"},
                pipeline: {type: "string"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_bulk",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_bulk", req: {index: {type: "string"}}}, {fmt: "/_bulk"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.cat = namespace(), api.cat.prototype.aliases = ca({
            params: {
                format: {type: "string"},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/aliases/<%=name%>", req: {name: {type: "list"}}}, {fmt: "/_cat/aliases"}]
        }), api.cat.prototype.allocation = ca({
            params: {
                format: {type: "string"},
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {
                    type: "time",
                    name: "master_timeout"
                },
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/allocation/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cat/allocation"}]
        }), api.cat.prototype.count = ca({
            params: {
                format: {type: "string"},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/count/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/count"}]
        }), api.cat.prototype.fielddata = ca({
            params: {
                format: {type: "string"},
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1},
                fields: {type: "list"}
            }, urls: [{fmt: "/_cat/fielddata/<%=fields%>", req: {fields: {type: "list"}}}, {fmt: "/_cat/fielddata"}]
        }), api.cat.prototype.health = ca({
            params: {
                format: {type: "string"},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                ts: {type: "boolean", "default": !0},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/health"}
        }), api.cat.prototype.help = ca({
            params: {help: {type: "boolean", "default": !1}},
            url: {fmt: "/_cat"}
        }), api.cat.prototype.indices = ca({
            params: {
                format: {type: "string"},
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                pri: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/indices/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/indices"}]
        }), api.cat.prototype.master = ca({
            params: {
                format: {type: "string"},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/master"}
        }), api.cat.prototype.nodeattrs = ca({
            params: {
                format: {type: "string"},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/nodeattrs"}
        }), api.cat.prototype.nodes = ca({
            params: {
                format: {type: "string"},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/nodes"}
        }), api.cat.prototype.pendingTasks = ca({
            params: {
                format: {type: "string"},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/pending_tasks"}
        }), api.cat.prototype.plugins = ca({
            params: {
                format: {type: "string"},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/plugins"}
        }), api.cat.prototype.recovery = ca({
            params: {
                format: {type: "string"},
                bytes: {type: "enum", options: ["b", "k", "m", "g"]},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/recovery/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/recovery"}]
        }), api.cat.prototype.repositories = ca({
            params: {
                format: {type: "string"},
                local: {type: "boolean", "default": !1},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/repositories"}
        }), api.cat.prototype.segments = ca({
            params: {
                format: {type: "string"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/segments/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/segments"}]
        }), api.cat.prototype.shards = ca({
            params: {
                format: {type: "string"},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/_cat/shards/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cat/shards"}]
        }), api.cat.prototype.snapshots = ca({
            params: {
                format: {type: "string"},
                ignoreUnavailable: {type: "boolean", "default": !1, name: "ignore_unavailable"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1}
            }, url: {fmt: "/_cat/snapshots/<%=repository%>", req: {repository: {type: "list"}}}
        }), api.cat.prototype.threadPool = ca({
            params: {
                format: {type: "string"},
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                h: {type: "list"},
                help: {type: "boolean", "default": !1},
                v: {type: "boolean", "default": !1},
                fullId: {type: "boolean", "default": !1, name: "full_id"}
            }, url: {fmt: "/_cat/thread_pool"}
        }), api.clearScroll = ca({
            urls: [{
                fmt: "/_search/scroll/<%=scrollId%>",
                req: {scrollId: {type: "list"}}
            }, {fmt: "/_search/scroll"}], method: "DELETE"
        }), api.cluster = namespace(), api.cluster.prototype.allocationExplain = ca({
            params: {
                includeYesDecisions: {
                    type: "boolean",
                    name: "include_yes_decisions"
                }
            }, url: {fmt: "/_cluster/allocation/explain"}, method: "POST"
        }), api.cluster.prototype.getSettings = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                includeDefaults: {type: "boolean", "default": !1, name: "include_defaults"}
            }, url: {fmt: "/_cluster/settings"}
        }), api.cluster.prototype.health = ca({
            params: {
                level: {
                    type: "enum",
                    "default": "cluster",
                    options: ["cluster", "indices", "shards"]
                },
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                waitForActiveShards: {type: "number", name: "wait_for_active_shards"},
                waitForNodes: {type: "string", name: "wait_for_nodes"},
                waitForRelocatingShards: {type: "number", name: "wait_for_relocating_shards"},
                waitForStatus: {
                    type: "enum",
                    "default": null,
                    options: ["green", "yellow", "red"],
                    name: "wait_for_status"
                }
            }, urls: [{fmt: "/_cluster/health/<%=index%>", req: {index: {type: "list"}}}, {fmt: "/_cluster/health"}]
        }), api.cluster.prototype.pendingTasks = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_cluster/pending_tasks"}
        }), api.cluster.prototype.putSettings = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/settings"}, method: "PUT"
        }), api.cluster.prototype.reroute = ca({
            params: {
                dryRun: {type: "boolean", name: "dry_run"},
                explain: {type: "boolean"},
                metric: {
                    type: "list",
                    options: ["_all", "blocks", "metadata", "nodes", "routing_table", "master_node", "version"]
                },
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_cluster/reroute"}, method: "POST"
        }), api.cluster.prototype.state = ca({
            params: {
                local: {type: "boolean"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/_cluster/state/<%=metric%>/<%=index%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }, index: {type: "list"}
                }
            }, {
                fmt: "/_cluster/state/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "blocks", "metadata", "nodes", "routing_table", "routing_nodes", "master_node", "version"]
                    }
                }
            }, {fmt: "/_cluster/state"}]
        }), api.cluster.prototype.stats = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_cluster/stats/nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {fmt: "/_cluster/stats"}]
        }), api.count = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                minScore: {type: "number", name: "min_score"},
                preference: {type: "string"},
                routing: {type: "string"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_count",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_count", req: {index: {type: "list"}}}, {fmt: "/_count"}],
            method: "POST"
        }), api.countPercolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate/count",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate/count", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api["delete"] = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "DELETE"
        }), api.deleteScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            method: "DELETE"
        }), api.deleteTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, method: "DELETE"
        }), api.exists = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "HEAD"
        }), api.explain = ca({
            params: {
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                analyzer: {type: "string"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                fields: {type: "list"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                parent: {type: "string"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_explain",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }), api.fieldStats = ca({
            params: {
                fields: {type: "list"},
                level: {type: "enum", "default": "cluster", options: ["indices", "cluster"]},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{fmt: "/<%=index%>/_field_stats", req: {index: {type: "list"}}}, {fmt: "/_field_stats"}],
            method: "POST"
        }), api.get = ca({
            params: {
                fields: {type: "list"},
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getScript = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}}
        }), api.getSource = ca({
            params: {
                parent: {type: "string"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_source",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }
        }), api.getTemplate = ca({
            params: {
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}
        }), api.index = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                opType: {type: "enum", "default": "index", options: ["index", "create"], name: "op_type"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                routing: {type: "string"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                },
                pipeline: {type: "string"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "string"}, type: {type: "string"}}}],
            needBody: !0,
            method: "POST"
        }), api.indices = namespace(), api.indices.prototype.analyze = ca({
            params: {
                analyzer: {type: "string"},
                charFilters: {type: "list", name: "char_filters"},
                field: {type: "string"},
                filters: {type: "list"},
                index: {type: "string"},
                preferLocal: {type: "boolean", name: "prefer_local"},
                text: {type: "list"},
                tokenizer: {type: "string"},
                explain: {type: "boolean"},
                attributes: {type: "list"},
                format: {type: "enum", "default": "detailed", options: ["detailed", "text"]}
            }, urls: [{fmt: "/<%=index%>/_analyze", req: {index: {type: "string"}}}, {fmt: "/_analyze"}], method: "POST"
        }), api.indices.prototype.clearCache = ca({
            params: {
                fieldData: {type: "boolean", name: "field_data"},
                fielddata: {type: "boolean"},
                fields: {type: "list"},
                query: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                index: {type: "list"},
                recycler: {type: "boolean"},
                request: {type: "boolean"}
            },
            urls: [{fmt: "/<%=index%>/_cache/clear", req: {index: {type: "list"}}}, {fmt: "/_cache/clear"}],
            method: "POST"
        }), api.indices.prototype.close = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_close", req: {index: {type: "list"}}}, method: "POST"
        }), api.indices.prototype.create = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                updateAllTypes: {type: "boolean", name: "update_all_types"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "string"}}}, method: "POST"
        }), api.indices.prototype["delete"] = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "DELETE"
        }), api.indices.prototype.deleteAlias = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            },
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "list"}}},
            method: "DELETE"
        }), api.indices.prototype.deleteTemplate = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "DELETE"
        }), api.indices.prototype.exists = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>", req: {index: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.existsAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }],
            method: "HEAD"
        }), api.indices.prototype.existsTemplate = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, method: "HEAD"
        }), api.indices.prototype.existsType = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            }, url: {fmt: "/<%=index%>/<%=type%>", req: {index: {type: "list"}, type: {type: "list"}}}, method: "HEAD"
        }), api.indices.prototype.flush = ca({
            params: {
                force: {type: "boolean"},
                waitIfOngoing: {type: "boolean", name: "wait_if_ongoing"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, urls: [{fmt: "/<%=index%>/_flush", req: {index: {type: "list"}}}, {fmt: "/_flush"}], method: "POST"
        }), api.indices.prototype.flushSynced = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{fmt: "/<%=index%>/_flush/synced", req: {index: {type: "list"}}}, {fmt: "/_flush/synced"}],
            method: "POST"
        }), api.indices.prototype.forcemerge = ca({
            params: {
                flush: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                maxNumSegments: {type: "number", name: "max_num_segments"},
                onlyExpungeDeletes: {type: "boolean", name: "only_expunge_deletes"},
                operationThreading: {name: "operation_threading"},
                waitForMerge: {type: "boolean", name: "wait_for_merge"}
            },
            urls: [{fmt: "/<%=index%>/_forcemerge", req: {index: {type: "list"}}}, {fmt: "/_forcemerge"}],
            method: "POST"
        }), api.indices.prototype.get = ca({
            params: {
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                includeDefaults: {type: "boolean", "default": !1, name: "include_defaults"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=feature%>",
                req: {index: {type: "list"}, feature: {type: "list", options: ["_settings", "_mappings", "_aliases"]}}
            }, {fmt: "/<%=index%>", req: {index: {type: "list"}}}]
        }), api.indices.prototype.getAlias = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "all",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_alias/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/_alias/<%=name%>", req: {name: {type: "list"}}}, {
                fmt: "/<%=index%>/_alias",
                req: {index: {type: "list"}}
            }, {fmt: "/_alias"}]
        }), api.indices.prototype.getFieldMapping = ca({
            params: {
                includeDefaults: {
                    type: "boolean",
                    name: "include_defaults"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>/field/<%=fields%>",
                req: {index: {type: "list"}, type: {type: "list"}, fields: {type: "list"}}
            }, {
                fmt: "/<%=index%>/_mapping/field/<%=fields%>",
                req: {index: {type: "list"}, fields: {type: "list"}}
            }, {
                fmt: "/_mapping/<%=type%>/field/<%=fields%>",
                req: {type: {type: "list"}, fields: {type: "list"}}
            }, {fmt: "/_mapping/field/<%=fields%>", req: {fields: {type: "list"}}}]
        }), api.indices.prototype.getMapping = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                local: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_mapping", req: {index: {type: "list"}}}, {
                fmt: "/_mapping/<%=type%>",
                req: {type: {type: "list"}}
            }, {fmt: "/_mapping"}]
        }), api.indices.prototype.getSettings = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": ["open", "closed"],
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"},
                local: {type: "boolean"},
                human: {type: "boolean", "default": !1},
                includeDefaults: {type: "boolean", "default": !1, name: "include_defaults"}
            },
            urls: [{
                fmt: "/<%=index%>/_settings/<%=name%>",
                req: {index: {type: "list"}, name: {type: "list"}}
            }, {fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {
                fmt: "/_settings/<%=name%>",
                req: {name: {type: "list"}}
            }, {fmt: "/_settings"}]
        }), api.indices.prototype.getTemplate = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_template/<%=name%>", req: {name: {type: "list"}}}, {fmt: "/_template"}]
        }), api.indices.prototype.getUpgrade = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}]
        }), api.indices.prototype.open = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "closed",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            }, url: {fmt: "/<%=index%>/_open", req: {index: {type: "list"}}}, method: "POST"
        }), api.indices.prototype.putAlias = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            },
            url: {fmt: "/<%=index%>/_alias/<%=name%>", req: {index: {type: "list"}, name: {type: "string"}}},
            method: "PUT"
        }), api.indices.prototype.putMapping = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                updateAllTypes: {type: "boolean", name: "update_all_types"}
            },
            urls: [{
                fmt: "/<%=index%>/_mapping/<%=type%>",
                req: {index: {type: "list"}, type: {type: "string"}}
            }, {fmt: "/_mapping/<%=type%>", req: {type: {type: "string"}}}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putSettings = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                preserveExisting: {type: "boolean", name: "preserve_existing"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                flatSettings: {type: "boolean", name: "flat_settings"}
            },
            urls: [{fmt: "/<%=index%>/_settings", req: {index: {type: "list"}}}, {fmt: "/_settings"}],
            needBody: !0,
            method: "PUT"
        }), api.indices.prototype.putTemplate = ca({
            params: {
                order: {type: "number"},
                create: {type: "boolean", "default": !1},
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"},
                flatSettings: {type: "boolean", name: "flat_settings"}
            }, url: {fmt: "/_template/<%=name%>", req: {name: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.indices.prototype.recovery = ca({
            params: {
                detailed: {type: "boolean", "default": !1},
                activeOnly: {type: "boolean", "default": !1, name: "active_only"},
                human: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_recovery", req: {index: {type: "list"}}}, {fmt: "/_recovery"}]
        }), api.indices.prototype.refresh = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                force: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_refresh", req: {index: {type: "list"}}}, {fmt: "/_refresh"}], method: "POST"
        }), api.indices.prototype.segments = ca({
            params: {
                ignoreUnavailable: {
                    type: "boolean",
                    name: "ignore_unavailable"
                },
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                human: {type: "boolean", "default": !1},
                operationThreading: {name: "operation_threading"},
                verbose: {type: "boolean", "default": !1}
            }, urls: [{fmt: "/<%=index%>/_segments", req: {index: {type: "list"}}}, {fmt: "/_segments"}]
        }), api.indices.prototype.shardStores = ca({
            params: {
                status: {
                    type: "list",
                    options: ["green", "yellow", "red", "all"]
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                operationThreading: {name: "operation_threading"}
            }, urls: [{fmt: "/<%=index%>/_shard_stores", req: {index: {type: "list"}}}, {fmt: "/_shard_stores"}]
        }), api.indices.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "list"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "indices", options: ["cluster", "indices", "shards"]},
                types: {type: "list"}
            },
            urls: [{
                fmt: "/<%=index%>/_stats/<%=metric%>",
                req: {
                    index: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/<%=index%>/_stats", req: {index: {type: "list"}}}, {fmt: "/_stats"}]
        }), api.indices.prototype.updateAliases = ca({
            params: {
                timeout: {type: "time"},
                masterTimeout: {type: "time", name: "master_timeout"}
            }, url: {fmt: "/_aliases"}, needBody: !0, method: "POST"
        }), api.indices.prototype.upgrade = ca({
            params: {
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                waitForCompletion: {type: "boolean", name: "wait_for_completion"},
                onlyAncientSegments: {type: "boolean", name: "only_ancient_segments"}
            }, urls: [{fmt: "/<%=index%>/_upgrade", req: {index: {type: "list"}}}, {fmt: "/_upgrade"}], method: "POST"
        }), api.indices.prototype.validateQuery = ca({
            params: {
                explain: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                operationThreading: {name: "operation_threading"},
                q: {type: "string"},
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                rewrite: {type: "boolean"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_validate/query",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_validate/query", req: {index: {type: "list"}}}, {fmt: "/_validate/query"}],
            method: "POST"
        }), api.info = ca({url: {fmt: "/"}}), api.ingest = namespace(), api.ingest.prototype.deletePipeline = ca({
            params: {
                masterTimeout: {
                    type: "time",
                    name: "master_timeout"
                }, timeout: {type: "time"}
            }, url: {fmt: "/_ingest/pipeline/<%=id%>", req: {id: {type: "string"}}}, method: "DELETE"
        }), api.ingest.prototype.getPipeline = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {fmt: "/_ingest/pipeline/<%=id%>", req: {id: {type: "string"}}}
        }), api.ingest.prototype.putPipeline = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_ingest/pipeline/<%=id%>", req: {id: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.ingest.prototype.simulate = ca({
            params: {verbose: {type: "boolean", "default": !1}},
            urls: [{
                fmt: "/_ingest/pipeline/<%=id%>/_simulate/",
                req: {id: {type: "string"}}
            }, {fmt: "/_ingest/pipeline/_simulate"}],
            needBody: !0,
            method: "POST"
        }), api.mget = ca({
            params: {
                fields: {type: "list"},
                preference: {type: "string"},
                realtime: {type: "boolean"},
                refresh: {type: "boolean"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mget",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mget", req: {index: {type: "string"}}}, {fmt: "/_mget"}],
            needBody: !0,
            method: "POST"
        }), api.mpercolate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mpercolate",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mpercolate", req: {index: {type: "string"}}}, {fmt: "/_mpercolate"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.msearch = ca({
            params: {
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_msearch",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_msearch", req: {index: {type: "list"}}}, {fmt: "/_msearch"}],
            needBody: !0,
            bulkBody: !0,
            method: "POST"
        }), api.mtermvectors = ca({
            params: {
                ids: {type: "list", required: !1},
                termStatistics: {type: "boolean", "default": !1, required: !1, name: "term_statistics"},
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_mtermvectors",
                req: {index: {type: "string"}, type: {type: "string"}}
            }, {fmt: "/<%=index%>/_mtermvectors", req: {index: {type: "string"}}}, {fmt: "/_mtermvectors"}],
            method: "POST"
        }), api.nodes = namespace(), api.nodes.prototype.hotThreads = ca({
            params: {
                interval: {type: "time"},
                snapshots: {
                    type: "number"
                },
                threads: {type: "number"},
                ignoreIdleThreads: {type: "boolean", name: "ignore_idle_threads"},
                type: {type: "enum", options: ["cpu", "wait", "block"]},
                timeout: {type: "time"}
            },
            urls: [{fmt: "/_nodes/<%=nodeId%>/hotthreads", req: {nodeId: {type: "list"}}}, {fmt: "/_nodes/hotthreads"}]
        }), api.nodes.prototype.info = ca({
            params: {
                flatSettings: {type: "boolean", name: "flat_settings"},
                human: {type: "boolean", "default": !1},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "transport", "http", "plugins", "ingest"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["settings", "os", "process", "jvm", "thread_pool", "transport", "http", "plugins", "ingest"]
                    }
                }
            }, {fmt: "/_nodes"}]
        }), api.nodes.prototype.stats = ca({
            params: {
                completionFields: {type: "list", name: "completion_fields"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                fields: {type: "list"},
                groups: {type: "boolean"},
                human: {type: "boolean", "default": !1},
                level: {type: "enum", "default": "node", options: ["node", "indices", "shards"]},
                types: {type: "list"},
                timeout: {type: "time"}
            },
            urls: [{
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport", "discovery"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {
                fmt: "/_nodes/<%=nodeId%>/stats/<%=metric%>",
                req: {
                    nodeId: {type: "list"},
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport", "discovery"]
                    }
                }
            }, {
                fmt: "/_nodes/stats/<%=metric%>/<%=indexMetric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport", "discovery"]
                    },
                    indexMetric: {
                        type: "list",
                        options: ["_all", "completion", "docs", "fielddata", "query_cache", "flush", "get", "indexing", "merge", "percolate", "request_cache", "refresh", "search", "segments", "store", "warmer", "suggest"]
                    }
                }
            }, {fmt: "/_nodes/<%=nodeId%>/stats", req: {nodeId: {type: "list"}}}, {
                fmt: "/_nodes/stats/<%=metric%>",
                req: {
                    metric: {
                        type: "list",
                        options: ["_all", "breaker", "fs", "http", "indices", "jvm", "os", "process", "thread_pool", "transport", "discovery"]
                    }
                }
            }, {fmt: "/_nodes/stats"}]
        }), api.percolate = ca({
            params: {
                routing: {type: "list"},
                preference: {type: "string"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                percolateIndex: {type: "string", name: "percolate_index"},
                percolateType: {type: "string", name: "percolate_type"},
                percolateRouting: {type: "string", name: "percolate_routing"},
                percolatePreference: {type: "string", name: "percolate_preference"},
                percolateFormat: {type: "enum", options: ["ids"], name: "percolate_format"},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_percolate",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_percolate", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }), api.ping = ca({
            url: {fmt: "/"},
            requestTimeout: 3e3,
            method: "HEAD"
        }), api.putScript = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            url: {fmt: "/_scripts/<%=lang%>/<%=id%>", req: {lang: {type: "string"}, id: {type: "string"}}},
            needBody: !0,
            method: "PUT"
        }), api.putTemplate = ca({
            params: {
                opType: {
                    type: "enum",
                    "default": "index",
                    options: ["index", "create"],
                    name: "op_type"
                },
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            }, url: {fmt: "/_search/template/<%=id%>", req: {id: {type: "string"}}}, needBody: !0, method: "PUT"
        }), api.reindex = namespace(), api.reindex = ca({
            params: {
                refresh: {type: "boolean"},
                timeout: {type: "time", "default": "1m"},
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"},
                requestsPerSecond: {type: "float", "default": 0, name: "requests_per_second"}
            }, url: {fmt: "/_reindex"}, needBody: !0, method: "POST"
        }), api.reindex.prototype.rethrottle = ca({
            params: {
                requestsPerSecond: {
                    type: "float",
                    "default": 0,
                    name: "requests_per_second"
                }
            }, url: {fmt: "/_reindex/<%=taskId%>/_rethrottle", req: {taskId: {type: "string"}}}, method: "POST"
        }), api.renderSearchTemplate = ca({
            urls: [{
                fmt: "/_render/template/<%=id%>",
                req: {id: {type: "string"}}
            }, {fmt: "/_render/template"}], method: "POST"
        }),api.scroll = ca({
            params: {scroll: {type: "duration"}, scrollId: {type: "string", name: "scroll_id"}},
            urls: [{fmt: "/_search/scroll/<%=scrollId%>", req: {scrollId: {type: "string"}}}, {fmt: "/_search/scroll"}],
            paramAsBody: "scrollId",
            method: "POST"
        }),api.search = ca({
            params: {
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                explain: {type: "boolean"},
                fields: {type: "list"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                from: {type: "number"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {type: "enum", options: ["query_then_fetch", "dfs_query_then_fetch"], name: "search_type"},
                size: {type: "number"},
                sort: {type: "list"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                terminateAfter: {type: "number", name: "terminate_after"},
                stats: {type: "list"},
                suggestField: {type: "string", name: "suggest_field"},
                suggestMode: {
                    type: "enum",
                    "default": "missing",
                    options: ["missing", "popular", "always"],
                    name: "suggest_mode"
                },
                suggestSize: {type: "number", name: "suggest_size"},
                suggestText: {type: "text", name: "suggest_text"},
                timeout: {type: "time"},
                trackScores: {type: "boolean", name: "track_scores"},
                version: {type: "boolean"},
                requestCache: {type: "boolean", name: "request_cache"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search", req: {index: {type: "list"}}}, {fmt: "/_search"}],
            method: "POST"
        }),api.searchShards = ca({
            params: {
                preference: {type: "string"},
                routing: {type: "string"},
                local: {type: "boolean"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search_shards",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search_shards", req: {index: {type: "list"}}}, {fmt: "/_search_shards"}],
            method: "POST"
        }),api.searchTemplate = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {
                    type: "enum",
                    options: ["query_then_fetch", "query_and_fetch", "dfs_query_then_fetch", "dfs_query_and_fetch"],
                    name: "search_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_search/template",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_search/template", req: {index: {type: "list"}}}, {fmt: "/_search/template"}],
            method: "POST"
        }),api.snapshot = namespace(),api.snapshot.prototype.create = ca({
            params: {
                masterTimeout: {
                    type: "time",
                    name: "master_timeout"
                }, waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.createRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"},
                verify: {type: "boolean"}
            },
            url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "string"}}},
            needBody: !0,
            method: "POST"
        }),api.snapshot.prototype["delete"] = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "DELETE"
        }),api.snapshot.prototype.deleteRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, method: "DELETE"
        }),api.snapshot.prototype.get = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }
        }),api.snapshot.prototype.getRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                local: {type: "boolean"}
            }, urls: [{fmt: "/_snapshot/<%=repository%>", req: {repository: {type: "list"}}}, {fmt: "/_snapshot"}]
        }),api.snapshot.prototype.restore = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"}
            },
            url: {
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_restore",
                req: {repository: {type: "string"}, snapshot: {type: "string"}}
            },
            method: "POST"
        }),api.snapshot.prototype.status = ca({
            params: {masterTimeout: {type: "time", name: "master_timeout"}},
            urls: [{
                fmt: "/_snapshot/<%=repository%>/<%=snapshot%>/_status",
                req: {repository: {type: "string"}, snapshot: {type: "list"}}
            }, {
                fmt: "/_snapshot/<%=repository%>/_status",
                req: {repository: {type: "string"}}
            }, {fmt: "/_snapshot/_status"}]
        }),api.snapshot.prototype.verifyRepository = ca({
            params: {
                masterTimeout: {type: "time", name: "master_timeout"},
                timeout: {type: "time"}
            }, url: {fmt: "/_snapshot/<%=repository%>/_verify", req: {repository: {type: "string"}}}, method: "POST"
        }),api.suggest = ca({
            params: {
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                preference: {type: "string"},
                routing: {type: "string"}
            },
            urls: [{fmt: "/<%=index%>/_suggest", req: {index: {type: "list"}}}, {fmt: "/_suggest"}],
            needBody: !0,
            method: "POST"
        }),api.tasks = namespace(),api.tasks.prototype.cancel = ca({
            params: {
                nodeId: {type: "list", name: "node_id"},
                actions: {type: "list"},
                parentNode: {type: "string", name: "parent_node"},
                parentTask: {type: "string", name: "parent_task"}
            },
            urls: [{fmt: "/_tasks/<%=taskId%>/_cancel", req: {taskId: {type: "string"}}}, {fmt: "/_tasks/_cancel"}],
            method: "POST"
        }),api.tasks.prototype.list = ca({
            params: {
                nodeId: {type: "list", name: "node_id"},
                actions: {type: "list"},
                detailed: {type: "boolean"},
                parentNode: {type: "string", name: "parent_node"},
                parentTask: {type: "string", name: "parent_task"},
                waitForCompletion: {type: "boolean", name: "wait_for_completion"},
                groupBy: {type: "enum", "default": "nodes", options: ["nodes", "parents"], name: "group_by"}
            }, urls: [{fmt: "/_tasks/<%=taskId%>", req: {taskId: {type: "string"}}}, {fmt: "/_tasks"}]
        }),api.termvectors = ca({
            params: {
                termStatistics: {
                    type: "boolean",
                    "default": !1,
                    required: !1,
                    name: "term_statistics"
                },
                fieldStatistics: {type: "boolean", "default": !0, required: !1, name: "field_statistics"},
                fields: {type: "list", required: !1},
                offsets: {type: "boolean", "default": !0, required: !1},
                positions: {type: "boolean", "default": !0, required: !1},
                payloads: {type: "boolean", "default": !0, required: !1},
                preference: {type: "string", required: !1},
                routing: {type: "string", required: !1},
                parent: {type: "string", required: !1},
                realtime: {type: "boolean", required: !1},
                version: {type: "number"},
                versionType: {
                    type: "enum",
                    options: ["internal", "external", "external_gte", "force"],
                    name: "version_type"
                }
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_termvectors",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            }, {fmt: "/<%=index%>/<%=type%>/_termvectors", req: {index: {type: "string"}, type: {type: "string"}}}],
            method: "POST"
        }),api.update = ca({
            params: {
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                fields: {type: "list"},
                lang: {type: "string"},
                parent: {type: "string"},
                refresh: {type: "boolean"},
                retryOnConflict: {type: "number", name: "retry_on_conflict"},
                routing: {type: "string"},
                script: {},
                scriptId: {name: "script_id"},
                scriptedUpsert: {type: "boolean", name: "scripted_upsert"},
                timeout: {type: "time"},
                timestamp: {type: "time"},
                ttl: {type: "duration"},
                version: {type: "number"},
                versionType: {type: "enum", options: ["internal", "force"], name: "version_type"}
            },
            url: {
                fmt: "/<%=index%>/<%=type%>/<%=id%>/_update",
                req: {index: {type: "string"}, type: {type: "string"}, id: {type: "string"}}
            },
            method: "POST"
        }),api.updateByQuery = ca({
            params: {
                analyzer: {type: "string"},
                analyzeWildcard: {type: "boolean", name: "analyze_wildcard"},
                defaultOperator: {type: "enum", "default": "OR", options: ["AND", "OR"], name: "default_operator"},
                df: {type: "string"},
                explain: {type: "boolean"},
                fields: {type: "list"},
                fielddataFields: {type: "list", name: "fielddata_fields"},
                from: {type: "number"},
                ignoreUnavailable: {type: "boolean", name: "ignore_unavailable"},
                allowNoIndices: {type: "boolean", name: "allow_no_indices"},
                conflicts: {type: "enum", "default": "abort", options: ["abort", "proceed"]},
                expandWildcards: {
                    type: "enum",
                    "default": "open",
                    options: ["open", "closed", "none", "all"],
                    name: "expand_wildcards"
                },
                lenient: {type: "boolean"},
                lowercaseExpandedTerms: {type: "boolean", name: "lowercase_expanded_terms"},
                pipeline: {type: "string"},
                preference: {type: "string"},
                q: {type: "string"},
                routing: {type: "list"},
                scroll: {type: "duration"},
                searchType: {type: "enum", options: ["query_then_fetch", "dfs_query_then_fetch"], name: "search_type"},
                searchTimeout: {type: "time", name: "search_timeout"},
                size: {type: "number"},
                sort: {type: "list"},
                _source: {type: "list"},
                _sourceExclude: {type: "list", name: "_source_exclude"},
                _sourceInclude: {type: "list", name: "_source_include"},
                terminateAfter: {type: "number", name: "terminate_after"},
                stats: {type: "list"},
                suggestField: {type: "string", name: "suggest_field"},
                suggestMode: {
                    type: "enum",
                    "default": "missing",
                    options: ["missing", "popular", "always"],
                    name: "suggest_mode"
                },
                suggestSize: {type: "number", name: "suggest_size"},
                suggestText: {type: "text", name: "suggest_text"},
                timeout: {type: "time", "default": "1m"},
                trackScores: {type: "boolean", name: "track_scores"},
                version: {type: "boolean"},
                versionType: {type: "boolean", name: "version_type"},
                requestCache: {type: "boolean", name: "request_cache"},
                refresh: {type: "boolean"},
                consistency: {type: "enum", options: ["one", "quorum", "all"]},
                scrollSize: {type: "integer", name: "scroll_size"},
                waitForCompletion: {type: "boolean", "default": !1, name: "wait_for_completion"},
                requestsPerSecond: {type: "float", "default": 0, name: "requests_per_second"}
            },
            urls: [{
                fmt: "/<%=index%>/<%=type%>/_update_by_query",
                req: {index: {type: "list"}, type: {type: "list"}}
            }, {fmt: "/<%=index%>/_update_by_query", req: {index: {type: "list"}}}],
            method: "POST"
        }),api.create = ca.proxy(api.index, {
            transform: function (params) {
                params.op_type = "create"
            }
        })
    }, {"../client_action": 15, "../utils": 38}],
    14: [function (require, module, exports) {
        function Client(config) {
            function EsApiClient() {
                config.hasOwnProperty("log") || (config.log = "warning"), config.hosts || config.host || (config.host = "http://localhost:9200"), this.close = function () {
                    this.transport.close()
                }, this.transport = new Transport(config), _.each(EsApiClient.prototype, function (Fn, prop) {
                    Fn.prototype instanceof clientAction.ApiNamespace && (this[prop] = new Fn(this.transport))
                }, this), delete this._namespaces
            }

            if (config = config || {}, config.__reused)throw new Error("Do not reuse objects to configure the elasticsearch Client class: https://github.com/elasticsearch/elasticsearch-js/issues/33");
            config.__reused = !0, EsApiClient.prototype = _.funcEnum(config, "apiVersion", Client.apis, "_default"), config.sniffEndpoint || EsApiClient.prototype !== Client.apis["0.90"] || (config.sniffEndpoint = "/_cluster/nodes");
            var Constructor = EsApiClient;
            return config.plugins && (Constructor.prototype = _.cloneDeep(Constructor.prototype), _.each(config.plugins, function (setup) {
                Constructor = setup(Constructor, config, {
                        apis: require("./apis"),
                        connectors: require("./connectors"),
                        loggers: require("./loggers"),
                        selectors: require("./selectors"),
                        serializers: require("./serializers"),
                        Client: require("./client"),
                        clientAction: clientAction,
                        Connection: require("./connection"),
                        ConnectionPool: require("./connection_pool"),
                        Errors: require("./errors"),
                        Host: require("./host"),
                        Log: require("./log"),
                        Logger: require("./logger"),
                        NodesToHost: require("./nodes_to_host"),
                        Transport: require("./transport"),
                        utils: require("./utils")
                    }) || Constructor
            })), new Constructor
        }

        module.exports = Client;
        var Transport = require("./transport"), clientAction = require("./client_action"), _ = require("./utils");
        Client.apis = require("./apis")
    }, {
        "./apis": 12,
        "./client": 14,
        "./client_action": 15,
        "./connection": 16,
        "./connection_pool": 17,
        "./connectors": 19,
        "./errors": 22,
        "./host": 23,
        "./log": 24,
        "./logger": 25,
        "./loggers": 26,
        "./nodes_to_host": 28,
        "./selectors": 29,
        "./serializers": 33,
        "./transport": 35,
        "./utils": 38
    }],
    15: [function (require, module, exports) {
        function makeFactoryWithModifier(modifier) {
            modifier = modifier || _.identity;
            var factory = function (spec) {
                function action(params, cb) {
                    "function" == typeof params ? (cb = params, params = {}) : (params = params || {}, cb = "function" == typeof cb ? cb : null);
                    try {
                        return exec(this.transport, spec, _.clone(params), cb)
                    } catch (e) {
                        if ("function" != typeof cb) {
                            var def = this.transport.defer();
                            return def.reject(e), def.promise
                        }
                        _.nextTick(cb, e)
                    }
                }

                return spec = modifier(spec), _.isPlainObject(spec.params) || (spec.params = {}), spec.method || (spec.method = "GET"), action.spec = spec, action
            };
            return factory.proxy = function (fn, spec) {
                return function (params, cb) {
                    return "function" == typeof params ? (cb = params, params = {}) : (params = params || {}, cb = "function" == typeof cb ? cb : null), spec.transform && spec.transform(params), fn.call(this, params, cb)
                }
            }, factory
        }

        function resolveUrl(url, params) {
            var i, key, vars = {};
            if (url.req)for (url.reqParamKeys || (url.reqParamKeys = _.keys(url.req)), i = 0; i < url.reqParamKeys.length; i++) {
                if (key = url.reqParamKeys[i], !params.hasOwnProperty(key) || null == params[key])return !1;
                castType[url.req[key].type] ? vars[key] = castType[url.req[key].type](url.req[key], params[key], key) : vars[key] = params[key]
            }
            if (url.opt)for (url.optParamKeys || (url.optParamKeys = _.keys(url.opt)), i = 0; i < url.optParamKeys.length; i++)key = url.optParamKeys[i], params[key] ? castType[url.opt[key].type] || null == params[key] ? vars[key] = castType[url.opt[key].type](url.opt[key], params[key], key) : vars[key] = params[key] : vars[key] = url.opt[key]["default"];
            return url.template || (url.template = _.template(url.fmt)), url.template(_.transform(vars, function (note, val, name) {
                note[name] = encodeURIComponent(val), delete params[name]
            }, {}))
        }

        function exec(transport, spec, params, cb) {
            var i, request = {method: spec.method}, query = {};
            if (spec.requestTimeout && (request.requestTimeout = spec.requestTimeout), !params.body && spec.paramAsBody && (params.body = params[spec.paramAsBody], delete params[spec.paramAsBody]), spec.needsBody && !params.body)throw new TypeError("A request body is required.");
            if (spec.bulkBody && (request.bulkBody = !0), "HEAD" === spec.method && (request.castExists = !0), spec.url)request.path = resolveUrl(spec.url, params); else for (i = 0; i < spec.urls.length && !(request.path = resolveUrl(spec.urls[i], params)); i++);
            if (!request.path) {
                var minUrl = spec.url || spec.urls[spec.urls.length - 1];
                throw new TypeError("Unable to build a path with those params. Supply at least " + _.keys(minUrl.req).join(", "))
            }
            spec.paramKeys || (spec.paramKeys = _.keys(spec.params), spec.requireParamKeys = _.transform(spec.params, function (req, param, key) {
                param.required && req.push(key)
            }, []));
            for (var key in params)if (params.hasOwnProperty(key) && null != params[key])switch (key) {
                case"body":
                case"headers":
                case"requestTimeout":
                case"maxRetries":
                    request[key] = params[key];
                    break;
                case"ignore":
                    request.ignore = _.isArray(params[key]) ? params[key] : [params[key]];
                    break;
                case"method":
                    request.method = _.toUpperString(params[key]);
                    break;
                default:
                    var paramSpec = spec.params[key];
                    paramSpec ? (paramSpec.name = paramSpec.name || key, null != params[key] && (castType[paramSpec.type] ? query[paramSpec.name] = castType[paramSpec.type](paramSpec, params[key], key) : query[paramSpec.name] = params[key], paramSpec["default"] && query[paramSpec.name] === paramSpec["default"] && delete query[paramSpec.name])) : query[key] = params[key]
            }
            for (i = 0; i < spec.requireParamKeys.length; i++)if (!query.hasOwnProperty(spec.requireParamKeys[i]))throw new TypeError("Missing required parameter " + spec.requireParamKeys[i]);
            return request.query = query, transport.request(request, cb)
        }

        function commaSepList(str) {
            return str.split(",").map(function (i) {
                return i.trim()
            })
        }

        var _ = require("./utils");
        exports.makeFactoryWithModifier = makeFactoryWithModifier, exports.factory = makeFactoryWithModifier(), exports.proxyFactory = exports.factory.proxy, exports._resolveUrl = resolveUrl, exports.ApiNamespace = function () {
        }, exports.namespaceFactory = function () {
            function ClientNamespace(transport) {
                this.transport = transport
            }

            return ClientNamespace.prototype = new exports.ApiNamespace, ClientNamespace
        };
        var castType = {
            "enum": function validSelection(param, val, name) {
                if (_.isString(val) && val.indexOf(",") > -1 && (val = commaSepList(val)), _.isArray(val))return val.map(function (v) {
                    return validSelection(param, v, name)
                }).join(",");
                for (var i = 0; i < param.options.length; i++)if (param.options[i] == val)return param.options[i];
                throw new TypeError("Invalid " + name + ": expected " + (param.options.length > 1 ? "one of " + param.options.join(",") : param.options[0]))
            }, duration: function (param, val, name) {
                if (_.isNumeric(val) || _.isInterval(val))return val;
                throw new TypeError("Invalid " + name + ": expected a number or interval (an integer followed by one of M, w, d, h, m, s, y or ms).")
            }, list: function (param, val, name) {
                switch (typeof val) {
                    case"number":
                    case"boolean":
                        return "" + val;
                    case"string":
                        val = commaSepList(val);
                    case"object":
                        if (_.isArray(val))return val.join(",");
                    default:
                        throw new TypeError("Invalid " + name + ": expected be a comma separated list, array, number or string.")
                }
            }, "boolean": function (param, val) {
                return val = _.isString(val) ? val.toLowerCase() : val, "no" === val || "off" === val ? !1 : !!val
            }, number: function (param, val, name) {
                if (_.isNumeric(val))return 1 * val;
                throw new TypeError("Invalid " + name + ": expected a number.")
            }, string: function (param, val, name) {
                switch (typeof val) {
                    case"number":
                    case"string":
                        return "" + val;
                    default:
                        throw new TypeError("Invalid " + name + ": expected a string.")
                }
            }, time: function (param, val, name) {
                if ("string" == typeof val)return val;
                if (_.isNumeric(val))return "" + val;
                if (val instanceof Date)return "" + val.getTime();
                throw new TypeError("Invalid " + name + ": expected some sort of time.")
            }
        }
    }, {"./utils": 38}],
    16: [function (require, module, exports) {
        function ConnectionAbstract(host, config) {
            if (config = config || {}, EventEmitter.call(this), this.log = config.log || new Log, this.pingTimeout = config.pingTimeout || 3e3, !host)throw new TypeError("Missing host");
            if (!(host instanceof Host))throw new TypeError("Invalid host");
            this.host = host, _.makeBoundMethods(this)
        }

        module.exports = ConnectionAbstract;
        var _ = require("./utils"), EventEmitter = require("events").EventEmitter, Log = require("./log"), Host = require("./host"), errors = require("./errors");
        _.inherits(ConnectionAbstract, EventEmitter), ConnectionAbstract.prototype.request = function () {
            throw new Error("Connection#request must be overwritten by the Connector")
        }, ConnectionAbstract.prototype.ping = function (params, cb) {
            "function" == typeof params ? (cb = params, params = null) : cb = "function" == typeof cb ? cb : null;
            var requestTimeoutId, aborted, abort, requestTimeout = this.pingTimeout;
            params && params.hasOwnProperty("requestTimeout") && (requestTimeout = params.requestTimeout), abort = this.request(_.defaults(params || {}, {
                path: "/",
                method: "HEAD"
            }), function (err) {
                aborted || (clearTimeout(requestTimeoutId), cb && cb(err))
            }), requestTimeout && (requestTimeoutId = setTimeout(function () {
                abort && abort(), aborted = !0, cb && cb(new errors.RequestTimeout("Ping Timeout after " + requestTimeout + "ms"))
            }, requestTimeout))
        }, ConnectionAbstract.prototype.setStatus = function (status) {
            var origStatus = this.status;
            this.status = status, this.emit("status set", status, origStatus, this), "closed" === status && this.removeAllListeners()
        }
    }, {"./errors": 22, "./host": 23, "./log": 24, "./utils": 38, events: 39}],
    17: [function (require, module, exports) {
        (function (process) {
            function ConnectionPool(config) {
                config = config || {}, _.makeBoundMethods(this), config.log ? this.log = config.log : (this.log = new Log, config.log = this.log), this._config = config, this.selector = _.funcEnum(config, "selector", ConnectionPool.selectors, ConnectionPool.defaultSelector), this.Connection = _.funcEnum(config, "connectionClass", ConnectionPool.connectionClasses, ConnectionPool.defaultConnectionClass), this.deadTimeout = config.hasOwnProperty("deadTimeout") ? config.deadTimeout : 6e4, this.maxDeadTimeout = config.hasOwnProperty("maxDeadTimeout") ? config.maxDeadTimeout : 18e5, this.calcDeadTimeout = _.funcEnum(config, "calcDeadTimeout", ConnectionPool.calcDeadTimeoutOptions, "exponential"), this.index = {}, this._conns = {
                    alive: [],
                    dead: []
                }, this._timeouts = []
            }

            module.exports = ConnectionPool;
            var _ = require("./utils"), Log = require("./log");
            ConnectionPool.selectors = require("./selectors"), ConnectionPool.defaultSelector = "roundRobin", ConnectionPool.connectionClasses = require("./connectors"), ConnectionPool.defaultConnectionClass = ConnectionPool.connectionClasses._default, delete ConnectionPool.connectionClasses._default, ConnectionPool.calcDeadTimeoutOptions = {
                flat: function (attempt, baseTimeout) {
                    return baseTimeout
                }, exponential: function (attempt, baseTimeout) {
                    return Math.min(2 * baseTimeout * Math.pow(2, .5 * attempt - 1), this.maxDeadTimeout)
                }
            }, ConnectionPool.prototype.select = function (cb) {
                if (this._conns.alive.length)if (this.selector.length > 1)this.selector(this._conns.alive, cb); else try {
                    _.nextTick(cb, void 0, this.selector(this._conns.alive))
                } catch (e) {
                    cb(e)
                } else this._timeouts.length ? this._selectDeadConnection(cb) : _.nextTick(cb, void 0)
            }, ConnectionPool.prototype.onStatusSet = _.handler(function (status, oldStatus, connection) {
                var index, died = "dead" === status, wasAlreadyDead = died && "dead" === oldStatus, revived = !died && "dead" === oldStatus, noChange = oldStatus === status, from = this._conns[oldStatus], to = this._conns[status];
                return noChange && !died ? !0 : (from !== to && (_.isArray(from) && (index = from.indexOf(connection), -1 !== index && from.splice(index, 1)), _.isArray(to) && (index = to.indexOf(connection), -1 === index && to.push(connection))), died && this._onConnectionDied(connection, wasAlreadyDead), void(revived && this._onConnectionRevived(connection)))
            }), ConnectionPool.prototype._onConnectionRevived = function (connection) {
                for (var timeout, i = 0; i < this._timeouts.length; i++)if (this._timeouts[i].conn === connection) {
                    timeout = this._timeouts[i], timeout.id && clearTimeout(timeout.id), this._timeouts.splice(i, 1);
                    break
                }
            }, ConnectionPool.prototype._onConnectionDied = function (connection, alreadyWasDead) {
                var timeout;
                if (alreadyWasDead) {
                    for (var i = 0; i < this._timeouts.length; i++)if (this._timeouts[i].conn === connection) {
                        timeout = this._timeouts[i];
                        break
                    }
                } else timeout = {
                    conn: connection, attempt: 0, revive: function (cb) {
                        timeout.attempt++, connection.ping(function (err) {
                            connection.setStatus(err ? "dead" : "alive"), cb && "function" == typeof cb && cb(err)
                        })
                    }
                }, this._timeouts.push(timeout);
                timeout.id && clearTimeout(timeout.id);
                var ms = this.calcDeadTimeout(timeout.attempt, this.deadTimeout);
                timeout.id = setTimeout(timeout.revive, ms), timeout.runAt = _.now() + ms
            }, ConnectionPool.prototype._selectDeadConnection = function (cb) {
                var orderedTimeouts = _.sortBy(this._timeouts, "runAt"), log = this.log;
                process.nextTick(function next() {
                    var timeout = orderedTimeouts.shift();
                    return timeout ? timeout.conn ? void("dead" === timeout.conn.status ? timeout.revive(function (err) {
                        err ? (log.warning("Unable to revive connection: " + timeout.conn.id), process.nextTick(next)) : cb(void 0, timeout.conn)
                    }) : cb(void 0, timeout.conn)) : void next() : void cb(void 0)
                })
            }, ConnectionPool.prototype.getConnections = function (status, limit) {
                var list;
                return list = status ? this._conns[status] : this._conns[this._conns.alive.length ? "alive" : "dead"], null == limit ? list.slice(0) : _.shuffle(list).slice(0, limit)
            }, ConnectionPool.prototype.addConnection = function (connection) {
                connection.id || (connection.id = connection.host.toString()), this.index[connection.id] || (this.log.info("Adding connection to", connection.id), this.index[connection.id] = connection, connection.on("status set", this.bound.onStatusSet), connection.setStatus("alive"))
            }, ConnectionPool.prototype.removeConnection = function (connection) {
                connection.id || (connection.id = connection.host.toString()), this.index[connection.id] && (delete this.index[connection.id], connection.setStatus("closed"), connection.removeListener("status set", this.bound.onStatusSet))
            }, ConnectionPool.prototype.setHosts = function (hosts) {
                var connection, i, id, host, toRemove = _.clone(this.index);
                for (i = 0; i < hosts.length; i++)host = hosts[i], id = host.toString(), this.index[id] ? delete toRemove[id] : (connection = new this.Connection(host, this._config), connection.id = id, this.addConnection(connection));
                var removeIds = _.keys(toRemove);
                for (i = 0; i < removeIds.length; i++)this.removeConnection(this.index[removeIds[i]])
            }, ConnectionPool.prototype.getAllHosts = function () {
                return _.values(this.index).map(function (connection) {
                    return connection.host
                })
            }, ConnectionPool.prototype.close = function () {
                this.setHosts([])
            }, ConnectionPool.prototype.empty = ConnectionPool.prototype.close
        }).call(this, require("_process"))
    }, {"./connectors": 19, "./log": 24, "./selectors": 29, "./utils": 38, _process: 48}],
    18: [function (require, module, exports) {
        function AngularConnector(host, config) {
            ConnectionAbstract.call(this, host, config);
            var self = this;
            config.$injector.invoke(["$http", "$q", function ($http, $q) {
                self.$q = $q, self.$http = $http
            }])
        }

        module.exports = AngularConnector;
        var _ = require("../utils"), ConnectionAbstract = require("../connection"), ConnectionFault = require("../errors").ConnectionFault;
        _.inherits(AngularConnector, ConnectionAbstract), AngularConnector.prototype.request = function (params, cb) {
            var abort = this.$q.defer();
            return this.$http({
                method: params.method,
                url: this.host.makeUrl(params),
                data: params.body,
                cache: !1,
                headers: this.host.getHeaders(params.headers),
                transformRequest: [],
                transformResponse: [],
                timeout: abort.promise
            }).then(function (response) {
                cb(null, response.data, response.status, response.headers())
            }, function (err) {
                err.status ? cb(null, err.data, err.status, err.headers()) : cb(new ConnectionFault(err.message))
            }), function () {
                abort.resolve()
            }
        }
    }, {"../connection": 16, "../errors": 22, "../utils": 38}],
    19: [function (require, module, exports) {
        var opts = {
            xhr: require("./xhr"),
            jquery: require("./jquery"),
            angular: require("./angular")
        }, _ = require("../utils");
        _.each(opts, function (conn, name) {
            "function" != typeof conn && delete opts[name]
        }), opts.xhr ? opts._default = "xhr" : opts.angular ? opts._default = "angular" : opts._default = "jquery", module.exports = opts
    }, {"../utils": 38, "./angular": 18, "./jquery": 20, "./xhr": 21}],
    20: [function (require, module, exports) {
        function JqueryConnector(host, config) {
            ConnectionAbstract.call(this, host, config)
        }

        module.exports = JqueryConnector;
        var _ = require("../utils"), ConnectionAbstract = require("../connection"), ConnectionFault = require("../errors").ConnectionFault;
        _.inherits(JqueryConnector, ConnectionAbstract), JqueryConnector.prototype.request = function (params, cb) {
            var ajax = {
                url: this.host.makeUrl(params),
                data: params.body,
                type: params.method,
                dataType: "text",
                headers: this.host.getHeaders(params.headers),
                done: cb
            }, jqXHR = jQuery.ajax(ajax).done(function (data, textStatus, jqXHR) {
                cb(null, data, jqXHR.statusCode(), {"content-type": jqXHR.getResponseHeader("content-type")})
            }).fail(function (jqXHR, textStatus, err) {
                cb(new ConnectionFault(err && err.message))
            });
            return function () {
                jqXHR.abort()
            }
        }
    }, {"../connection": 16, "../errors": 22, "../utils": 38}],
    21: [function (require, module, exports) {
        function XhrConnector(host, config) {
            ConnectionAbstract.call(this, host, config)
        }

        module.exports = XhrConnector;
        var _ = require("../utils"), ConnectionAbstract = require("../connection"), ConnectionFault = require("../errors").ConnectionFault, asyncDefault = !(navigator && /PhantomJS/i.test(navigator.userAgent));
        _.inherits(XhrConnector, ConnectionAbstract);
        var getXhr = _.noop;
        if (getXhr = "undefined" != typeof XMLHttpRequest ? function () {
                return new XMLHttpRequest
            } : _(["Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0"]).map(function (appName) {
                try {
                    new window.ActiveXObject(appName);
                    return function () {
                        return new window.ActiveXObject(appName)
                    }
                } catch (e) {
                    return !1
                }
            }).compact().first(), !getXhr)throw new Error("getXhr(): XMLHttpRequest not available");
        XhrConnector.prototype.request = function (params, cb) {
            var timeoutId, xhr = getXhr(), host = this.host, log = this.log, url = host.makeUrl(params), headers = host.getHeaders(params.headers), async = params.async === !1 ? !1 : asyncDefault;
            if (xhr.open(params.method || "GET", url, async), headers)for (var key in headers)void 0 !== headers[key] && xhr.setRequestHeader(key, headers[key]);
            return xhr.onreadystatechange = function () {
                if (4 === xhr.readyState) {
                    clearTimeout(timeoutId), log.trace(params.method, url, params.body, xhr.responseText, xhr.status);
                    var err = xhr.status ? void 0 : new ConnectionFault(xhr.statusText || "Request failed to complete.");
                    cb(err, xhr.responseText, xhr.status)
                }
            }, xhr.send(params.body || void 0), function () {
                xhr.abort()
            }
        }
    }, {"../connection": 16, "../errors": 22, "../utils": 38}],
    22: [function (require, module, exports) {
        function ErrorAbstract(msg, constructor, metadata) {
            this.message = msg, Error.call(this, this.message), canCapture ? Error.captureStackTrace(this, constructor) : canStack ? this.stack = (new Error).stack : this.stack = "", metadata && (_.assign(this, metadata), this.toString = function () {
                return msg + " :: " + JSON.stringify(metadata)
            }, this.toJSON = function () {
                return _.assign({msg: msg}, metadata)
            })
        }

        var _ = require("./utils"), qs = require("querystring"), errors = module.exports, canCapture = "function" == typeof Error.captureStackTrace, canStack = !!(new Error).stack;
        errors._Abstract = ErrorAbstract, _.inherits(ErrorAbstract, Error), errors.ConnectionFault = function (msg) {
            ErrorAbstract.call(this, msg || "Connection Failure", errors.ConnectionFault)
        }, _.inherits(errors.ConnectionFault, ErrorAbstract), errors.NoConnections = function (msg) {
            ErrorAbstract.call(this, msg || "No Living connections", errors.NoConnections)
        }, _.inherits(errors.NoConnections, ErrorAbstract), errors.Generic = function (msg, metadata) {
            ErrorAbstract.call(this, msg || "Generic Error", errors.Generic, metadata)
        }, _.inherits(errors.Generic, ErrorAbstract), errors.RequestTimeout = function (msg) {
            ErrorAbstract.call(this, msg || "Request Timeout", errors.RequestTimeout)
        }, _.inherits(errors.RequestTimeout, ErrorAbstract), errors.Serialization = function (msg) {
            ErrorAbstract.call(this, msg || "Unable to parse/serialize body", errors.Serialization)
        }, _.inherits(errors.Serialization, ErrorAbstract), errors.RequestTypeError = function (feature) {
            ErrorAbstract.call(this, "Cross-domain AJAX requests " + feature + " are not supported", errors.RequestTypeError)
        }, _.inherits(errors.RequestTypeError, ErrorAbstract);
        var statusCodes = [[300, "Multiple Choices"], [301, "Moved Permanently"], [302, "Found"], [303, "See Other"], [304, "Not Modified"], [305, "Use Proxy"], [307, "Temporary Redirect"], [308, "Permanent Redirect"], [400, "Bad Request"], [401, "Authentication Exception"], [402, "Payment Required"], [403, ["Authorization Exception", "Forbidden"]], [404, "Not Found"], [405, "Method Not Allowed"], [406, "Not Acceptable"], [407, "Proxy Authentication Required"], [408, "Request Timeout"], [409, "Conflict"], [410, "Gone"], [411, "Length Required"], [412, "Precondition Failed"], [413, "Request Entity Too Large"], [414, "Request URIToo Long"], [415, "Unsupported Media Type"], [416, "Requested Range Not Satisfiable"], [417, "Expectation Failed"], [418, "Im ATeapot"], [421, "Too Many Connections From This IP"], [426, "Upgrade Required"], [429, "Too Many Requests"], [450, "Blocked By Windows Parental Controls"], [494, "Request Header Too Large"], [497, "HTTPTo HTTPS"], [499, "Client Closed Request"], [500, "Internal Server Error"], [501, "Not Implemented"], [502, "Bad Gateway"], [503, "Service Unavailable"], [504, "Gateway Timeout"], [505, "HTTPVersion Not Supported"], [506, "Variant Also Negotiates"], [510, "Not Extended"]];
        _.each(statusCodes, function (tuple) {
            function StatusCodeError(msg, metadata) {
                this.status = status, this.displayName = className;
                var esErrObject = null;
                return _.isPlainObject(msg) && (esErrObject = msg, msg = null), esErrObject ? (msg = [].concat(esErrObject.root_cause || []).reduce(function (memo, cause) {
                    memo && (memo += " (and) "), memo += "[" + cause.type + "] " + cause.reason;
                    var extraData = _.omit(cause, ["type", "reason"]);
                    return _.size(extraData) && (memo += ", with { " + qs.stringify(extraData, " ", "=", {
                            encodeURIComponent: function (v) {
                                return String(v).split("\n").join("\\n")
                            }
                        }) + " }"), memo
                }, ""), msg || (esErrObject.type && (msg += "[" + esErrObject.type + "] "), esErrObject.reason && (msg += esErrObject.reason)), ErrorAbstract.call(this, msg || primaryName, StatusCodeError, metadata), this) : (ErrorAbstract.call(this, msg || primaryName, StatusCodeError), this)
            }

            var status = tuple[0], names = tuple[1], allNames = [].concat(names, status), primaryName = allNames[0], className = _.studlyCase(primaryName);
            allNames = _.uniq(allNames.concat(className)), _.inherits(StatusCodeError, ErrorAbstract), allNames.forEach(function (name) {
                errors[name] = StatusCodeError
            })
        })
    }, {"./utils": 38, querystring: 54}],
    23: [function (require, module, exports) {
        (function (Buffer) {
            function Host(config, globalConfig) {
                if (config = _.clone(config || {}), globalConfig = globalConfig || {}, this.protocol = "http", this.host = "localhost", this.path = "", this.port = 9200, this.query = null, this.headers = null, this.suggestCompression = !!globalConfig.suggestCompression, this.ssl = _.defaults({}, config.ssl || {}, globalConfig.ssl || {}, sslDefaults), "string" == typeof config) {
                    var firstColon = config.indexOf(":"), firstSlash = config.indexOf("/"), noSlash = -1 === firstSlash, portNoPath = firstColon > -1 && noSlash, portWithPath = !portNoPath && firstSlash > firstColon;
                    if ((noSlash || portNoPath || portWithPath) && !startsWithProtocolRE.test(config) && (config = defaultProto + "//" + config), config = _.pick(url.parse(config, !1, !0), urlParseFields), !config.port) {
                        var proto = config.protocol || "http";
                        ":" === proto.charAt(proto.length - 1) && (proto = proto.substring(0, proto.length - 1)), Host.defaultPorts[proto] && (config.port = Host.defaultPorts[proto])
                    }
                }
                _.isObject(config) ? _.each(simplify, function (to) {
                    var from = to + "name";
                    config[from] && config[to] ? 0 === config[to].indexOf(config[from]) && (config[to] = config[from]) : config[from] && (config[to] = config[from]), delete config[from]
                }) : config = {}, config.auth && (config.headers = config.headers || {}, config.headers.Authorization = "Basic " + btoa(config.auth), delete config.auth), _.forOwn(config, function (val, prop) {
                    null != val && (this[prop] = _.clone(val))
                }, this), null === this.query ? this.query = {} : _.isPlainObject(this.query) || (this.query = qs.parse(this.query)), _.isNumeric(this.port) ? this.port = parseInt(this.port, 10) : this.port = 9200, "/" === this.path ? this.path = "" : this.path && "/" !== this.path.charAt(0) && (this.path = "/" + (this.path || "")), ":" === this.protocol.substr(-1) && (this.protocol = this.protocol.substring(0, this.protocol.length - 1))
            }

            function objectPropertyGetter(prop, preOverride) {
                return function (overrides) {
                    preOverride && (overrides = preOverride.call(this, overrides));
                    var obj = this[prop];
                    return obj || overrides ? (overrides && (obj = _.assign({}, obj, overrides)), _.size(obj) ? obj : null) : null
                }
            }

            module.exports = Host;
            var btoa, url = require("url"), qs = require("querystring"), _ = require("./utils"), startsWithProtocolRE = /^([a-z]+:)?\/\//, defaultProto = "http:";
            "undefined" != typeof window && "undefined" != typeof window.location && (defaultProto = window.location.protocol, btoa = window.btoa), btoa = btoa || function (data) {
                    return new Buffer(data, "utf8").toString("base64")
                };
            var urlParseFields = ["protocol", "hostname", "pathname", "port", "auth", "query"], simplify = ["host", "path"], sslDefaults = {
                pfx: null,
                key: null,
                passphrase: null,
                cert: null,
                ca: null,
                ciphers: null,
                rejectUnauthorized: !1,
                secureProtocol: null
            };
            Host.defaultPorts = {http: 80, https: 443}, Host.prototype.makeUrl = function (params) {
                params = params || {};
                var port = "";
                this.port !== Host.defaultPorts[this.protocol] && (port = ":" + this.port);
                var path = "" + (this.path || "") + (params.path || "");
                "/" !== path.charAt(0) && (path = "/" + path);
                var query = qs.stringify(this.getQuery(params.query));
                return this.host ? this.protocol + "://" + this.host + port + path + (query ? "?" + query : "") : path + (query ? "?" + query : "")
            }, Host.prototype.getHeaders = objectPropertyGetter("headers", function (overrides) {
                return this.suggestCompression ? _.defaults(overrides || {}, {"Accept-Encoding": "gzip,deflate"}) : overrides
            }), Host.prototype.getQuery = objectPropertyGetter("query", function (query) {
                return "string" == typeof query ? qs.parse(query) : query
            }), Host.prototype.toString = function () {
                return this.makeUrl()
            }
        }).call(this, require("buffer").Buffer)
    }, {"./utils": 38, buffer: 3, querystring: 54, url: 55}],
    24: [function (require, module, exports) {
        (function (process) {
            function Log(config) {
                if (config = config || {}, config.log) {
                    var i, outputs;
                    if (outputs = _.isArrayOfStrings(config.log) ? [{levels: config.log}] : _.createArray(config.log, function (val) {
                            return _.isPlainObject(val) ? val : "string" == typeof val ? {level: val} : void 0
                        }), !outputs)throw new TypeError("Invalid logging output config. Expected either a log level, array of log levels, a logger config object, or an array of logger config objects.");
                    for (i = 0; i < outputs.length; i++)this.addOutput(outputs[i])
                }
            }

            var _ = require("./utils"), url = require("url"), EventEmitter = require("events").EventEmitter;
            _.inherits(Log, EventEmitter), Log.loggers = require("./loggers"), Log.prototype.close = function () {
                this.emit("closing"), this.listenerCount() && (console.error("Something is still listening for log events, but the logger is closing."), this.clearAllListeners())
            }, EventEmitter.prototype.listenerCount ? Log.prototype.listenerCount = EventEmitter.prototype.listenerCount : EventEmitter.listenerCount ? Log.prototype.listenerCount = function (event) {
                return EventEmitter.listenerCount(this, event)
            } : Log.prototype.listenerCount = function (event) {
                return this.listeners(event).length
            }, Log.levels = ["error", "warning", "info", "debug", "trace"], Log.parseLevels = function (input) {
                switch (typeof input) {
                    case"string":
                        var i = _.indexOf(Log.levels, input);
                        if (i >= 0)return Log.levels.slice(0, i + 1);
                    case"object":
                        if (_.isArray(input)) {
                            var valid = _.intersection(input, Log.levels);
                            if (valid.length === input.length)return valid
                        }
                    default:
                        throw new TypeError("invalid logging level " + input + ". Expected zero or more of these options: " + Log.levels.join(", "))
                }
            }, Log.join = function (arrayish) {
                return _.map(arrayish, function (item) {
                    return _.isPlainObject(item) ? _.inspect(item) + "\n" : item.toString()
                }).join(" ")
            }, Log.prototype.addOutput = function (config) {
                config = config || {}, config.levels = Log.parseLevels(config.levels || config.level || "warning"), delete config.level;
                var Logger = _.funcEnum(config, "type", Log.loggers, process.browser ? "console" : "stdio");
                return new Logger(this, config)
            }, Log.prototype.error = function (e) {
                return this.listenerCount("error") ? this.emit("error", e instanceof Error ? e : new Error(e)) : void 0
            }, Log.prototype.warning = function () {
                return this.listenerCount("warning") ? this.emit("warning", Log.join(arguments)) : void 0
            }, Log.prototype.info = function () {
                return this.listenerCount("info") ? this.emit("info", Log.join(arguments)) : void 0
            }, Log.prototype.debug = function () {
                return this.listenerCount("debug") ? this.emit("debug", Log.join(arguments)) : void 0
            }, Log.prototype.trace = function (method, requestUrl, body, responseBody, responseStatus) {
                return this.listenerCount("trace") ? this.emit("trace", Log.normalizeTraceArgs(method, requestUrl, body, responseBody, responseStatus)) : void 0
            }, Log.normalizeTraceArgs = function (method, requestUrl, body, responseBody, responseStatus) {
                return "string" == typeof requestUrl ? requestUrl = url.parse(requestUrl, !0, !0) : (requestUrl = _.clone(requestUrl), requestUrl.path && (requestUrl.query = url.parse(requestUrl.path, !0, !1).query), !requestUrl.pathname && requestUrl.path && (requestUrl.pathname = requestUrl.path.split("?").shift())), delete requestUrl.auth, {
                    method: method,
                    url: url.format(requestUrl),
                    body: body,
                    status: responseStatus,
                    response: responseBody
                }
            }, module.exports = Log
        }).call(this, require("_process"))
    }, {"./loggers": 26, "./utils": 38, _process: 48, events: 39, url: 55}],
    25: [function (require, module, exports) {
        function LoggerAbstract(log, config) {
            this.log = log, this.listeningLevels = [], _.makeBoundMethods(this), this.log.once("closing", this.bound.cleanUpListeners), this.setupListeners(config.levels)
        }

        function padNumToTen(n) {
            return 10 > n ? "0" + n.toString(10) : n.toString(10)
        }

        function indent(text, spaces) {
            var space = _.repeat(" ", spaces || 2);
            return (text || "").split(/\r?\n/).map(function (line) {
                return space + line
            }).join("\n")
        }

        var _ = require("./utils");
        LoggerAbstract.prototype.timestamp = function () {
            var d = new Date;
            return d.getUTCFullYear() + "-" + padNumToTen(d.getUTCMonth() + 1) + "-" + padNumToTen(d.getUTCDate()) + "T" + padNumToTen(d.getUTCHours()) + ":" + padNumToTen(d.getUTCMinutes()) + ":" + padNumToTen(d.getUTCSeconds()) + "Z"
        }, LoggerAbstract.prototype.format = function (label, message) {
            return label + ": " + this.timestamp() + "\n" + indent(message) + "\n\n"
        }, LoggerAbstract.prototype.write = function () {
            throw new Error("This should be overwritten by the logger")
        }, LoggerAbstract.prototype.setupListeners = function (levels) {
            this.cleanUpListeners(), this.listeningLevels = [], _.each(levels, function (level) {
                var fnName = "on" + _.ucfirst(level);
                if (!this.bound[fnName])throw new Error('Unable to listen for level "' + level + '"');
                this.listeningLevels.push(level), this.log.on(level, this.bound[fnName])
            }, this)
        }, LoggerAbstract.prototype.cleanUpListeners = _.handler(function () {
            _.each(this.listeningLevels, function (level) {
                this.log.removeListener(level, this.bound["on" + _.ucfirst(level)])
            }, this)
        }), LoggerAbstract.prototype.onError = _.handler(function (e) {
            this.write("Error" === e.name ? "ERROR" : e.name, e.stack)
        }), LoggerAbstract.prototype.onWarning = _.handler(function (msg) {
            this.write("WARNING", msg)
        }), LoggerAbstract.prototype.onInfo = _.handler(function (msg) {
            this.write("INFO", msg)
        }), LoggerAbstract.prototype.onDebug = _.handler(function (msg) {
            this.write("DEBUG", msg)
        }), LoggerAbstract.prototype.onTrace = _.handler(function (requestDetails) {
            this.write("TRACE", this._formatTraceMessage(requestDetails))
        }), LoggerAbstract.prototype._formatTraceMessage = function (req) {
            return "-> " + req.method + " " + req.url + "\n" + this._prettyJson(req.body) + "\n<- " + req.status + "\n" + this._prettyJson(req.response)
        }, LoggerAbstract.prototype._prettyJson = function (body) {
            try {
                return "string" == typeof body && (body = JSON.parse(body)), JSON.stringify(body, null, "  ").replace(/'/g, "\\u0027")
            } catch (e) {
                return "string" == typeof body ? body : ""
            }
        }, module.exports = LoggerAbstract
    }, {"./utils": 38}],
    26: [function (require, module, exports) {
        module.exports = {console: require("./console")}
    }, {"./console": 27}],
    27: [function (require, module, exports) {
        function Console(log, config) {
            LoggerAbstract.call(this, log, config), this.color = _.has(config, "color") ? !!config.color : !0
        }

        module.exports = Console;
        var LoggerAbstract = require("../logger"), _ = require("../utils");
        _.inherits(Console, LoggerAbstract), Console.prototype.setupListeners = function (levels) {
            LoggerAbstract.prototype.setupListeners.call(this, levels)
        }, Console.prototype.write = function (label, message, to) {
            console[to] && console[to](this.format(label, message))
        }, Console.prototype.onError = _.handler(function (e) {
            var to = console.error ? "error" : "log";
            this.write("Error" === e.name ? "ERROR" : e.name, e.stack || e.message, to)
        }), Console.prototype.onWarning = _.handler(function (msg) {
            this.write("WARNING", msg, console.warn ? "warn" : "log")
        }), Console.prototype.onInfo = _.handler(function (msg) {
            this.write("INFO", msg, console.info ? "info" : "log")
        }), Console.prototype.onDebug = _.handler(function (msg) {
            this.write("DEBUG", msg, console.debug ? "debug" : "log")
        }), Console.prototype.onTrace = _.handler(function (msg) {
            this.write("TRACE", this._formatTraceMessage(msg), "log")
        })
    }, {"../logger": 25, "../utils": 38}],
    28: [function (require, module, exports) {
        function makeNodeParser(hostProp) {
            return function (nodes) {
                return _.transform(nodes, function (hosts, node, id) {
                    var address = node[hostProp];
                    if (address) {
                        var host = {
                            host: void 0,
                            port: void 0,
                            _meta: {id: id, name: node.name, hostname: node.hostname, version: node.version}
                        }, malformedError = new Error("Malformed " + hostProp + ". Got " + JSON.stringify(node[hostProp]) + ' and expected it to match "{hostname?}/{ip}:{port}".'), matches1x = extractHostPartsRE1x.exec(address);
                        if (matches1x)return host.host = matches1x[1], host.port = parseInt(matches1x[2], 10), void hosts.push(host);
                        if (address.indexOf("/") > -1) {
                            var withHostParts = address.split("/");
                            if (2 !== withHostParts.length)throw malformedError;
                            host.host = withHostParts.shift(), address = withHostParts.shift()
                        }
                        if (address.indexOf(":") < 0)throw malformedError;
                        var addressParts = address.split(":");
                        if (2 !== addressParts.length)throw malformedError;
                        host.host = host.host || addressParts[0], host.port = parseInt(addressParts[1], 10), hosts.push(host)
                    }
                }, [])
            }
        }

        var _ = require("./utils"), extractHostPartsRE1x = /\[\/*([^:]+):(\d+)\]/;
        module.exports = makeNodeParser("http_address"), module.exports.thrift = makeNodeParser("transport_address")
    }, {"./utils": 38}],
    29: [function (require, module, exports) {
        module.exports = {random: require("./random"), roundRobin: require("./round_robin")}
    }, {"./random": 30, "./round_robin": 31}],
    30: [function (require, module, exports) {
        module.exports = function (connections) {
            return connections[Math.floor(Math.random() * connections.length)]
        }
    }, {}],
    31: [function (require, module, exports) {
        module.exports = function (connections) {
            var connection = connections[0];
            return connections.push(connections.shift()), connection
        }
    }, {}],
    32: [function (require, module, exports) {
        function AngularSerializer() {
        }

        var _ = require("../utils"), JsonSerializer = require("../serializers/json");
        _.inherits(AngularSerializer, JsonSerializer), AngularSerializer.prototype.encode = function (val) {
            switch (typeof val) {
                case"string":
                    return val;
                case"object":
                    if (val)return angular.toJson(val);
                default:
                    return
            }
        }, module.exports = AngularSerializer
    }, {"../serializers/json": 34, "../utils": 38}],
    33: [function (require, module, exports) {
        module.exports = {angular: require("./angular"), json: require("./json")}
    }, {"./angular": 32, "./json": 34}],
    34: [function (require, module, exports) {
        function Json() {
        }

        module.exports = Json;
        var _ = require("../utils");
        Json.prototype.serialize = function (val, replacer, spaces) {
            switch (typeof val) {
                case"string":
                    return val;
                case"object":
                    if (val)return JSON.stringify(val, replacer, spaces);
                default:
                    return
            }
        }, Json.prototype.serialize.contentType = "application/json", Json.prototype.deserialize = function (str) {
            if ("string" == typeof str)try {
                return JSON.parse(str)
            } catch (e) {
            }
        }, Json.prototype.bulkBody = function (val) {
            var i, body = "";
            if (_.isArray(val))for (i = 0; i < val.length; i++)body += this.serialize(val[i]) + "\n"; else {
                if ("string" != typeof val)throw new TypeError("Bulk body should either be an Array of commands/string, or a String");
                body = val + ("\n" === val[val.length - 1] ? "" : "\n")
            }
            return body
        }, Json.prototype.bulkBody.contentType = "application/x-ldjson"
    }, {"../utils": 38}],
    35: [function (require, module, exports) {
        (function (process) {
            function Transport(config) {
                var self = this;
                config = self._config = config || {};
                var LogClass = "function" == typeof config.log ? config.log : require("./log");
                config.log = self.log = new LogClass(config);
                var ConnectionPool = _.funcEnum(config, "connectionPool", Transport.connectionPools, "main");
                self.connectionPool = new ConnectionPool(config);
                var Serializer = _.funcEnum(config, "serializer", Transport.serializers, "json");
                self.serializer = new Serializer(config), self.nodesToHostCallback = _.funcEnum(config, "nodesToHostCallback", Transport.nodesToHostCallbacks, "main"), self.maxRetries = config.hasOwnProperty("maxRetries") ? config.maxRetries : 3, self.sniffEndpoint = config.hasOwnProperty("sniffEndpoint") ? config.sniffEndpoint : "/_nodes/_all/clear", self.requestTimeout = config.hasOwnProperty("requestTimeout") ? config.requestTimeout : 3e4, config.hasOwnProperty("defer") && (self.defer = config.defer);
                var randomizeHosts = config.hasOwnProperty("randomizeHosts") ? !!config.randomizeHosts : !0;
                if (config.host && (config.hosts = config.host), config.hosts) {
                    var hostsConfig = _.createArray(config.hosts, function (val) {
                        return _.isPlainObject(val) || _.isString(val) || val instanceof Host ? val : void 0
                    });
                    if (!hostsConfig)throw new TypeError("Invalid hosts config. Expected a URL, an array of urls, a host config object, or an array of host config objects.");
                    randomizeHosts && (hostsConfig = _.shuffle(hostsConfig)), self.setHosts(hostsConfig)
                }
                config.hasOwnProperty("sniffedNodesProtocol") ? self.sniffedNodesProtocol = config.sniffedNodesProtocol || null : self.sniffedNodesProtocol = findCommonProtocol(self.connectionPool.getAllHosts()) || null, config.sniffOnStart && self.sniff(), config.sniffInterval && self._timeout(function doSniff() {
                    self.sniff(), self._timeout(doSniff, config.sniffInterval)
                }, config.sniffInterval), config.sniffOnConnectionFault && patchSniffOnConnectionFault(self)
            }

            module.exports = Transport;
            var _ = require("./utils"), errors = require("./errors"), Host = require("./host"), Promise = require("promise/lib/es6-extensions"), patchSniffOnConnectionFault = require("./transport/sniff_on_connection_fault"), findCommonProtocol = require("./transport/find_common_protocol");
            Transport.connectionPools = {main: require("./connection_pool")}, Transport.serializers = require("./serializers"), Transport.nodesToHostCallbacks = {main: require("./nodes_to_host")}, Transport.prototype.defer = function () {
                var defer = {};
                return defer.promise = new Promise(function (resolve, reject) {
                    defer.resolve = resolve, defer.reject = reject
                }), defer
            }, Transport.prototype.request = function (params, cb) {
                function sendReqWithConnection(err, _connection) {
                    aborted || (err ? respond(err) : _connection ? (connection = _connection, requestAborter = connection.request(params.req, checkRespForFailure)) : (self.log.warning("No living connections"), respond(new errors.NoConnections)))
                }

                function checkRespForFailure(err, body, status, headers) {
                    if (!aborted) {
                        if (requestAborter = void 0, err instanceof errors.RequestTypeError)return self.log.error("Connection refused to execute the request", err), void respond(err, body, status, headers);
                        if (err) {
                            connection.setStatus("dead");
                            var errMsg = err.message || "";
                            errMsg = "\n" + params.req.method + " " + connection.host.makeUrl(params.req) + (errMsg.length ? " => " : "") + errMsg, remainingRetries ? (remainingRetries--, self.log.error("Request error, retrying" + errMsg), self.connectionPool.select(sendReqWithConnection)) : (self.log.error("Request complete with error" + errMsg), respond(new errors.ConnectionFault(err)))
                        } else self.log.debug("Request complete"), respond(void 0, body, status, headers)
                    }
                }

                function respond(err, body, status, headers) {
                    if (!aborted) {
                        self._timeout(requestTimeoutId);
                        var parsedBody, isJson = !headers || headers["content-type"] && ~headers["content-type"].indexOf("application/json");
                        if (!err && body && (isJson ? (parsedBody = self.serializer.deserialize(body), null == parsedBody && (err = new errors.Serialization, parsedBody = body)) : parsedBody = body), (!err || err instanceof errors.Serialization) && (200 > status || status >= 300) && (!params.ignore || !_.contains(params.ignore, status))) {
                            var errorMetadata = _.pick(params.req, ["path", "query", "body"]);
                            errorMetadata.statusCode = status, errorMetadata.response = body, 401 === status && headers && headers["www-authenticate"] && (errorMetadata.wwwAuthenticateDirective = headers["www-authenticate"]), err = errors[status] ? new errors[status](parsedBody && parsedBody.error, errorMetadata) : new errors.Generic("unknown error", errorMetadata)
                        }
                        params.castExists && (err && err instanceof errors.NotFound ? (parsedBody = !1, err = void 0) : parsedBody = !err), "function" == typeof cb ? err ? cb(err, parsedBody, status) : cb(void 0, parsedBody, status) : err ? (err.body = parsedBody, err.status = status, defer.reject(err)) : defer.resolve(parsedBody)
                    }
                }

                function abortRequest() {
                    aborted || (aborted = !0, remainingRetries = 0, self._timeout(requestTimeoutId), "function" == typeof requestAborter && requestAborter())
                }

                var connection, requestAborter, requestTimeoutId, ret, defer, self = this, remainingRetries = this.maxRetries, requestTimeout = this.requestTimeout, aborted = !1, body = params.body, headers = params.headers ? _.transform(params.headers, function (headers, val, name) {
                    headers[String(name).toLowerCase()] = val
                }) : {};
                if (self.log.debug("starting request", params), "function" == typeof cb ? (process.domain && (cb = process.domain.bind(cb)), ret = {abort: abortRequest}) : (defer = this.defer(), ret = defer.promise, ret.abort = abortRequest), body && "GET" === params.method)return _.nextTick(respond, new TypeError('Body can not be sent with method "GET"')), ret;
                if (body) {
                    var serializer = self.serializer, serializeFn = serializer[params.bulkBody ? "bulkBody" : "serialize"];
                    body = serializeFn.call(serializer, body), headers["content-type"] || (headers["content-type"] = serializeFn.contentType)
                }
                return params.hasOwnProperty("maxRetries") && (remainingRetries = params.maxRetries), params.hasOwnProperty("requestTimeout") && (requestTimeout = params.requestTimeout), params.req = {
                    method: params.method,
                    path: params.path || "/",
                    query: params.query,
                    body: body,
                    headers: headers
                }, requestTimeout && requestTimeout !== 1 / 0 && (requestTimeoutId = this._timeout(function () {
                    respond(new errors.RequestTimeout("Request Timeout after " + requestTimeout + "ms")), abortRequest()
                }, requestTimeout)), connection ? sendReqWithConnection(void 0, connection) : self.connectionPool.select(sendReqWithConnection), ret
            }, Transport.prototype._timeout = function (cb, delay) {
                if (!this.closed) {
                    var id, timers = this._timers || (this._timers = []);
                    if ("function" != typeof cb && (id = cb, cb = void 0), cb)return id = setTimeout(function () {
                        _.pull(timers, id), cb()
                    }, delay), timers.push(id), id;
                    if (id) {
                        clearTimeout(id);
                        var i = this._timers.indexOf(id);
                        -1 !== i && this._timers.splice(i, 1)
                    }
                }
            }, Transport.prototype.sniff = function (cb) {
                var self = this, nodesToHostCallback = this.nodesToHostCallback, log = this.log, sniffedNodesProtocol = this.sniffedNodesProtocol;
                cb = "function" == typeof cb ? cb : _.noop, this.request({
                    path: this.sniffEndpoint,
                    method: "GET"
                }, function (err, resp, status) {
                    if (!err && resp && resp.nodes) {
                        var hostsConfigs;
                        try {
                            hostsConfigs = nodesToHostCallback(resp.nodes)
                        } catch (e) {
                            return void log.error(new Error("Unable to convert node list from " + this.sniffEndpoint + " to hosts durring sniff. Encountered error:\n" + (e.stack || e.message)))
                        }
                        _.forEach(hostsConfigs, function (hostConfig) {
                            sniffedNodesProtocol && (hostConfig.protocol = sniffedNodesProtocol)
                        }), self.setHosts(hostsConfigs)
                    }
                    cb(err, resp, status)
                })
            }, Transport.prototype.setHosts = function (hostsConfigs) {
                var globalConfig = this._config;
                this.connectionPool.setHosts(_.map(hostsConfigs, function (conf) {
                    return conf instanceof Host ? conf : new Host(conf, globalConfig)
                }))
            }, Transport.prototype.close = function () {
                this.log.close(), this.closed = !0, _.each(this._timers, clearTimeout), this._timers = null, this.connectionPool.close()
            }
        }).call(this, require("_process"))
    }, {
        "./connection_pool": 17,
        "./errors": 22,
        "./host": 23,
        "./log": 24,
        "./nodes_to_host": 28,
        "./serializers": 33,
        "./transport/find_common_protocol": 36,
        "./transport/sniff_on_connection_fault": 37,
        "./utils": 38,
        _process: 48,
        "promise/lib/es6-extensions": 50
    }],
    36: [function (require, module, exports) {
        var isEmpty = require("lodash").isEmpty;
        module.exports = function (hosts) {
            if (isEmpty(hosts))return !1;
            for (var commonProtocol = hosts.shift().protocol, i = 0; i < hosts.length; i++)if (commonProtocol !== hosts[i].protocol)return !1;
            return commonProtocol
        }
    }, {lodash: 45}],
    37: [function (require, module, exports) {
        var _ = require("../utils");
        module.exports = function (transport) {
            var failures = 0, pool = transport.connectionPool, originalOnDied = pool._onConnectionDied, work = function () {
                work.timerId = transport._timeout(work.timerId), transport.sniff()
            }, countdownTo = function (ms) {
                var start = _.now();
                return function () {
                    return start - ms
                }
            };
            pool._onConnectionDied = function (connection, wasAlreadyDead) {
                var ret = originalOnDied.call(pool, connection, wasAlreadyDead);
                failures = work.timerId ? failures + 1 : 0;
                var ms = pool.calcDeadTimeout(failures, 1e3);
                return work.timerId && ms < work.timerId && work.countdown() && (work.timerId = transport._timeout(work.timerId)), work.timerId || (work.timerId = transport._timeout(work, ms), work.countdown = countdownTo(ms)), ret
            }, pool._onConnectionDied.restore = function () {
                pool._onConnectionDied = originalOnDied
            }
        }
    }, {"../utils": 38}],
    38: [function (require, module, exports) {
        (function (Buffer, process) {
            function adjustWordCase(firstWordCap, otherWordsCap, sep) {
                return function (string) {
                    for (var code, c, upper, lower, i = 0, words = [], word = ""; i < string.length; i++)code = string.charCodeAt(i), c = string.charAt(i), lower = code >= 97 && 122 >= code || code >= 48 && 57 >= code, upper = code >= 65 && 90 >= code, !upper && lower || (word.length && words.push(word), word = ""), (upper || lower) && (lower && word.length ? word += c : word = !words.length && firstWordCap || words.length && otherWordsCap ? c.toUpperCase() : c.toLowerCase());
                    return word.length && words.push(word), words.length && "_" === string.charAt(0) && (words[0] = "_" + words[0]), words.join(sep)
                }
            }

            var path = require("path"), _ = require("lodash"), nodeUtils = require("util"), utils = _.extend({}, _, nodeUtils);
            _ = utils, utils.joinPath = path.join, utils.deepMerge = function (to, from) {
                return _.each(from, function (fromVal, key) {
                    switch (typeof to[key]) {
                        case"undefined":
                            to[key] = from[key];
                            break;
                        case"object":
                            _.isArray(to[key]) && _.isArray(from[key]) ? to[key] = to[key].concat(from[key]) : _.isPlainObject(to[key]) && _.isPlainObject(from[key]) && utils.deepMerge(to[key], from[key])
                    }
                }), to
            }, _.each(["String", "Object", "PlainObject", "Array", "Finite", "Function", "RegExp"], function (type) {
                var check = _["is" + type];
                utils["isArrayOf" + type + "s"] = function (arr) {
                    return _.isArray(arr) && _.every(arr.slice(0, 10), check)
                }
            }), utils.ucfirst = function (word) {
                return word[0].toUpperCase() + word.substring(1).toLowerCase()
            }, utils.studlyCase = adjustWordCase(!0, !0, ""), utils.camelCase = adjustWordCase(!1, !0, ""), utils.snakeCase = adjustWordCase(!1, !1, "_"), utils.toLowerString = function (any) {
                return any ? "string" != typeof any && (any = any.toString()) : any = "", any.toLowerCase()
            }, utils.toUpperString = function (any) {
                return any ? "string" != typeof any && (any = any.toString()) : any = "", any.toUpperCase()
            }, utils.isNumeric = function (val) {
                return "object" != typeof val && val - parseFloat(val) >= 0
            };
            var intervalRE = /^(\d+(?:\.\d+)?)(M|w|d|h|m|s|y|ms)$/;
            utils.isInterval = function (val) {
                return !(!val.match || !val.match(intervalRE))
            }, utils.repeat = function (what, times) {
                return new Array(times + 1).join(what)
            }, utils.applyArgs = function (func, context, args, sliceIndex) {
                switch (sliceIndex = sliceIndex || 0, args.length - sliceIndex) {
                    case 0:
                        return func.call(context);
                    case 1:
                        return func.call(context, args[0 + sliceIndex]);
                    case 2:
                        return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex]);
                    case 3:
                        return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex]);
                    case 4:
                        return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex], args[3 + sliceIndex]);
                    case 5:
                        return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex], args[3 + sliceIndex], args[4 + sliceIndex]);
                    default:
                        return func.apply(context, Array.prototype.slice.call(args, sliceIndex))
                }
            }, _.nextTick = function (cb) {
                process.nextTick(_.bindKey(_, "applyArgs", cb, null, arguments, 1))
            }, _.handler = function (func) {
                return func._provideBound = !0, func
            }, _.scheduled = _.handler, _.makeBoundMethods = function (obj) {
                obj.bound = {};
                for (var prop in obj)"function" == typeof obj[prop] && obj[prop]._provideBound === !0 && (obj.bound[prop] = _.bind(obj[prop], obj))
            }, _.noop = function () {
            }, _.funcEnum = function (config, name, opts, def) {
                var val = config[name];
                switch (typeof val) {
                    case"undefined":
                        return opts[def];
                    case"function":
                        return val;
                    case"string":
                        if (opts.hasOwnProperty(val))return opts[val];
                    default:
                        var err = "Invalid " + name + ' "' + val + '", expected a function';
                        switch (_.size(opts)) {
                            case 0:
                                break;
                            case 1:
                                err += " or " + _.keys(opts)[0];
                                break;
                            default:
                                err += " or one of " + _.keys(opts).join(", ")
                        }
                        throw new TypeError(err)
                }
            }, _.createArray = function (input, transform) {
                transform = "function" == typeof transform ? transform : _.identity;
                var item, i, output = [];
                for (_.isArray(input) || (input = [input]), i = 0; i < input.length; i++) {
                    if (item = transform(input[i]), void 0 === item)return !1;
                    output.push(item)
                }
                return output
            }, _.getUnwrittenFromStream = function (stream) {
                var writeBuffer = _.getStreamWriteBuffer(stream);
                if (writeBuffer) {
                    var out = "";
                    return writeBuffer.length ? (_.each(writeBuffer, function (writeReq) {
                        if (writeReq.chunk)out += "" + writeReq.chunk; else {
                            if (!_.isArray(writeReq) || "string" != typeof writeReq[0] && !Buffer.isBuffer(writeReq[0]))return !1;
                            out += "" + writeReq[0]
                        }
                    }), out) : out
                }
            }, _.getStreamWriteBuffer = function (stream) {
                if (stream && stream._writableState) {
                    var writeState = stream._writableState;
                    return writeState.getBuffer ? writeState.getBuffer() : writeState.buffer ? writeState.buffer : void 0
                }
            }, _.clearWriteStreamBuffer = function (stream) {
                var buffer = _.getStreamWriteBuffer(stream);
                return buffer && buffer.splice(0)
            }, _.now = function () {
                return "function" == typeof Date.now ? Date.now() : (new Date).getTime()
            }, module.exports = utils
        }).call(this, {isBuffer: require("../../../is-buffer/index.js")}, require("_process"))
    }, {"../../../is-buffer/index.js": 42, _process: 48, lodash: 45, path: 47, util: 58}],
    39: [function (require, module, exports) {
        function EventEmitter() {
            this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0
        }

        function isFunction(arg) {
            return "function" == typeof arg
        }

        function isNumber(arg) {
            return "number" == typeof arg
        }

        function isObject(arg) {
            return "object" == typeof arg && null !== arg
        }

        function isUndefined(arg) {
            return void 0 === arg
        }

        module.exports = EventEmitter, EventEmitter.EventEmitter = EventEmitter, EventEmitter.prototype._events = void 0, EventEmitter.prototype._maxListeners = void 0, EventEmitter.defaultMaxListeners = 10, EventEmitter.prototype.setMaxListeners = function (n) {
            if (!isNumber(n) || 0 > n || isNaN(n))throw TypeError("n must be a positive number");
            return this._maxListeners = n, this
        }, EventEmitter.prototype.emit = function (type) {
            var er, handler, len, args, i, listeners;
            if (this._events || (this._events = {}), "error" === type && (!this._events.error || isObject(this._events.error) && !this._events.error.length)) {
                if (er = arguments[1], er instanceof Error)throw er;
                throw TypeError('Uncaught, unspecified "error" event.')
            }
            if (handler = this._events[type], isUndefined(handler))return !1;
            if (isFunction(handler))switch (arguments.length) {
                case 1:
                    handler.call(this);
                    break;
                case 2:
                    handler.call(this, arguments[1]);
                    break;
                case 3:
                    handler.call(this, arguments[1], arguments[2]);
                    break;
                default:
                    args = Array.prototype.slice.call(arguments, 1), handler.apply(this, args)
            } else if (isObject(handler))for (args = Array.prototype.slice.call(arguments, 1), listeners = handler.slice(), len = listeners.length, i = 0; len > i; i++)listeners[i].apply(this, args);
            return !0
        }, EventEmitter.prototype.addListener = function (type, listener) {
            var m;
            if (!isFunction(listener))throw TypeError("listener must be a function");
            return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener), this._events[type] ? isObject(this._events[type]) ? this._events[type].push(listener) : this._events[type] = [this._events[type], listener] : this._events[type] = listener, isObject(this._events[type]) && !this._events[type].warned && (m = isUndefined(this._maxListeners) ? EventEmitter.defaultMaxListeners : this._maxListeners, m && m > 0 && this._events[type].length > m && (this._events[type].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[type].length), "function" == typeof console.trace && console.trace())), this
        }, EventEmitter.prototype.on = EventEmitter.prototype.addListener, EventEmitter.prototype.once = function (type, listener) {
            function g() {
                this.removeListener(type, g), fired || (fired = !0, listener.apply(this, arguments))
            }

            if (!isFunction(listener))throw TypeError("listener must be a function");
            var fired = !1;
            return g.listener = listener, this.on(type, g), this
        }, EventEmitter.prototype.removeListener = function (type, listener) {
            var list, position, length, i;
            if (!isFunction(listener))throw TypeError("listener must be a function");
            if (!this._events || !this._events[type])return this;
            if (list = this._events[type], length = list.length, position = -1, list === listener || isFunction(list.listener) && list.listener === listener)delete this._events[type], this._events.removeListener && this.emit("removeListener", type, listener); else if (isObject(list)) {
                for (i = length; i-- > 0;)if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                    position = i;
                    break
                }
                if (0 > position)return this;
                1 === list.length ? (list.length = 0, delete this._events[type]) : list.splice(position, 1), this._events.removeListener && this.emit("removeListener", type, listener)
            }
            return this
        }, EventEmitter.prototype.removeAllListeners = function (type) {
            var key, listeners;
            if (!this._events)return this;
            if (!this._events.removeListener)return 0 === arguments.length ? this._events = {} : this._events[type] && delete this._events[type], this;
            if (0 === arguments.length) {
                for (key in this._events)"removeListener" !== key && this.removeAllListeners(key);
                return this.removeAllListeners("removeListener"), this._events = {}, this
            }
            if (listeners = this._events[type], isFunction(listeners))this.removeListener(type, listeners); else if (listeners)for (; listeners.length;)this.removeListener(type, listeners[listeners.length - 1]);
            return delete this._events[type], this
        }, EventEmitter.prototype.listeners = function (type) {
            var ret;
            return ret = this._events && this._events[type] ? isFunction(this._events[type]) ? [this._events[type]] : this._events[type].slice() : []
        }, EventEmitter.prototype.listenerCount = function (type) {
            if (this._events) {
                var evlistener = this._events[type];
                if (isFunction(evlistener))return 1;
                if (evlistener)return evlistener.length
            }
            return 0
        }, EventEmitter.listenerCount = function (emitter, type) {
            return emitter.listenerCount(type)
        }
    }, {}],
    40: [function (require, module, exports) {
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
            var e, m, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i];
            for (i += d, e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen; nBits > 0; e = 256 * e + buffer[offset + i], i += d, nBits -= 8);
            for (m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen; nBits > 0; m = 256 * m + buffer[offset + i], i += d, nBits -= 8);
            if (0 === e)e = 1 - eBias; else {
                if (e === eMax)return m ? NaN : (s ? -1 : 1) * (1 / 0);
                m += Math.pow(2, mLen), e -= eBias
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }, exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = 0 > value || 0 === value && 0 > 1 / value ? 1 : 0;
            for (value = Math.abs(value), isNaN(value) || value === 1 / 0 ? (m = isNaN(value) ? 1 : 0, e = eMax) : (e = Math.floor(Math.log(value) / Math.LN2), value * (c = Math.pow(2, -e)) < 1 && (e--, c *= 2), value += e + eBias >= 1 ? rt / c : rt * Math.pow(2, 1 - eBias), value * c >= 2 && (e++, c /= 2), e + eBias >= eMax ? (m = 0, e = eMax) : e + eBias >= 1 ? (m = (value * c - 1) * Math.pow(2, mLen), e += eBias) : (m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0)); mLen >= 8; buffer[offset + i] = 255 & m, i += d, m /= 256, mLen -= 8);
            for (e = e << mLen | m, eLen += mLen; eLen > 0; buffer[offset + i] = 255 & e, i += d, e /= 256, eLen -= 8);
            buffer[offset + i - d] |= 128 * s
        }
    }, {}],
    41: [function (require, module, exports) {
        "function" == typeof Object.create ? module.exports = function (ctor, superCtor) {
            ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            })
        } : module.exports = function (ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function () {
            };
            TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor
        }
    }, {}],
    42: [function (require, module, exports) {
        module.exports = function (obj) {
            return !(null == obj || !(obj._isBuffer || obj.constructor && "function" == typeof obj.constructor.isBuffer && obj.constructor.isBuffer(obj)))
        }
    }, {}],
    43: [function (require, module, exports) {
        var toString = {}.toString;
        module.exports = Array.isArray || function (arr) {
                return "[object Array]" == toString.call(arr)
            }
    }, {}],
    44: [function (require, module, exports) {
        !function (a, b) {
            "use strict";
            var c = {
                item: 3,
                autoWidth: !1,
                slideMove: 1,
                slideMargin: 10,
                addClass: "",
                mode: "slide",
                useCSS: !0,
                cssEasing: "ease",
                easing: "linear",
                speed: 400,
                auto: !1,
                pauseOnHover: !1,
                loop: !1,
                slideEndAnimation: !0,
                pause: 2e3,
                keyPress: !1,
                controls: !0,
                prevHtml: "",
                nextHtml: "",
                rtl: !1,
                adaptiveHeight: !1,
                vertical: !1,
                verticalHeight: 500,
                vThumbWidth: 100,
                thumbItem: 10,
                pager: !0,
                gallery: !1,
                galleryMargin: 5,
                thumbMargin: 5,
                currentPagerPosition: "middle",
                enableTouch: !0,
                enableDrag: !0,
                freeMove: !0,
                swipeThreshold: 40,
                responsive: [],
                onBeforeStart: function (a) {
                },
                onSliderLoad: function (a) {
                },
                onBeforeSlide: function (a, b) {
                },
                onAfterSlide: function (a, b) {
                },
                onBeforeNextSlide: function (a, b) {
                },
                onBeforePrevSlide: function (a, b) {
                }
            };
            a.fn.lightSlider = function (b) {
                if (0 === this.length)return this;
                if (this.length > 1)return this.each(function () {
                    a(this).lightSlider(b)
                }), this;
                var d = {}, e = a.extend(!0, {}, c, b), f = {}, g = this;
                d.$el = this, "fade" === e.mode && (e.vertical = !1);
                var h = g.children(), i = a(window).width(), j = null, k = null, l = 0, m = 0, n = !1, o = 0, p = "", q = 0, r = e.vertical === !0 ? "height" : "width", s = e.vertical === !0 ? "margin-bottom" : "margin-right", t = 0, u = 0, v = 0, w = 0, x = null, y = "ontouchstart" in document.documentElement, z = {};
                return z.chbreakpoint = function () {
                    if (i = a(window).width(), e.responsive.length) {
                        var b;
                        if (e.autoWidth === !1 && (b = e.item), i < e.responsive[0].breakpoint)for (var c = 0; c < e.responsive.length; c++)i < e.responsive[c].breakpoint && (j = e.responsive[c].breakpoint, k = e.responsive[c]);
                        if ("undefined" != typeof k && null !== k)for (var d in k.settings)k.settings.hasOwnProperty(d) && (("undefined" == typeof f[d] || null === f[d]) && (f[d] = e[d]), e[d] = k.settings[d]);
                        if (!a.isEmptyObject(f) && i > e.responsive[0].breakpoint)for (var g in f)f.hasOwnProperty(g) && (e[g] = f[g]);
                        e.autoWidth === !1 && t > 0 && v > 0 && b !== e.item && (q = Math.round(t / ((v + e.slideMargin) * e.slideMove)))
                    }
                }, z.calSW = function () {
                    e.autoWidth === !1 && (v = (o - (e.item * e.slideMargin - e.slideMargin)) / e.item)
                }, z.calWidth = function (a) {
                    var b = a === !0 ? p.find(".lslide").length : h.length;
                    if (e.autoWidth === !1)m = b * (v + e.slideMargin); else {
                        m = 0;
                        for (var c = 0; b > c; c++)m += parseInt(h.eq(c).width()) + e.slideMargin
                    }
                    return m
                }, d = {
                    doCss: function () {
                        var a = function () {
                            for (var a = ["transition", "MozTransition", "WebkitTransition", "OTransition", "msTransition", "KhtmlTransition"], b = document.documentElement, c = 0; c < a.length; c++)if (a[c] in b.style)return !0
                        };
                        return !(!e.useCSS || !a())
                    }, keyPress: function () {
                        e.keyPress && a(document).on("keyup.lightslider", function (b) {
                            a(":focus").is("input, textarea") || (b.preventDefault ? b.preventDefault() : b.returnValue = !1, 37 === b.keyCode ? g.goToPrevSlide() : 39 === b.keyCode && g.goToNextSlide())
                        })
                    }, controls: function () {
                        e.controls && (g.after('<div class="lSAction"><a class="lSPrev">' + e.prevHtml + '</a><a class="lSNext">' + e.nextHtml + "</a></div>"), e.autoWidth ? z.calWidth(!1) < o && p.find(".lSAction").hide() : l <= e.item && p.find(".lSAction").hide(), p.find(".lSAction a").on("click", function (b) {
                            return b.preventDefault ? b.preventDefault() : b.returnValue = !1, "lSPrev" === a(this).attr("class") ? g.goToPrevSlide() : g.goToNextSlide(), !1
                        }))
                    }, initialStyle: function () {
                        var a = this;
                        "fade" === e.mode && (e.autoWidth = !1, e.slideEndAnimation = !1), e.auto && (e.slideEndAnimation = !1), e.autoWidth && (e.slideMove = 1, e.item = 1), e.loop && (e.slideMove = 1, e.freeMove = !1), e.onBeforeStart.call(this, g), z.chbreakpoint(), g.addClass("lightSlider").wrap('<div class="lSSlideOuter ' + e.addClass + '"><div class="lSSlideWrapper"></div></div>'), p = g.parent(".lSSlideWrapper"), e.rtl === !0 && p.parent().addClass("lSrtl"), e.vertical ? (p.parent().addClass("vertical"), o = e.verticalHeight, p.css("height", o + "px")) : o = g.outerWidth(), h.addClass("lslide"), e.loop === !0 && "slide" === e.mode && (z.calSW(), z.clone = function () {
                            if (z.calWidth(!0) > o) {
                                for (var b = 0, c = 0, d = 0; d < h.length && (b += parseInt(g.find(".lslide").eq(d).width()) + e.slideMargin, c++, !(b >= o + e.slideMargin)); d++);
                                var f = e.autoWidth === !0 ? c : e.item;
                                if (f < g.find(".clone.left").length)for (var i = 0; i < g.find(".clone.left").length - f; i++)h.eq(i).remove();
                                if (f < g.find(".clone.right").length)for (var j = h.length - 1; j > h.length - 1 - g.find(".clone.right").length; j--)q--, h.eq(j).remove();
                                for (var k = g.find(".clone.right").length; f > k; k++)g.find(".lslide").eq(k).clone().removeClass("lslide").addClass("clone right").appendTo(g), q++;
                                for (var l = g.find(".lslide").length - g.find(".clone.left").length; l > g.find(".lslide").length - f; l--)g.find(".lslide").eq(l - 1).clone().removeClass("lslide").addClass("clone left").prependTo(g);
                                h = g.children()
                            } else h.hasClass("clone") && (g.find(".clone").remove(), a.move(g, 0))
                        }, z.clone()), z.sSW = function () {
                            l = h.length, e.rtl === !0 && e.vertical === !1 && (s = "margin-left"), e.autoWidth === !1 && h.css(r, v + "px"), h.css(s, e.slideMargin + "px"), m = z.calWidth(!1), g.css(r, m + "px"), e.loop === !0 && "slide" === e.mode && n === !1 && (q = g.find(".clone.left").length)
                        }, z.calL = function () {
                            h = g.children(), l = h.length
                        }, this.doCss() && p.addClass("usingCss"), z.calL(), "slide" === e.mode ? (z.calSW(), z.sSW(), e.loop === !0 && (t = a.slideValue(), this.move(g, t)), e.vertical === !1 && this.setHeight(g, !1)) : (this.setHeight(g, !0), g.addClass("lSFade"), this.doCss() || (h.fadeOut(0), h.eq(q).fadeIn(0))), e.loop === !0 && "slide" === e.mode ? h.eq(q).addClass("active") : h.first().addClass("active")
                    }, pager: function () {
                        var a = this;
                        if (z.createPager = function () {
                                w = (o - (e.thumbItem * e.thumbMargin - e.thumbMargin)) / e.thumbItem;
                                var b = p.find(".lslide"), c = p.find(".lslide").length, d = 0, f = "", h = 0;
                                for (d = 0; c > d; d++) {
                                    "slide" === e.mode && (e.autoWidth ? h += (parseInt(b.eq(d).width()) + e.slideMargin) * e.slideMove : h = d * (v + e.slideMargin) * e.slideMove);
                                    var i = b.eq(d * e.slideMove).attr("data-thumb");
                                    if (f += e.gallery === !0 ? '<li style="width:100%;' + r + ":" + w + "px;" + s + ":" + e.thumbMargin + 'px"><a href="#"><img src="' + i + '" /></a></li>' : '<li><a href="#">' + (d + 1) + "</a></li>", "slide" === e.mode && h >= m - o - e.slideMargin) {
                                        d += 1;
                                        var j = 2;
                                        e.autoWidth && (f += '<li><a href="#">' + (d + 1) + "</a></li>", j = 1), j > d ? (f = null, p.parent().addClass("noPager")) : p.parent().removeClass("noPager");
                                        break
                                    }
                                }
                                var k = p.parent();
                                k.find(".lSPager").html(f), e.gallery === !0 && (e.vertical === !0 && k.find(".lSPager").css("width", e.vThumbWidth + "px"), u = d * (e.thumbMargin + w) + .5, k.find(".lSPager").css({
                                    property: u + "px",
                                    "transition-duration": e.speed + "ms"
                                }), e.vertical === !0 && p.parent().css("padding-right", e.vThumbWidth + e.galleryMargin + "px"), k.find(".lSPager").css(r, u + "px"));
                                var l = k.find(".lSPager").find("li");
                                l.first().addClass("active"), l.on("click", function () {
                                    return e.loop === !0 && "slide" === e.mode ? q += l.index(this) - k.find(".lSPager").find("li.active").index() : q = l.index(this), g.mode(!1), e.gallery === !0 && a.slideThumb(), !1
                                })
                            }, e.pager) {
                            var b = "lSpg";
                            e.gallery && (b = "lSGallery"), p.after('<ul class="lSPager ' + b + '"></ul>');
                            var c = e.vertical ? "margin-left" : "margin-top";
                            p.parent().find(".lSPager").css(c, e.galleryMargin + "px"), z.createPager()
                        }
                        setTimeout(function () {
                            z.init()
                        }, 0)
                    }, setHeight: function (a, b) {
                        var c = null, d = this;
                        c = e.loop ? a.children(".lslide ").first() : a.children().first();
                        var f = function () {
                            var d = c.outerHeight(), e = 0, f = d;
                            b && (d = 0, e = 100 * f / o), a.css({height: d + "px", "padding-bottom": e + "%"})
                        };
                        f(), c.find("img").length ? c.find("img")[0].complete ? (f(), x || d.auto()) : c.find("img").load(function () {
                            setTimeout(function () {
                                f(), x || d.auto()
                            }, 100)
                        }) : x || d.auto()
                    }, active: function (a, b) {
                        this.doCss() && "fade" === e.mode && p.addClass("on");
                        var c = 0;
                        if (q * e.slideMove < l) {
                            a.removeClass("active"), this.doCss() || "fade" !== e.mode || b !== !1 || a.fadeOut(e.speed), c = b === !0 ? q : q * e.slideMove;
                            var d, f;
                            b === !0 && (d = a.length, f = d - 1, c + 1 >= d && (c = f)), e.loop === !0 && "slide" === e.mode && (c = b === !0 ? q - g.find(".clone.left").length : q * e.slideMove, b === !0 && (d = a.length, f = d - 1, c + 1 === d ? c = f : c + 1 > d && (c = 0))), this.doCss() || "fade" !== e.mode || b !== !1 || a.eq(c).fadeIn(e.speed), a.eq(c).addClass("active")
                        } else a.removeClass("active"), a.eq(a.length - 1).addClass("active"), this.doCss() || "fade" !== e.mode || b !== !1 || (a.fadeOut(e.speed), a.eq(c).fadeIn(e.speed))
                    }, move: function (a, b) {
                        e.rtl === !0 && (b = -b), this.doCss() ? a.css(e.vertical === !0 ? {
                            transform: "translate3d(0px, " + -b + "px, 0px)",
                            "-webkit-transform": "translate3d(0px, " + -b + "px, 0px)"
                        } : {
                            transform: "translate3d(" + -b + "px, 0px, 0px)",
                            "-webkit-transform": "translate3d(" + -b + "px, 0px, 0px)"
                        }) : e.vertical === !0 ? a.css("position", "relative").animate({top: -b + "px"}, e.speed, e.easing) : a.css("position", "relative").animate({left: -b + "px"}, e.speed, e.easing);
                        var c = p.parent().find(".lSPager").find("li");
                        this.active(c, !0)
                    }, fade: function () {
                        this.active(h, !1);
                        var a = p.parent().find(".lSPager").find("li");
                        this.active(a, !0)
                    }, slide: function () {
                        var a = this;
                        z.calSlide = function () {
                            m > o && (t = a.slideValue(), a.active(h, !1), t > m - o - e.slideMargin ? t = m - o - e.slideMargin : 0 > t && (t = 0), a.move(g, t), e.loop === !0 && "slide" === e.mode && (q >= l - g.find(".clone.left").length / e.slideMove && a.resetSlide(g.find(".clone.left").length), 0 === q && a.resetSlide(p.find(".lslide").length)))
                        }, z.calSlide()
                    }, resetSlide: function (a) {
                        var b = this;
                        p.find(".lSAction a").addClass("disabled"), setTimeout(function () {
                            q = a, p.css("transition-duration", "0ms"), t = b.slideValue(), b.active(h, !1), d.move(g, t), setTimeout(function () {
                                p.css("transition-duration", e.speed + "ms"), p.find(".lSAction a").removeClass("disabled")
                            }, 50)
                        }, e.speed + 100)
                    }, slideValue: function () {
                        var a = 0;
                        if (e.autoWidth === !1)a = q * (v + e.slideMargin) * e.slideMove; else {
                            a = 0;
                            for (var b = 0; q > b; b++)a += parseInt(h.eq(b).width()) + e.slideMargin
                        }
                        return a
                    }, slideThumb: function () {
                        var a;
                        switch (e.currentPagerPosition) {
                            case"left":
                                a = 0;
                                break;
                            case"middle":
                                a = o / 2 - w / 2;
                                break;
                            case"right":
                                a = o - w
                        }
                        var b = q - g.find(".clone.left").length, c = p.parent().find(".lSPager");
                        "slide" === e.mode && e.loop === !0 && (b >= c.children().length ? b = 0 : 0 > b && (b = c.children().length));
                        var d = b * (w + e.thumbMargin) - a;
                        d + o > u && (d = u - o - e.thumbMargin), 0 > d && (d = 0), this.move(c, d)
                    }, auto: function () {
                        e.auto && (clearInterval(x), x = setInterval(function () {
                            g.goToNextSlide()
                        }, e.pause))
                    }, pauseOnHover: function () {
                        var b = this;
                        e.auto && e.pauseOnHover && (p.on("mouseenter", function () {
                            a(this).addClass("ls-hover"), g.pause(), e.auto = !0
                        }), p.on("mouseleave", function () {
                            a(this).removeClass("ls-hover"), p.find(".lightSlider").hasClass("lsGrabbing") || b.auto()
                        }))
                    }, touchMove: function (a, b) {
                        if (p.css("transition-duration", "0ms"), "slide" === e.mode) {
                            var c = a - b, d = t - c;
                            if (d >= m - o - e.slideMargin)if (e.freeMove === !1)d = m - o - e.slideMargin; else {
                                var f = m - o - e.slideMargin;
                                d = f + (d - f) / 5
                            } else 0 > d && (e.freeMove === !1 ? d = 0 : d /= 5);
                            this.move(g, d)
                        }
                    }, touchEnd: function (a) {
                        if (p.css("transition-duration", e.speed + "ms"), "slide" === e.mode) {
                            var b = !1, c = !0;
                            t -= a, t > m - o - e.slideMargin ? (t = m - o - e.slideMargin, e.autoWidth === !1 && (b = !0)) : 0 > t && (t = 0);
                            var d = function (a) {
                                var c = 0;
                                if (b || a && (c = 1), e.autoWidth)for (var d = 0, f = 0; f < h.length && (d += parseInt(h.eq(f).width()) + e.slideMargin, q = f + c, !(d >= t)); f++); else {
                                    var g = t / ((v + e.slideMargin) * e.slideMove);
                                    q = parseInt(g) + c, t >= m - o - e.slideMargin && g % 1 !== 0 && q++
                                }
                            };
                            a >= e.swipeThreshold ? (d(!1), c = !1) : a <= -e.swipeThreshold && (d(!0), c = !1), g.mode(c), this.slideThumb()
                        } else a >= e.swipeThreshold ? g.goToPrevSlide() : a <= -e.swipeThreshold && g.goToNextSlide()
                    }, enableDrag: function () {
                        var b = this;
                        if (!y) {
                            var c = 0, d = 0, f = !1;
                            p.find(".lightSlider").addClass("lsGrab"), p.on("mousedown", function (b) {
                                return o > m && 0 !== m ? !1 : void("lSPrev" !== a(b.target).attr("class") && "lSNext" !== a(b.target).attr("class") && (c = e.vertical === !0 ? b.pageY : b.pageX, f = !0, b.preventDefault ? b.preventDefault() : b.returnValue = !1, p.scrollLeft += 1, p.scrollLeft -= 1, p.find(".lightSlider").removeClass("lsGrab").addClass("lsGrabbing"), clearInterval(x)))
                            }), a(window).on("mousemove", function (a) {
                                f && (d = e.vertical === !0 ? a.pageY : a.pageX, b.touchMove(d, c))
                            }), a(window).on("mouseup", function (g) {
                                if (f) {
                                    p.find(".lightSlider").removeClass("lsGrabbing").addClass("lsGrab"), f = !1, d = e.vertical === !0 ? g.pageY : g.pageX;
                                    var h = d - c;
                                    Math.abs(h) >= e.swipeThreshold && a(window).on("click.ls", function (b) {
                                        b.preventDefault ? b.preventDefault() : b.returnValue = !1, b.stopImmediatePropagation(), b.stopPropagation(), a(window).off("click.ls")
                                    }), b.touchEnd(h)
                                }
                            })
                        }
                    }, enableTouch: function () {
                        var a = this;
                        if (y) {
                            var b = {}, c = {};
                            p.on("touchstart", function (a) {
                                c = a.originalEvent.targetTouches[0], b.pageX = a.originalEvent.targetTouches[0].pageX, b.pageY = a.originalEvent.targetTouches[0].pageY, clearInterval(x)
                            }), p.on("touchmove", function (d) {
                                if (o > m && 0 !== m)return !1;
                                var f = d.originalEvent;
                                c = f.targetTouches[0];
                                var g = Math.abs(c.pageX - b.pageX), h = Math.abs(c.pageY - b.pageY);
                                e.vertical === !0 ? (3 * h > g && d.preventDefault(), a.touchMove(c.pageY, b.pageY)) : (3 * g > h && d.preventDefault(), a.touchMove(c.pageX, b.pageX))
                            }), p.on("touchend", function () {
                                if (o > m && 0 !== m)return !1;
                                var d;
                                d = e.vertical === !0 ? c.pageY - b.pageY : c.pageX - b.pageX, a.touchEnd(d)
                            })
                        }
                    }, build: function () {
                        var b = this;
                        b.initialStyle(), this.doCss() && (e.enableTouch === !0 && b.enableTouch(), e.enableDrag === !0 && b.enableDrag()), a(window).on("focus", function () {
                            b.auto()
                        }), a(window).on("blur", function () {
                            clearInterval(x)
                        }), b.pager(), b.pauseOnHover(), b.controls(), b.keyPress()
                    }
                }, d.build(), z.init = function () {
                    z.chbreakpoint(), e.vertical === !0 ? (o = e.item > 1 ? e.verticalHeight : h.outerHeight(), p.css("height", o + "px")) : o = p.outerWidth(), e.loop === !0 && "slide" === e.mode && z.clone(), z.calL(), "slide" === e.mode && g.removeClass("lSSlide"), "slide" === e.mode && (z.calSW(), z.sSW()), setTimeout(function () {
                        "slide" === e.mode && g.addClass("lSSlide")
                    }, 1e3), e.pager && z.createPager(), e.adaptiveHeight === !0 && e.vertical === !1 && g.css("height", h.eq(q).outerHeight(!0)), e.adaptiveHeight === !1 && ("slide" === e.mode ? e.vertical === !1 ? d.setHeight(g, !1) : d.auto() : d.setHeight(g, !0)), e.gallery === !0 && d.slideThumb(), "slide" === e.mode && d.slide(), e.autoWidth === !1 ? h.length <= e.item ? p.find(".lSAction").hide() : p.find(".lSAction").show() : z.calWidth(!1) < o && 0 !== m ? p.find(".lSAction").hide() : p.find(".lSAction").show()
                }, g.goToPrevSlide = function () {
                    if (q > 0)e.onBeforePrevSlide.call(this, g, q), q--, g.mode(!1), e.gallery === !0 && d.slideThumb(); else if (e.loop === !0) {
                        if (e.onBeforePrevSlide.call(this, g, q), "fade" === e.mode) {
                            var a = l - 1;
                            q = parseInt(a / e.slideMove)
                        }
                        g.mode(!1), e.gallery === !0 && d.slideThumb()
                    } else e.slideEndAnimation === !0 && (g.addClass("leftEnd"), setTimeout(function () {
                        g.removeClass("leftEnd")
                    }, 400))
                }, g.goToNextSlide = function () {
                    var a = !0;
                    if ("slide" === e.mode) {
                        var b = d.slideValue();
                        a = b < m - o - e.slideMargin
                    }
                    q * e.slideMove < l - e.slideMove && a ? (e.onBeforeNextSlide.call(this, g, q), q++, g.mode(!1), e.gallery === !0 && d.slideThumb()) : e.loop === !0 ? (e.onBeforeNextSlide.call(this, g, q), q = 0, g.mode(!1), e.gallery === !0 && d.slideThumb()) : e.slideEndAnimation === !0 && (g.addClass("rightEnd"), setTimeout(function () {
                        g.removeClass("rightEnd")
                    }, 400))
                }, g.mode = function (a) {
                    e.adaptiveHeight === !0 && e.vertical === !1 && g.css("height", h.eq(q).outerHeight(!0)), n === !1 && ("slide" === e.mode ? d.doCss() && (g.addClass("lSSlide"), "" !== e.speed && p.css("transition-duration", e.speed + "ms"), "" !== e.cssEasing && p.css("transition-timing-function", e.cssEasing)) : d.doCss() && ("" !== e.speed && g.css("transition-duration", e.speed + "ms"), "" !== e.cssEasing && g.css("transition-timing-function", e.cssEasing))), a || e.onBeforeSlide.call(this, g, q), "slide" === e.mode ? d.slide() : d.fade(), p.hasClass("ls-hover") || d.auto(), setTimeout(function () {
                        a || e.onAfterSlide.call(this, g, q)
                    }, e.speed), n = !0
                }, g.play = function () {
                    g.goToNextSlide(), e.auto = !0, d.auto()
                }, g.pause = function () {
                    e.auto = !1, clearInterval(x)
                }, g.refresh = function () {
                    z.init()
                }, g.getCurrentSlideCount = function () {
                    var a = q;
                    if (e.loop) {
                        var b = p.find(".lslide").length, c = g.find(".clone.left").length;
                        a = c - 1 >= q ? b + (q - c) : q >= b + c ? q - b - c : q - c
                    }
                    return a + 1
                }, g.getTotalSlideCount = function () {
                    return p.find(".lslide").length
                }, g.goToSlide = function (a) {
                    q = e.loop ? a + g.find(".clone.left").length - 1 : a, g.mode(!1), e.gallery === !0 && d.slideThumb()
                }, g.destroy = function () {
                    g.lightSlider && (g.goToPrevSlide = function () {
                    }, g.goToNextSlide = function () {
                    }, g.mode = function () {
                    }, g.play = function () {
                    }, g.pause = function () {
                    }, g.refresh = function () {
                    }, g.getCurrentSlideCount = function () {
                    }, g.getTotalSlideCount = function () {
                    }, g.goToSlide = function () {
                    }, g.lightSlider = null, z = {
                        init: function () {
                        }
                    }, g.parent().parent().find(".lSAction, .lSPager").remove(), g.removeClass("lightSlider lSFade lSSlide lsGrab lsGrabbing leftEnd right").removeAttr("style").unwrap().unwrap(), g.children().removeAttr("style"), h.removeClass("lslide active"), g.find(".clone").remove(), h = null, x = null, n = !1, q = 0)
                }, setTimeout(function () {
                    e.onSliderLoad.call(this, g)
                }, 10), a(window).on("resize orientationchange", function (a) {
                    setTimeout(function () {
                        a.preventDefault ? a.preventDefault() : a.returnValue = !1, z.init()
                    }, 200)
                }), this
            }
        }(jQuery)
    }, {}],
    45: [function (require, module, exports) {
        (function (global) {
            (function () {
                function baseCompareAscending(value, other) {
                    if (value !== other) {
                        var valIsNull = null === value, valIsUndef = value === undefined, valIsReflexive = value === value, othIsNull = null === other, othIsUndef = other === undefined, othIsReflexive = other === other;
                        if (value > other && !othIsNull || !valIsReflexive || valIsNull && !othIsUndef && othIsReflexive || valIsUndef && othIsReflexive)return 1;
                        if (other > value && !valIsNull || !othIsReflexive || othIsNull && !valIsUndef && valIsReflexive || othIsUndef && valIsReflexive)return -1
                    }
                    return 0
                }

                function baseFindIndex(array, predicate, fromRight) {
                    for (var length = array.length, index = fromRight ? length : -1; fromRight ? index-- : ++index < length;)if (predicate(array[index], index, array))return index;
                    return -1
                }

                function baseIndexOf(array, value, fromIndex) {
                    if (value !== value)return indexOfNaN(array, fromIndex);
                    for (var index = fromIndex - 1, length = array.length; ++index < length;)if (array[index] === value)return index;
                    return -1
                }

                function baseIsFunction(value) {
                    return "function" == typeof value || !1
                }

                function baseToString(value) {
                    return null == value ? "" : value + ""
                }

                function charsLeftIndex(string, chars) {
                    for (var index = -1, length = string.length; ++index < length && chars.indexOf(string.charAt(index)) > -1;);
                    return index
                }

                function charsRightIndex(string, chars) {
                    for (var index = string.length; index-- && chars.indexOf(string.charAt(index)) > -1;);
                    return index
                }

                function compareAscending(object, other) {
                    return baseCompareAscending(object.criteria, other.criteria) || object.index - other.index
                }

                function compareMultiple(object, other, orders) {
                    for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length;) {
                        var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
                        if (result) {
                            if (index >= ordersLength)return result;
                            var order = orders[index];
                            return result * ("asc" === order || order === !0 ? 1 : -1)
                        }
                    }
                    return object.index - other.index
                }

                function deburrLetter(letter) {
                    return deburredLetters[letter]
                }

                function escapeHtmlChar(chr) {
                    return htmlEscapes[chr]
                }

                function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
                    return leadingChar ? chr = regexpEscapes[chr] : whitespaceChar && (chr = stringEscapes[chr]), "\\" + chr
                }

                function escapeStringChar(chr) {
                    return "\\" + stringEscapes[chr]
                }

                function indexOfNaN(array, fromIndex, fromRight) {
                    for (var length = array.length, index = fromIndex + (fromRight ? 0 : -1); fromRight ? index-- : ++index < length;) {
                        var other = array[index];
                        if (other !== other)return index
                    }
                    return -1
                }

                function isObjectLike(value) {
                    return !!value && "object" == typeof value
                }

                function isSpace(charCode) {
                    return 160 >= charCode && charCode >= 9 && 13 >= charCode || 32 == charCode || 160 == charCode || 5760 == charCode || 6158 == charCode || charCode >= 8192 && (8202 >= charCode || 8232 == charCode || 8233 == charCode || 8239 == charCode || 8287 == charCode || 12288 == charCode || 65279 == charCode)
                }

                function replaceHolders(array, placeholder) {
                    for (var index = -1, length = array.length, resIndex = -1, result = []; ++index < length;)array[index] === placeholder && (array[index] = PLACEHOLDER, result[++resIndex] = index);
                    return result
                }

                function sortedUniq(array, iteratee) {
                    for (var seen, index = -1, length = array.length, resIndex = -1, result = []; ++index < length;) {
                        var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
                        index && seen === computed || (seen = computed, result[++resIndex] = value)
                    }
                    return result
                }

                function trimmedLeftIndex(string) {
                    for (var index = -1, length = string.length; ++index < length && isSpace(string.charCodeAt(index)););
                    return index
                }

                function trimmedRightIndex(string) {
                    for (var index = string.length; index-- && isSpace(string.charCodeAt(index)););
                    return index
                }

                function unescapeHtmlChar(chr) {
                    return htmlUnescapes[chr]
                }

                function runInContext(context) {
                    function lodash(value) {
                        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                            if (value instanceof LodashWrapper)return value;
                            if (hasOwnProperty.call(value, "__chain__") && hasOwnProperty.call(value, "__wrapped__"))return wrapperClone(value)
                        }
                        return new LodashWrapper(value)
                    }

                    function baseLodash() {
                    }

                    function LodashWrapper(value, chainAll, actions) {
                        this.__wrapped__ = value, this.__actions__ = actions || [], this.__chain__ = !!chainAll
                    }

                    function LazyWrapper(value) {
                        this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = POSITIVE_INFINITY, this.__views__ = []
                    }

                    function lazyClone() {
                        var result = new LazyWrapper(this.__wrapped__);
                        return result.__actions__ = arrayCopy(this.__actions__), result.__dir__ = this.__dir__, result.__filtered__ = this.__filtered__, result.__iteratees__ = arrayCopy(this.__iteratees__), result.__takeCount__ = this.__takeCount__, result.__views__ = arrayCopy(this.__views__), result
                    }

                    function lazyReverse() {
                        if (this.__filtered__) {
                            var result = new LazyWrapper(this);
                            result.__dir__ = -1, result.__filtered__ = !0
                        } else result = this.clone(), result.__dir__ *= -1;
                        return result
                    }

                    function lazyValue() {
                        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = 0 > dir, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                        if (!isArr || LARGE_ARRAY_SIZE > arrLength || arrLength == length && takeCount == length)return baseWrapperValue(array, this.__actions__);
                        var result = [];
                        outer:for (; length-- && takeCount > resIndex;) {
                            index += dir;
                            for (var iterIndex = -1, value = array[index]; ++iterIndex < iterLength;) {
                                var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                                if (type == LAZY_MAP_FLAG)value = computed; else if (!computed) {
                                    if (type == LAZY_FILTER_FLAG)continue outer;
                                    break outer
                                }
                            }
                            result[resIndex++] = value
                        }
                        return result
                    }

                    function MapCache() {
                        this.__data__ = {}
                    }

                    function mapDelete(key) {
                        return this.has(key) && delete this.__data__[key]
                    }

                    function mapGet(key) {
                        return "__proto__" == key ? undefined : this.__data__[key]
                    }

                    function mapHas(key) {
                        return "__proto__" != key && hasOwnProperty.call(this.__data__, key)
                    }

                    function mapSet(key, value) {
                        return "__proto__" != key && (this.__data__[key] = value), this
                    }

                    function SetCache(values) {
                        var length = values ? values.length : 0;
                        for (this.data = {hash: nativeCreate(null), set: new Set}; length--;)this.push(values[length])
                    }

                    function cacheIndexOf(cache, value) {
                        var data = cache.data, result = "string" == typeof value || isObject(value) ? data.set.has(value) : data.hash[value];
                        return result ? 0 : -1
                    }

                    function cachePush(value) {
                        var data = this.data;
                        "string" == typeof value || isObject(value) ? data.set.add(value) : data.hash[value] = !0
                    }

                    function arrayConcat(array, other) {
                        for (var index = -1, length = array.length, othIndex = -1, othLength = other.length, result = Array(length + othLength); ++index < length;)result[index] = array[index];
                        for (; ++othIndex < othLength;)result[index++] = other[othIndex];
                        return result
                    }

                    function arrayCopy(source, array) {
                        var index = -1, length = source.length;
                        for (array || (array = Array(length)); ++index < length;)array[index] = source[index];
                        return array
                    }

                    function arrayEach(array, iteratee) {
                        for (var index = -1, length = array.length; ++index < length && iteratee(array[index], index, array) !== !1;);
                        return array
                    }

                    function arrayEachRight(array, iteratee) {
                        for (var length = array.length; length-- && iteratee(array[length], length, array) !== !1;);
                        return array
                    }

                    function arrayEvery(array, predicate) {
                        for (var index = -1, length = array.length; ++index < length;)if (!predicate(array[index], index, array))return !1;
                        return !0
                    }

                    function arrayExtremum(array, iteratee, comparator, exValue) {
                        for (var index = -1, length = array.length, computed = exValue, result = computed; ++index < length;) {
                            var value = array[index], current = +iteratee(value);
                            comparator(current, computed) && (computed = current, result = value)
                        }
                        return result
                    }

                    function arrayFilter(array, predicate) {
                        for (var index = -1, length = array.length, resIndex = -1, result = []; ++index < length;) {
                            var value = array[index];
                            predicate(value, index, array) && (result[++resIndex] = value)
                        }
                        return result
                    }

                    function arrayMap(array, iteratee) {
                        for (var index = -1, length = array.length, result = Array(length); ++index < length;)result[index] = iteratee(array[index], index, array);
                        return result
                    }

                    function arrayPush(array, values) {
                        for (var index = -1, length = values.length, offset = array.length; ++index < length;)array[offset + index] = values[index];
                        return array
                    }

                    function arrayReduce(array, iteratee, accumulator, initFromArray) {
                        var index = -1, length = array.length;
                        for (initFromArray && length && (accumulator = array[++index]); ++index < length;)accumulator = iteratee(accumulator, array[index], index, array);
                        return accumulator
                    }

                    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
                        var length = array.length;
                        for (initFromArray && length && (accumulator = array[--length]); length--;)accumulator = iteratee(accumulator, array[length], length, array);
                        return accumulator
                    }

                    function arraySome(array, predicate) {
                        for (var index = -1, length = array.length; ++index < length;)if (predicate(array[index], index, array))return !0;
                        return !1
                    }

                    function arraySum(array, iteratee) {
                        for (var length = array.length, result = 0; length--;)result += +iteratee(array[length]) || 0;
                        return result
                    }

                    function assignDefaults(objectValue, sourceValue) {
                        return objectValue === undefined ? sourceValue : objectValue
                    }

                    function assignOwnDefaults(objectValue, sourceValue, key, object) {
                        return objectValue !== undefined && hasOwnProperty.call(object, key) ? objectValue : sourceValue
                    }

                    function assignWith(object, source, customizer) {
                        for (var index = -1, props = keys(source), length = props.length; ++index < length;) {
                            var key = props[index], value = object[key], result = customizer(value, source[key], key, object, source);
                            (result === result ? result === value : value !== value) && (value !== undefined || key in object) || (object[key] = result)
                        }
                        return object
                    }

                    function baseAssign(object, source) {
                        return null == source ? object : baseCopy(source, keys(source), object)
                    }

                    function baseAt(collection, props) {
                        for (var index = -1, isNil = null == collection, isArr = !isNil && isArrayLike(collection), length = isArr ? collection.length : 0, propsLength = props.length, result = Array(propsLength); ++index < propsLength;) {
                            var key = props[index];
                            isArr ? result[index] = isIndex(key, length) ? collection[key] : undefined : result[index] = isNil ? undefined : collection[key]
                        }
                        return result
                    }

                    function baseCopy(source, props, object) {
                        object || (object = {});
                        for (var index = -1, length = props.length; ++index < length;) {
                            var key = props[index];
                            object[key] = source[key]
                        }
                        return object
                    }

                    function baseCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        return "function" == type ? thisArg === undefined ? func : bindCallback(func, thisArg, argCount) : null == func ? identity : "object" == type ? baseMatches(func) : thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg)
                    }

                    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
                        var result;
                        if (customizer && (result = object ? customizer(value, key, object) : customizer(value)), result !== undefined)return result;
                        if (!isObject(value))return value;
                        var isArr = isArray(value);
                        if (isArr) {
                            if (result = initCloneArray(value), !isDeep)return arrayCopy(value, result)
                        } else {
                            var tag = objToString.call(value), isFunc = tag == funcTag;
                            if (tag != objectTag && tag != argsTag && (!isFunc || object))return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : object ? value : {};
                            if (isHostObject(value))return object ? value : {};
                            if (result = initCloneObject(isFunc ? {} : value), !isDeep)return baseAssign(result, value)
                        }
                        stackA || (stackA = []), stackB || (stackB = []);
                        for (var length = stackA.length; length--;)if (stackA[length] == value)return stackB[length];
                        return stackA.push(value), stackB.push(result), (isArr ? arrayEach : baseForOwn)(value, function (subValue, key) {
                            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB)
                        }), result
                    }

                    function baseDelay(func, wait, args) {
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        return setTimeout(function () {
                            func.apply(undefined, args)
                        }, wait)
                    }

                    function baseDifference(array, values) {
                        var length = array ? array.length : 0, result = [];
                        if (!length)return result;
                        var index = -1, indexOf = getIndexOf(), isCommon = indexOf === baseIndexOf, cache = isCommon && values.length >= LARGE_ARRAY_SIZE ? createCache(values) : null, valuesLength = values.length;
                        cache && (indexOf = cacheIndexOf, isCommon = !1, values = cache);
                        outer:for (; ++index < length;) {
                            var value = array[index];
                            if (isCommon && value === value) {
                                for (var valuesIndex = valuesLength; valuesIndex--;)if (values[valuesIndex] === value)continue outer;
                                result.push(value)
                            } else indexOf(values, value, 0) < 0 && result.push(value)
                        }
                        return result
                    }

                    function baseEvery(collection, predicate) {
                        var result = !0;
                        return baseEach(collection, function (value, index, collection) {
                            return result = !!predicate(value, index, collection)
                        }), result
                    }

                    function baseExtremum(collection, iteratee, comparator, exValue) {
                        var computed = exValue, result = computed;
                        return baseEach(collection, function (value, index, collection) {
                            var current = +iteratee(value, index, collection);
                            (comparator(current, computed) || current === exValue && current === result) && (computed = current, result = value)
                        }), result
                    }

                    function baseFill(array, value, start, end) {
                        var length = array.length;
                        for (start = null == start ? 0 : +start || 0, 0 > start && (start = -start > length ? 0 : length + start), end = end === undefined || end > length ? length : +end || 0, 0 > end && (end += length), length = start > end ? 0 : end >>> 0, start >>>= 0; length > start;)array[start++] = value;
                        return array
                    }

                    function baseFilter(collection, predicate) {
                        var result = [];
                        return baseEach(collection, function (value, index, collection) {
                            predicate(value, index, collection) && result.push(value)
                        }), result
                    }

                    function baseFind(collection, predicate, eachFunc, retKey) {
                        var result;
                        return eachFunc(collection, function (value, key, collection) {
                            return predicate(value, key, collection) ? (result = retKey ? key : value, !1) : void 0
                        }), result
                    }

                    function baseFlatten(array, isDeep, isStrict, result) {
                        result || (result = []);
                        for (var index = -1, length = array.length; ++index < length;) {
                            var value = array[index];
                            isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value)) ? isDeep ? baseFlatten(value, isDeep, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value)
                        }
                        return result
                    }

                    function baseForIn(object, iteratee) {
                        return baseFor(object, iteratee, keysIn)
                    }

                    function baseForOwn(object, iteratee) {
                        return baseFor(object, iteratee, keys)
                    }

                    function baseForOwnRight(object, iteratee) {
                        return baseForRight(object, iteratee, keys)
                    }

                    function baseFunctions(object, props) {
                        for (var index = -1, length = props.length, resIndex = -1, result = []; ++index < length;) {
                            var key = props[index];
                            isFunction(object[key]) && (result[++resIndex] = key)
                        }
                        return result
                    }

                    function baseGet(object, path, pathKey) {
                        if (null != object) {
                            object = toObject(object), pathKey !== undefined && pathKey in object && (path = [pathKey]);
                            for (var index = 0, length = path.length; null != object && length > index;)object = toObject(object)[path[index++]];
                            return index && index == length ? object : undefined
                        }
                    }

                    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
                        return value === other ? !0 : null == value || null == other || !isObject(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB)
                    }

                    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
                        objIsArr || (objTag = objToString.call(object), objTag == argsTag ? objTag = objectTag : objTag != objectTag && (objIsArr = isTypedArray(object))), othIsArr || (othTag = objToString.call(other), othTag == argsTag ? othTag = objectTag : othTag != objectTag && (othIsArr = isTypedArray(other)));
                        var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
                        if (isSameTag && !objIsArr && !objIsObj)return equalByTag(object, other, objTag);
                        if (!isLoose) {
                            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                            if (objIsWrapped || othIsWrapped)return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB)
                        }
                        if (!isSameTag)return !1;
                        stackA || (stackA = []), stackB || (stackB = []);
                        for (var length = stackA.length; length--;)if (stackA[length] == object)return stackB[length] == other;
                        stackA.push(object), stackB.push(other);
                        var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
                        return stackA.pop(), stackB.pop(), result
                    }

                    function baseIsMatch(object, matchData, customizer) {
                        var index = matchData.length, length = index, noCustomizer = !customizer;
                        if (null == object)return !length;
                        for (object = toObject(object); index--;) {
                            var data = matchData[index];
                            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object))return !1
                        }
                        for (; ++index < length;) {
                            data = matchData[index];
                            var key = data[0], objValue = object[key], srcValue = data[1];
                            if (noCustomizer && data[2]) {
                                if (objValue === undefined && !(key in object))return !1
                            } else {
                                var result = customizer ? customizer(objValue, srcValue, key) : undefined;
                                if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, !0) : result))return !1
                            }
                        }
                        return !0
                    }

                    function baseMap(collection, iteratee) {
                        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
                        return baseEach(collection, function (value, key, collection) {
                            result[++index] = iteratee(value, key, collection)
                        }), result
                    }

                    function baseMatches(source) {
                        var matchData = getMatchData(source);
                        if (1 == matchData.length && matchData[0][2]) {
                            var key = matchData[0][0], value = matchData[0][1];
                            return function (object) {
                                return null == object ? !1 : (object = toObject(object), object[key] === value && (value !== undefined || key in object))
                            }
                        }
                        return function (object) {
                            return baseIsMatch(object, matchData)
                        }
                    }

                    function baseMatchesProperty(path, srcValue) {
                        var isArr = isArray(path), isCommon = isKey(path) && isStrictComparable(srcValue), pathKey = path + "";
                        return path = toPath(path), function (object) {
                            if (null == object)return !1;
                            var key = pathKey;
                            if (object = toObject(object), (isArr || !isCommon) && !(key in object)) {
                                if (object = 1 == path.length ? object : baseGet(object, baseSlice(path, 0, -1)), null == object)return !1;
                                key = last(path), object = toObject(object)
                            }
                            return object[key] === srcValue ? srcValue !== undefined || key in object : baseIsEqual(srcValue, object[key], undefined, !0)
                        }
                    }

                    function baseMerge(object, source, customizer, stackA, stackB) {
                        if (!isObject(object))return object;
                        var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)), props = isSrcArr ? undefined : keys(source);
                        return arrayEach(props || source, function (srcValue, key) {
                            if (props && (key = srcValue, srcValue = source[key]), isObjectLike(srcValue))stackA || (stackA = []), stackB || (stackB = []), baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB); else {
                                var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = result === undefined;
                                isCommon && (result = srcValue), result === undefined && (!isSrcArr || key in object) || !isCommon && (result === result ? result === value : value !== value) || (object[key] = result)
                            }
                        }), object
                    }

                    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
                        for (var length = stackA.length, srcValue = source[key]; length--;)if (stackA[length] == srcValue)return void(object[key] = stackB[length]);
                        var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = result === undefined;
                        isCommon && (result = srcValue, isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue)) ? result = isArray(value) ? value : isArrayLike(value) ? arrayCopy(value) : [] : isPlainObject(srcValue) || isArguments(srcValue) ? result = isArguments(value) ? toPlainObject(value) : isPlainObject(value) ? value : {} : isCommon = !1), stackA.push(srcValue), stackB.push(result), isCommon ? object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB) : (result === result ? result !== value : value === value) && (object[key] = result)
                    }

                    function baseProperty(key) {
                        return function (object) {
                            return null == object ? undefined : toObject(object)[key]
                        }
                    }

                    function basePropertyDeep(path) {
                        var pathKey = path + "";
                        return path = toPath(path), function (object) {
                            return baseGet(object, path, pathKey)
                        }
                    }

                    function basePullAt(array, indexes) {
                        for (var length = array ? indexes.length : 0; length--;) {
                            var index = indexes[length];
                            if (index != previous && isIndex(index)) {
                                var previous = index;
                                splice.call(array, index, 1)
                            }
                        }
                        return array
                    }

                    function baseRandom(min, max) {
                        return min + nativeFloor(nativeRandom() * (max - min + 1))
                    }

                    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
                        return eachFunc(collection, function (value, index, collection) {
                            accumulator = initFromCollection ? (initFromCollection = !1, value) : iteratee(accumulator, value, index, collection)
                        }), accumulator
                    }

                    function baseSlice(array, start, end) {
                        var index = -1, length = array.length;
                        start = null == start ? 0 : +start || 0, 0 > start && (start = -start > length ? 0 : length + start), end = end === undefined || end > length ? length : +end || 0, 0 > end && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
                        for (var result = Array(length); ++index < length;)result[index] = array[index + start];
                        return result
                    }

                    function baseSome(collection, predicate) {
                        var result;
                        return baseEach(collection, function (value, index, collection) {
                            return result = predicate(value, index, collection), !result
                        }), !!result
                    }

                    function baseSortBy(array, comparer) {
                        var length = array.length;
                        for (array.sort(comparer); length--;)array[length] = array[length].value;
                        return array
                    }

                    function baseSortByOrder(collection, iteratees, orders) {
                        var callback = getCallback(), index = -1;
                        iteratees = arrayMap(iteratees, function (iteratee) {
                            return callback(iteratee)
                        });
                        var result = baseMap(collection, function (value) {
                            var criteria = arrayMap(iteratees, function (iteratee) {
                                return iteratee(value)
                            });
                            return {criteria: criteria, index: ++index, value: value}
                        });
                        return baseSortBy(result, function (object, other) {
                            return compareMultiple(object, other, orders)
                        })
                    }

                    function baseSum(collection, iteratee) {
                        var result = 0;
                        return baseEach(collection, function (value, index, collection) {
                            result += +iteratee(value, index, collection) || 0
                        }), result
                    }

                    function baseUniq(array, iteratee) {
                        var index = -1, indexOf = getIndexOf(), length = array.length, isCommon = indexOf === baseIndexOf, isLarge = isCommon && length >= LARGE_ARRAY_SIZE, seen = isLarge ? createCache() : null, result = [];
                        seen ? (indexOf = cacheIndexOf, isCommon = !1) : (isLarge = !1, seen = iteratee ? [] : result);
                        outer:for (; ++index < length;) {
                            var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
                            if (isCommon && value === value) {
                                for (var seenIndex = seen.length; seenIndex--;)if (seen[seenIndex] === computed)continue outer;
                                iteratee && seen.push(computed), result.push(value)
                            } else indexOf(seen, computed, 0) < 0 && ((iteratee || isLarge) && seen.push(computed), result.push(value))
                        }
                        return result
                    }

                    function baseValues(object, props) {
                        for (var index = -1, length = props.length, result = Array(length); ++index < length;)result[index] = object[props[index]];
                        return result
                    }

                    function baseWhile(array, predicate, isDrop, fromRight) {
                        for (var length = array.length, index = fromRight ? length : -1; (fromRight ? index-- : ++index < length) && predicate(array[index], index, array););
                        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index)
                    }

                    function baseWrapperValue(value, actions) {
                        var result = value;
                        result instanceof LazyWrapper && (result = result.value());
                        for (var index = -1, length = actions.length; ++index < length;) {
                            var action = actions[index];
                            result = action.func.apply(action.thisArg, arrayPush([result], action.args))
                        }
                        return result
                    }

                    function binaryIndex(array, value, retHighest) {
                        var low = 0, high = array ? array.length : low;
                        if ("number" == typeof value && value === value && HALF_MAX_ARRAY_LENGTH >= high) {
                            for (; high > low;) {
                                var mid = low + high >>> 1, computed = array[mid];
                                (retHighest ? value >= computed : value > computed) && null !== computed ? low = mid + 1 : high = mid
                            }
                            return high
                        }
                        return binaryIndexBy(array, value, identity, retHighest)
                    }

                    function binaryIndexBy(array, value, iteratee, retHighest) {
                        value = iteratee(value);
                        for (var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsNull = null === value, valIsUndef = value === undefined; high > low;) {
                            var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), isDef = computed !== undefined, isReflexive = computed === computed;
                            if (valIsNaN)var setLow = isReflexive || retHighest; else setLow = valIsNull ? isReflexive && isDef && (retHighest || null != computed) : valIsUndef ? isReflexive && (retHighest || isDef) : null == computed ? !1 : retHighest ? value >= computed : value > computed;
                            setLow ? low = mid + 1 : high = mid
                        }
                        return nativeMin(high, MAX_ARRAY_INDEX)
                    }

                    function bindCallback(func, thisArg, argCount) {
                        if ("function" != typeof func)return identity;
                        if (thisArg === undefined)return func;
                        switch (argCount) {
                            case 1:
                                return function (value) {
                                    return func.call(thisArg, value)
                                };
                            case 3:
                                return function (value, index, collection) {
                                    return func.call(thisArg, value, index, collection)
                                };
                            case 4:
                                return function (accumulator, value, index, collection) {
                                    return func.call(thisArg, accumulator, value, index, collection)
                                };
                            case 5:
                                return function (value, other, key, object, source) {
                                    return func.call(thisArg, value, other, key, object, source)
                                }
                        }
                        return function () {
                            return func.apply(thisArg, arguments)
                        }
                    }

                    function bufferClone(buffer) {
                        var result = new ArrayBuffer(buffer.byteLength), view = new Uint8Array(result);
                        return view.set(new Uint8Array(buffer)), result
                    }

                    function composeArgs(args, partials, holders) {
                        for (var holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), leftIndex = -1, leftLength = partials.length, result = Array(leftLength + argsLength); ++leftIndex < leftLength;)result[leftIndex] = partials[leftIndex];
                        for (; ++argsIndex < holdersLength;)result[holders[argsIndex]] = args[argsIndex];
                        for (; argsLength--;)result[leftIndex++] = args[argsIndex++];
                        return result
                    }

                    function composeArgsRight(args, partials, holders) {
                        for (var holdersIndex = -1, holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), rightIndex = -1, rightLength = partials.length, result = Array(argsLength + rightLength); ++argsIndex < argsLength;)result[argsIndex] = args[argsIndex];
                        for (var offset = argsIndex; ++rightIndex < rightLength;)result[offset + rightIndex] = partials[rightIndex];
                        for (; ++holdersIndex < holdersLength;)result[offset + holders[holdersIndex]] = args[argsIndex++];
                        return result
                    }

                    function createAggregator(setter, initializer) {
                        return function (collection, iteratee, thisArg) {
                            var result = initializer ? initializer() : {};
                            if (iteratee = getCallback(iteratee, thisArg, 3), isArray(collection))for (var index = -1, length = collection.length; ++index < length;) {
                                var value = collection[index];
                                setter(result, value, iteratee(value, index, collection), collection)
                            } else baseEach(collection, function (value, key, collection) {
                                setter(result, value, iteratee(value, key, collection), collection)
                            });
                            return result
                        }
                    }

                    function createAssigner(assigner) {
                        return restParam(function (object, sources) {
                            var index = -1, length = null == object ? 0 : sources.length, customizer = length > 2 ? sources[length - 2] : undefined, guard = length > 2 ? sources[2] : undefined, thisArg = length > 1 ? sources[length - 1] : undefined;
                            for ("function" == typeof customizer ? (customizer = bindCallback(customizer, thisArg, 5), length -= 2) : (customizer = "function" == typeof thisArg ? thisArg : undefined, length -= customizer ? 1 : 0), guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = 3 > length ? undefined : customizer, length = 1); ++index < length;) {
                                var source = sources[index];
                                source && assigner(object, source, customizer)
                            }
                            return object
                        })
                    }

                    function createBaseEach(eachFunc, fromRight) {
                        return function (collection, iteratee) {
                            var length = collection ? getLength(collection) : 0;
                            if (!isLength(length))return eachFunc(collection, iteratee);
                            for (var index = fromRight ? length : -1, iterable = toObject(collection); (fromRight ? index-- : ++index < length) && iteratee(iterable[index], index, iterable) !== !1;);
                            return collection
                        }
                    }

                    function createBaseFor(fromRight) {
                        return function (object, iteratee, keysFunc) {
                            for (var iterable = toObject(object), props = keysFunc(object), length = props.length, index = fromRight ? length : -1; fromRight ? index-- : ++index < length;) {
                                var key = props[index];
                                if (iteratee(iterable[key], key, iterable) === !1)break
                            }
                            return object
                        }
                    }

                    function createBindWrapper(func, thisArg) {
                        function wrapper() {
                            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                            return fn.apply(thisArg, arguments)
                        }

                        var Ctor = createCtorWrapper(func);
                        return wrapper
                    }

                    function createCache(values) {
                        return nativeCreate && Set ? new SetCache(values) : null
                    }

                    function createCompounder(callback) {
                        return function (string) {
                            for (var index = -1, array = words(deburr(string)), length = array.length, result = ""; ++index < length;)result = callback(result, array[index], index);
                            return result
                        }
                    }

                    function createCtorWrapper(Ctor) {
                        return function () {
                            var args = arguments;
                            switch (args.length) {
                                case 0:
                                    return new Ctor;
                                case 1:
                                    return new Ctor(args[0]);
                                case 2:
                                    return new Ctor(args[0], args[1]);
                                case 3:
                                    return new Ctor(args[0], args[1], args[2]);
                                case 4:
                                    return new Ctor(args[0], args[1], args[2], args[3]);
                                case 5:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                                case 6:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                                case 7:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6])
                            }
                            var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                            return isObject(result) ? result : thisBinding
                        }
                    }

                    function createCurry(flag) {
                        function curryFunc(func, arity, guard) {
                            guard && isIterateeCall(func, arity, guard) && (arity = undefined);
                            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
                            return result.placeholder = curryFunc.placeholder, result
                        }

                        return curryFunc
                    }

                    function createDefaults(assigner, customizer) {
                        return restParam(function (args) {
                            var object = args[0];
                            return null == object ? object : (args.push(customizer), assigner.apply(undefined, args))
                        })
                    }

                    function createExtremum(comparator, exValue) {
                        return function (collection, iteratee, thisArg) {
                            if (thisArg && isIterateeCall(collection, iteratee, thisArg) && (iteratee = undefined), iteratee = getCallback(iteratee, thisArg, 3), 1 == iteratee.length) {
                                collection = isArray(collection) ? collection : toIterable(collection);
                                var result = arrayExtremum(collection, iteratee, comparator, exValue);
                                if (!collection.length || result !== exValue)return result
                            }
                            return baseExtremum(collection, iteratee, comparator, exValue)
                        }
                    }

                    function createFind(eachFunc, fromRight) {
                        return function (collection, predicate, thisArg) {
                            if (predicate = getCallback(predicate, thisArg, 3), isArray(collection)) {
                                var index = baseFindIndex(collection, predicate, fromRight);
                                return index > -1 ? collection[index] : undefined
                            }
                            return baseFind(collection, predicate, eachFunc)
                        }
                    }

                    function createFindIndex(fromRight) {
                        return function (array, predicate, thisArg) {
                            return array && array.length ? (predicate = getCallback(predicate, thisArg, 3), baseFindIndex(array, predicate, fromRight)) : -1
                        }
                    }

                    function createFindKey(objectFunc) {
                        return function (object, predicate, thisArg) {
                            return predicate = getCallback(predicate, thisArg, 3), baseFind(object, predicate, objectFunc, !0)
                        }
                    }

                    function createFlow(fromRight) {
                        return function () {
                            for (var wrapper, length = arguments.length, index = fromRight ? length : -1, leftIndex = 0, funcs = Array(length); fromRight ? index-- : ++index < length;) {
                                var func = funcs[leftIndex++] = arguments[index];
                                if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                                !wrapper && LodashWrapper.prototype.thru && "wrapper" == getFuncName(func) && (wrapper = new LodashWrapper([], !0))
                            }
                            for (index = wrapper ? -1 : length; ++index < length;) {
                                func = funcs[index];
                                var funcName = getFuncName(func), data = "wrapper" == funcName ? getData(func) : undefined;
                                wrapper = data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && 1 == data[9] ? wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func)
                            }
                            return function () {
                                var args = arguments, value = args[0];
                                if (wrapper && 1 == args.length && isArray(value) && value.length >= LARGE_ARRAY_SIZE)return wrapper.plant(value).value();
                                for (var index = 0, result = length ? funcs[index].apply(this, args) : value; ++index < length;)result = funcs[index].call(this, result);
                                return result
                            }
                        }
                    }

                    function createForEach(arrayFunc, eachFunc) {
                        return function (collection, iteratee, thisArg) {
                            return "function" == typeof iteratee && thisArg === undefined && isArray(collection) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3))
                        }
                    }

                    function createForIn(objectFunc) {
                        return function (object, iteratee, thisArg) {
                            return "function" == typeof iteratee && thisArg === undefined || (iteratee = bindCallback(iteratee, thisArg, 3)), objectFunc(object, iteratee, keysIn)
                        }
                    }

                    function createForOwn(objectFunc) {
                        return function (object, iteratee, thisArg) {
                            return "function" == typeof iteratee && thisArg === undefined || (iteratee = bindCallback(iteratee, thisArg, 3)), objectFunc(object, iteratee)
                        }
                    }

                    function createObjectMapper(isMapKeys) {
                        return function (object, iteratee, thisArg) {
                            var result = {};
                            return iteratee = getCallback(iteratee, thisArg, 3), baseForOwn(object, function (value, key, object) {
                                var mapped = iteratee(value, key, object);
                                key = isMapKeys ? mapped : key, value = isMapKeys ? value : mapped, result[key] = value
                            }), result
                        }
                    }

                    function createPadDir(fromRight) {
                        return function (string, length, chars) {
                            return string = baseToString(string), (fromRight ? string : "") + createPadding(string, length, chars) + (fromRight ? "" : string)
                        }
                    }

                    function createPartial(flag) {
                        var partialFunc = restParam(function (func, partials) {
                            var holders = replaceHolders(partials, partialFunc.placeholder);
                            return createWrapper(func, flag, undefined, partials, holders)
                        });
                        return partialFunc
                    }

                    function createReduce(arrayFunc, eachFunc) {
                        return function (collection, iteratee, accumulator, thisArg) {
                            var initFromArray = arguments.length < 3;
                            return "function" == typeof iteratee && thisArg === undefined && isArray(collection) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc)
                        }
                    }

                    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                        function wrapper() {
                            for (var length = arguments.length, index = length, args = Array(length); index--;)args[index] = arguments[index];
                            if (partials && (args = composeArgs(args, partials, holders)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight)), isCurry || isCurryRight) {
                                var placeholder = wrapper.placeholder, argsHolders = replaceHolders(args, placeholder);
                                if (length -= argsHolders.length, arity > length) {
                                    var newArgPos = argPos ? arrayCopy(argPos) : undefined, newArity = nativeMax(arity - length, 0), newsHolders = isCurry ? argsHolders : undefined, newHoldersRight = isCurry ? undefined : argsHolders, newPartials = isCurry ? args : undefined, newPartialsRight = isCurry ? undefined : args;
                                    bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG, bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG), isCurryBound || (bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG));
                                    var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity], result = createHybridWrapper.apply(undefined, newData);
                                    return isLaziable(func) && setData(result, newData), result.placeholder = placeholder, result
                                }
                            }
                            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                            return argPos && (args = reorder(args, argPos)), isAry && ary < args.length && (args.length = ary), this && this !== root && this instanceof wrapper && (fn = Ctor || createCtorWrapper(func)), fn.apply(thisBinding, args)
                        }

                        var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurry = bitmask & CURRY_FLAG, isCurryBound = bitmask & CURRY_BOUND_FLAG, isCurryRight = bitmask & CURRY_RIGHT_FLAG, Ctor = isBindKey ? undefined : createCtorWrapper(func);
                        return wrapper
                    }

                    function createPadding(string, length, chars) {
                        var strLength = string.length;
                        if (length = +length, strLength >= length || !nativeIsFinite(length))return "";
                        var padLength = length - strLength;
                        return chars = null == chars ? " " : chars + "", repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength)
                    }

                    function createPartialWrapper(func, bitmask, thisArg, partials) {
                        function wrapper() {
                            for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength); ++leftIndex < leftLength;)args[leftIndex] = partials[leftIndex];
                            for (; argsLength--;)args[leftIndex++] = arguments[++argsIndex];
                            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                            return fn.apply(isBind ? thisArg : this, args)
                        }

                        var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
                        return wrapper
                    }

                    function createRound(methodName) {
                        var func = Math[methodName];
                        return function (number, precision) {
                            return precision = precision === undefined ? 0 : +precision || 0, precision ? (precision = pow(10, precision), func(number * precision) / precision) : func(number)
                        }
                    }

                    function createSortedIndex(retHighest) {
                        return function (array, value, iteratee, thisArg) {
                            var callback = getCallback(iteratee);
                            return null == iteratee && callback === baseCallback ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest)
                        }
                    }

                    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                        var isBindKey = bitmask & BIND_KEY_FLAG;
                        if (!isBindKey && "function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        var length = partials ? partials.length : 0;
                        if (length || (bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG), partials = holders = undefined), length -= holders ? holders.length : 0, bitmask & PARTIAL_RIGHT_FLAG) {
                            var partialsRight = partials, holdersRight = holders;
                            partials = holders = undefined
                        }
                        var data = isBindKey ? undefined : getData(func), newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
                        if (data && (mergeData(newData, data), bitmask = newData[1], arity = newData[9]), newData[9] = null == arity ? isBindKey ? 0 : func.length : nativeMax(arity - length, 0) || 0, bitmask == BIND_FLAG)var result = createBindWrapper(newData[0], newData[2]); else result = bitmask != PARTIAL_FLAG && bitmask != (BIND_FLAG | PARTIAL_FLAG) || newData[4].length ? createHybridWrapper.apply(undefined, newData) : createPartialWrapper.apply(undefined, newData);
                        var setter = data ? baseSetData : setData;
                        return setter(result, newData)
                    }

                    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var index = -1, arrLength = array.length, othLength = other.length;
                        if (arrLength != othLength && !(isLoose && othLength > arrLength))return !1;
                        for (; ++index < arrLength;) {
                            var arrValue = array[index], othValue = other[index], result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
                            if (result !== undefined) {
                                if (result)continue;
                                return !1
                            }
                            if (isLoose) {
                                if (!arraySome(other, function (othValue) {
                                        return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB)
                                    }))return !1
                            } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))return !1
                        }
                        return !0
                    }

                    function equalByTag(object, other, tag) {
                        switch (tag) {
                            case boolTag:
                            case dateTag:
                                return +object == +other;
                            case errorTag:
                                return object.name == other.name && object.message == other.message;
                            case numberTag:
                                return object != +object ? other != +other : object == +other;
                            case regexpTag:
                            case stringTag:
                                return object == other + ""
                        }
                        return !1
                    }

                    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
                        if (objLength != othLength && !isLoose)return !1;
                        for (var index = objLength; index--;) {
                            var key = objProps[index];
                            if (!(isLoose ? key in other : hasOwnProperty.call(other, key)))return !1
                        }
                        for (var skipCtor = isLoose; ++index < objLength;) {
                            key = objProps[index];
                            var objValue = object[key], othValue = other[key], result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;
                            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result))return !1;
                            skipCtor || (skipCtor = "constructor" == key)
                        }
                        if (!skipCtor) {
                            var objCtor = object.constructor, othCtor = other.constructor;
                            if (objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor))return !1
                        }
                        return !0
                    }

                    function getCallback(func, thisArg, argCount) {
                        var result = lodash.callback || callback;
                        return result = result === callback ? baseCallback : result, argCount ? result(func, thisArg, argCount) : result
                    }

                    function getFuncName(func) {
                        for (var result = func.name + "", array = realNames[result], length = array ? array.length : 0; length--;) {
                            var data = array[length], otherFunc = data.func;
                            if (null == otherFunc || otherFunc == func)return data.name
                        }
                        return result
                    }

                    function getIndexOf(collection, target, fromIndex) {
                        var result = lodash.indexOf || indexOf;
                        return result = result === indexOf ? baseIndexOf : result, collection ? result(collection, target, fromIndex) : result
                    }

                    function getMatchData(object) {
                        for (var result = pairs(object), length = result.length; length--;)result[length][2] = isStrictComparable(result[length][1]);
                        return result
                    }

                    function getNative(object, key) {
                        var value = null == object ? undefined : object[key];
                        return isNative(value) ? value : undefined
                    }

                    function getView(start, end, transforms) {
                        for (var index = -1, length = transforms.length; ++index < length;) {
                            var data = transforms[index], size = data.size;
                            switch (data.type) {
                                case"drop":
                                    start += size;
                                    break;
                                case"dropRight":
                                    end -= size;
                                    break;
                                case"take":
                                    end = nativeMin(end, start + size);
                                    break;
                                case"takeRight":
                                    start = nativeMax(start, end - size)
                            }
                        }
                        return {start: start, end: end}
                    }

                    function initCloneArray(array) {
                        var length = array.length, result = new array.constructor(length);
                        return length && "string" == typeof array[0] && hasOwnProperty.call(array, "index") && (result.index = array.index, result.input = array.input), result
                    }

                    function initCloneObject(object) {
                        var Ctor = object.constructor;
                        return "function" == typeof Ctor && Ctor instanceof Ctor || (Ctor = Object), new Ctor
                    }

                    function initCloneByTag(object, tag, isDeep) {
                        var Ctor = object.constructor;
                        switch (tag) {
                            case arrayBufferTag:
                                return bufferClone(object);
                            case boolTag:
                            case dateTag:
                                return new Ctor(+object);
                            case float32Tag:
                            case float64Tag:
                            case int8Tag:
                            case int16Tag:
                            case int32Tag:
                            case uint8Tag:
                            case uint8ClampedTag:
                            case uint16Tag:
                            case uint32Tag:
                                Ctor instanceof Ctor && (Ctor = ctorByTag[tag]);
                                var buffer = object.buffer;
                                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
                            case numberTag:
                            case stringTag:
                                return new Ctor(object);
                            case regexpTag:
                                var result = new Ctor(object.source, reFlags.exec(object));
                                result.lastIndex = object.lastIndex
                        }
                        return result
                    }

                    function invokePath(object, path, args) {
                        null == object || isKey(path, object) || (path = toPath(path), object = 1 == path.length ? object : baseGet(object, baseSlice(path, 0, -1)), path = last(path));
                        var func = null == object ? object : object[path];
                        return null == func ? undefined : func.apply(object, args)
                    }

                    function isArrayLike(value) {
                        return null != value && isLength(getLength(value))
                    }

                    function isIndex(value, length) {
                        return value = "number" == typeof value || reIsUint.test(value) ? +value : -1, length = null == length ? MAX_SAFE_INTEGER : length, value > -1 && value % 1 == 0 && length > value
                    }

                    function isIterateeCall(value, index, object) {
                        if (!isObject(object))return !1;
                        var type = typeof index;
                        if ("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) {
                            var other = object[index];
                            return value === value ? value === other : other !== other
                        }
                        return !1
                    }

                    function isKey(value, object) {
                        var type = typeof value;
                        if ("string" == type && reIsPlainProp.test(value) || "number" == type)return !0;
                        if (isArray(value))return !1;
                        var result = !reIsDeepProp.test(value);
                        return result || null != object && value in toObject(object)
                    }

                    function isLaziable(func) {
                        var funcName = getFuncName(func), other = lodash[funcName];
                        if ("function" != typeof other || !(funcName in LazyWrapper.prototype))return !1;
                        if (func === other)return !0;
                        var data = getData(other);
                        return !!data && func === data[0]
                    }

                    function isLength(value) {
                        return "number" == typeof value && value > -1 && value % 1 == 0 && MAX_SAFE_INTEGER >= value
                    }

                    function isStrictComparable(value) {
                        return value === value && !isObject(value)
                    }

                    function mergeData(data, source) {
                        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = ARY_FLAG > newBitmask, isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG;
                        if (!isCommon && !isCombo)return data;
                        srcBitmask & BIND_FLAG && (data[2] = source[2], newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG);
                        var value = source[3];
                        if (value) {
                            var partials = data[3];
                            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value), data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4])
                        }
                        return value = source[5], value && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value), data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6])), value = source[7], value && (data[7] = arrayCopy(value)), srcBitmask & ARY_FLAG && (data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8])), null == data[9] && (data[9] = source[9]), data[0] = source[0], data[1] = newBitmask, data
                    }

                    function mergeDefaults(objectValue, sourceValue) {
                        return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults)
                    }

                    function pickByArray(object, props) {
                        object = toObject(object);
                        for (var index = -1, length = props.length, result = {}; ++index < length;) {
                            var key = props[index];
                            key in object && (result[key] = object[key])
                        }
                        return result
                    }

                    function pickByCallback(object, predicate) {
                        var result = {};
                        return baseForIn(object, function (value, key, object) {
                            predicate(value, key, object) && (result[key] = value)
                        }), result
                    }

                    function reorder(array, indexes) {
                        for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = arrayCopy(array); length--;) {
                            var index = indexes[length];
                            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined
                        }
                        return array
                    }

                    function shimKeys(object) {
                        for (var props = keysIn(object), propsLength = props.length, length = propsLength && object.length, allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object) || isString(object)), index = -1, result = []; ++index < propsLength;) {
                            var key = props[index];
                            (allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) && result.push(key)
                        }
                        return result
                    }

                    function toIterable(value) {
                        return null == value ? [] : isArrayLike(value) ? lodash.support.unindexedChars && isString(value) ? value.split("") : isObject(value) ? value : Object(value) : values(value)
                    }

                    function toObject(value) {
                        if (lodash.support.unindexedChars && isString(value)) {
                            for (var index = -1, length = value.length, result = Object(value); ++index < length;)result[index] = value.charAt(index);
                            return result
                        }
                        return isObject(value) ? value : Object(value)
                    }

                    function toPath(value) {
                        if (isArray(value))return value;
                        var result = [];
                        return baseToString(value).replace(rePropName, function (match, number, quote, string) {
                            result.push(quote ? string.replace(reEscapeChar, "$1") : number || match)
                        }), result
                    }

                    function wrapperClone(wrapper) {
                        return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__))
                    }

                    function chunk(array, size, guard) {
                        size = (guard ? isIterateeCall(array, size, guard) : null == size) ? 1 : nativeMax(nativeFloor(size) || 1, 1);
                        for (var index = 0, length = array ? array.length : 0, resIndex = -1, result = Array(nativeCeil(length / size)); length > index;)result[++resIndex] = baseSlice(array, index, index += size);
                        return result
                    }

                    function compact(array) {
                        for (var index = -1, length = array ? array.length : 0, resIndex = -1, result = []; ++index < length;) {
                            var value = array[index];
                            value && (result[++resIndex] = value)
                        }
                        return result
                    }

                    function drop(array, n, guard) {
                        var length = array ? array.length : 0;
                        return length ? ((guard ? isIterateeCall(array, n, guard) : null == n) && (n = 1), baseSlice(array, 0 > n ? 0 : n)) : []
                    }

                    function dropRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        return length ? ((guard ? isIterateeCall(array, n, guard) : null == n) && (n = 1), n = length - (+n || 0), baseSlice(array, 0, 0 > n ? 0 : n)) : []
                    }

                    function dropRightWhile(array, predicate, thisArg) {
                        return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), !0, !0) : []
                    }

                    function dropWhile(array, predicate, thisArg) {
                        return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), !0) : []
                    }

                    function fill(array, value, start, end) {
                        var length = array ? array.length : 0;
                        return length ? (start && "number" != typeof start && isIterateeCall(array, value, start) && (start = 0, end = length), baseFill(array, value, start, end)) : []
                    }

                    function first(array) {
                        return array ? array[0] : undefined
                    }

                    function flatten(array, isDeep, guard) {
                        var length = array ? array.length : 0;
                        return guard && isIterateeCall(array, isDeep, guard) && (isDeep = !1), length ? baseFlatten(array, isDeep) : []
                    }

                    function flattenDeep(array) {
                        var length = array ? array.length : 0;
                        return length ? baseFlatten(array, !0) : []
                    }

                    function indexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        if (!length)return -1;
                        if ("number" == typeof fromIndex)fromIndex = 0 > fromIndex ? nativeMax(length + fromIndex, 0) : fromIndex; else if (fromIndex) {
                            var index = binaryIndex(array, value);
                            return length > index && (value === value ? value === array[index] : array[index] !== array[index]) ? index : -1
                        }
                        return baseIndexOf(array, value, fromIndex || 0)
                    }

                    function initial(array) {
                        return dropRight(array, 1)
                    }

                    function last(array) {
                        var length = array ? array.length : 0;
                        return length ? array[length - 1] : undefined
                    }

                    function lastIndexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        if (!length)return -1;
                        var index = length;
                        if ("number" == typeof fromIndex)index = (0 > fromIndex ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1; else if (fromIndex) {
                            index = binaryIndex(array, value, !0) - 1;
                            var other = array[index];
                            return (value === value ? value === other : other !== other) ? index : -1
                        }
                        if (value !== value)return indexOfNaN(array, index, !0);
                        for (; index--;)if (array[index] === value)return index;
                        return -1
                    }

                    function pull() {
                        var args = arguments, array = args[0];
                        if (!array || !array.length)return array;
                        for (var index = 0, indexOf = getIndexOf(), length = args.length; ++index < length;)for (var fromIndex = 0, value = args[index]; (fromIndex = indexOf(array, value, fromIndex)) > -1;)splice.call(array, fromIndex, 1);
                        return array
                    }

                    function remove(array, predicate, thisArg) {
                        var result = [];
                        if (!array || !array.length)return result;
                        var index = -1, indexes = [], length = array.length;
                        for (predicate = getCallback(predicate, thisArg, 3); ++index < length;) {
                            var value = array[index];
                            predicate(value, index, array) && (result.push(value), indexes.push(index))
                        }
                        return basePullAt(array, indexes), result
                    }

                    function rest(array) {
                        return drop(array, 1)
                    }

                    function slice(array, start, end) {
                        var length = array ? array.length : 0;
                        return length ? (end && "number" != typeof end && isIterateeCall(array, start, end) && (start = 0, end = length), baseSlice(array, start, end)) : []
                    }

                    function take(array, n, guard) {
                        var length = array ? array.length : 0;
                        return length ? ((guard ? isIterateeCall(array, n, guard) : null == n) && (n = 1), baseSlice(array, 0, 0 > n ? 0 : n)) : []
                    }

                    function takeRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        return length ? ((guard ? isIterateeCall(array, n, guard) : null == n) && (n = 1), n = length - (+n || 0), baseSlice(array, 0 > n ? 0 : n)) : []
                    }

                    function takeRightWhile(array, predicate, thisArg) {
                        return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), !1, !0) : []
                    }

                    function takeWhile(array, predicate, thisArg) {
                        return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3)) : []
                    }

                    function uniq(array, isSorted, iteratee, thisArg) {
                        var length = array ? array.length : 0;
                        if (!length)return [];
                        null != isSorted && "boolean" != typeof isSorted && (thisArg = iteratee, iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted, isSorted = !1);
                        var callback = getCallback();
                        return null == iteratee && callback === baseCallback || (iteratee = callback(iteratee, thisArg, 3)), isSorted && getIndexOf() === baseIndexOf ? sortedUniq(array, iteratee) : baseUniq(array, iteratee)
                    }

                    function unzip(array) {
                        if (!array || !array.length)return [];
                        var index = -1, length = 0;
                        array = arrayFilter(array, function (group) {
                            return isArrayLike(group) ? (length = nativeMax(group.length, length), !0) : void 0
                        });
                        for (var result = Array(length); ++index < length;)result[index] = arrayMap(array, baseProperty(index));
                        return result
                    }

                    function unzipWith(array, iteratee, thisArg) {
                        var length = array ? array.length : 0;
                        if (!length)return [];
                        var result = unzip(array);
                        return null == iteratee ? result : (iteratee = bindCallback(iteratee, thisArg, 4), arrayMap(result, function (group) {
                            return arrayReduce(group, iteratee, undefined, !0)
                        }))
                    }

                    function xor() {
                        for (var index = -1, length = arguments.length; ++index < length;) {
                            var array = arguments[index];
                            if (isArrayLike(array))var result = result ? arrayPush(baseDifference(result, array), baseDifference(array, result)) : array
                        }
                        return result ? baseUniq(result) : []
                    }

                    function zipObject(props, values) {
                        var index = -1, length = props ? props.length : 0, result = {};
                        for (!length || values || isArray(props[0]) || (values = []); ++index < length;) {
                            var key = props[index];
                            values ? result[key] = values[index] : key && (result[key[0]] = key[1])
                        }
                        return result
                    }

                    function chain(value) {
                        var result = lodash(value);
                        return result.__chain__ = !0, result
                    }

                    function tap(value, interceptor, thisArg) {
                        return interceptor.call(thisArg, value), value
                    }

                    function thru(value, interceptor, thisArg) {
                        return interceptor.call(thisArg, value)
                    }

                    function wrapperChain() {
                        return chain(this)
                    }

                    function wrapperCommit() {
                        return new LodashWrapper(this.value(), this.__chain__)
                    }

                    function wrapperPlant(value) {
                        for (var result, parent = this; parent instanceof baseLodash;) {
                            var clone = wrapperClone(parent);
                            result ? previous.__wrapped__ = clone : result = clone;
                            var previous = clone;
                            parent = parent.__wrapped__
                        }
                        return previous.__wrapped__ = value, result
                    }

                    function wrapperReverse() {
                        var value = this.__wrapped__, interceptor = function (value) {
                            return value.reverse()
                        };
                        if (value instanceof LazyWrapper) {
                            var wrapped = value;
                            return this.__actions__.length && (wrapped = new LazyWrapper(this)), wrapped = wrapped.reverse(), wrapped.__actions__.push({
                                func: thru,
                                args: [interceptor],
                                thisArg: undefined
                            }), new LodashWrapper(wrapped, this.__chain__)
                        }
                        return this.thru(interceptor)
                    }

                    function wrapperToString() {
                        return this.value() + ""
                    }

                    function wrapperValue() {
                        return baseWrapperValue(this.__wrapped__, this.__actions__)
                    }

                    function every(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayEvery : baseEvery;
                        return thisArg && isIterateeCall(collection, predicate, thisArg) && (predicate = undefined), "function" == typeof predicate && thisArg === undefined || (predicate = getCallback(predicate, thisArg, 3)), func(collection, predicate)
                    }

                    function filter(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        return predicate = getCallback(predicate, thisArg, 3), func(collection, predicate)
                    }

                    function findWhere(collection, source) {
                        return find(collection, baseMatches(source))
                    }

                    function includes(collection, target, fromIndex, guard) {
                        var length = collection ? getLength(collection) : 0;
                        return isLength(length) || (collection = values(collection), length = collection.length), fromIndex = "number" != typeof fromIndex || guard && isIterateeCall(target, fromIndex, guard) ? 0 : 0 > fromIndex ? nativeMax(length + fromIndex, 0) : fromIndex || 0, "string" == typeof collection || !isArray(collection) && isString(collection) ? length >= fromIndex && collection.indexOf(target, fromIndex) > -1 : !!length && getIndexOf(collection, target, fromIndex) > -1
                    }

                    function map(collection, iteratee, thisArg) {
                        var func = isArray(collection) ? arrayMap : baseMap;
                        return iteratee = getCallback(iteratee, thisArg, 3), func(collection, iteratee)
                    }

                    function pluck(collection, path) {
                        return map(collection, property(path))
                    }

                    function reject(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        return predicate = getCallback(predicate, thisArg, 3), func(collection, function (value, index, collection) {
                            return !predicate(value, index, collection)
                        })
                    }

                    function sample(collection, n, guard) {
                        if (guard ? isIterateeCall(collection, n, guard) : null == n) {
                            collection = toIterable(collection);
                            var length = collection.length;
                            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined
                        }
                        var index = -1, result = toArray(collection), length = result.length, lastIndex = length - 1;
                        for (n = nativeMin(0 > n ? 0 : +n || 0, length); ++index < n;) {
                            var rand = baseRandom(index, lastIndex), value = result[rand];
                            result[rand] = result[index], result[index] = value
                        }
                        return result.length = n, result
                    }

                    function shuffle(collection) {
                        return sample(collection, POSITIVE_INFINITY)
                    }

                    function size(collection) {
                        var length = collection ? getLength(collection) : 0;
                        return isLength(length) ? length : keys(collection).length
                    }

                    function some(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arraySome : baseSome;
                        return thisArg && isIterateeCall(collection, predicate, thisArg) && (predicate = undefined), "function" == typeof predicate && thisArg === undefined || (predicate = getCallback(predicate, thisArg, 3)), func(collection, predicate)
                    }

                    function sortBy(collection, iteratee, thisArg) {
                        if (null == collection)return [];
                        thisArg && isIterateeCall(collection, iteratee, thisArg) && (iteratee = undefined);
                        var index = -1;
                        iteratee = getCallback(iteratee, thisArg, 3);
                        var result = baseMap(collection, function (value, key, collection) {
                            return {criteria: iteratee(value, key, collection), index: ++index, value: value}
                        });
                        return baseSortBy(result, compareAscending)
                    }

                    function sortByOrder(collection, iteratees, orders, guard) {
                        return null == collection ? [] : (guard && isIterateeCall(iteratees, orders, guard) && (orders = undefined), isArray(iteratees) || (iteratees = null == iteratees ? [] : [iteratees]), isArray(orders) || (orders = null == orders ? [] : [orders]), baseSortByOrder(collection, iteratees, orders))
                    }

                    function where(collection, source) {
                        return filter(collection, baseMatches(source))
                    }

                    function after(n, func) {
                        if ("function" != typeof func) {
                            if ("function" != typeof n)throw new TypeError(FUNC_ERROR_TEXT);
                            var temp = n;
                            n = func, func = temp
                        }
                        return n = nativeIsFinite(n = +n) ? n : 0, function () {
                            return --n < 1 ? func.apply(this, arguments) : void 0
                        }
                    }

                    function ary(func, n, guard) {
                        return guard && isIterateeCall(func, n, guard) && (n = undefined), n = func && null == n ? func.length : nativeMax(+n || 0, 0), createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n)
                    }

                    function before(n, func) {
                        var result;
                        if ("function" != typeof func) {
                            if ("function" != typeof n)throw new TypeError(FUNC_ERROR_TEXT);
                            var temp = n;
                            n = func, func = temp
                        }
                        return function () {
                            return --n > 0 && (result = func.apply(this, arguments)), 1 >= n && (func = undefined), result
                        }
                    }

                    function debounce(func, wait, options) {
                        function cancel() {
                            timeoutId && clearTimeout(timeoutId), maxTimeoutId && clearTimeout(maxTimeoutId), lastCalled = 0, maxTimeoutId = timeoutId = trailingCall = undefined
                        }

                        function complete(isCalled, id) {
                            id && clearTimeout(id), maxTimeoutId = timeoutId = trailingCall = undefined, isCalled && (lastCalled = now(), result = func.apply(thisArg, args), timeoutId || maxTimeoutId || (args = thisArg = undefined))
                        }

                        function delayed() {
                            var remaining = wait - (now() - stamp);
                            0 >= remaining || remaining > wait ? complete(trailingCall, maxTimeoutId) : timeoutId = setTimeout(delayed, remaining)
                        }

                        function maxDelayed() {
                            complete(trailing, timeoutId)
                        }

                        function debounced() {
                            if (args = arguments, stamp = now(), thisArg = this, trailingCall = trailing && (timeoutId || !leading), maxWait === !1)var leadingCall = leading && !timeoutId; else {
                                maxTimeoutId || leading || (lastCalled = stamp);
                                var remaining = maxWait - (stamp - lastCalled), isCalled = 0 >= remaining || remaining > maxWait;
                                isCalled ? (maxTimeoutId && (maxTimeoutId = clearTimeout(maxTimeoutId)), lastCalled = stamp, result = func.apply(thisArg, args)) : maxTimeoutId || (maxTimeoutId = setTimeout(maxDelayed, remaining))
                            }
                            return isCalled && timeoutId ? timeoutId = clearTimeout(timeoutId) : timeoutId || wait === maxWait || (timeoutId = setTimeout(delayed, wait)), leadingCall && (isCalled = !0, result = func.apply(thisArg, args)), !isCalled || timeoutId || maxTimeoutId || (args = thisArg = undefined), result
                        }

                        var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = !1, trailing = !0;
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        if (wait = 0 > wait ? 0 : +wait || 0, options === !0) {
                            var leading = !0;
                            trailing = !1
                        } else isObject(options) && (leading = !!options.leading, maxWait = "maxWait" in options && nativeMax(+options.maxWait || 0, wait), trailing = "trailing" in options ? !!options.trailing : trailing);
                        return debounced.cancel = cancel, debounced
                    }

                    function memoize(func, resolver) {
                        if ("function" != typeof func || resolver && "function" != typeof resolver)throw new TypeError(FUNC_ERROR_TEXT);
                        var memoized = function () {
                            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                            if (cache.has(key))return cache.get(key);
                            var result = func.apply(this, args);
                            return memoized.cache = cache.set(key, result), result
                        };
                        return memoized.cache = new memoize.Cache, memoized
                    }

                    function negate(predicate) {
                        if ("function" != typeof predicate)throw new TypeError(FUNC_ERROR_TEXT);
                        return function () {
                            return !predicate.apply(this, arguments)
                        }
                    }

                    function once(func) {
                        return before(2, func)
                    }

                    function restParam(func, start) {
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        return start = nativeMax(start === undefined ? func.length - 1 : +start || 0, 0), function () {
                            for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), rest = Array(length); ++index < length;)rest[index] = args[start + index];
                            switch (start) {
                                case 0:
                                    return func.call(this, rest);
                                case 1:
                                    return func.call(this, args[0], rest);
                                case 2:
                                    return func.call(this, args[0], args[1], rest)
                            }
                            var otherArgs = Array(start + 1);
                            for (index = -1; ++index < start;)otherArgs[index] = args[index];
                            return otherArgs[start] = rest, func.apply(this, otherArgs)
                        }
                    }

                    function spread(func) {
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        return function (array) {
                            return func.apply(this, array)
                        }
                    }

                    function throttle(func, wait, options) {
                        var leading = !0, trailing = !0;
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        return options === !1 ? leading = !1 : isObject(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce(func, wait, {
                            leading: leading,
                            maxWait: +wait,
                            trailing: trailing
                        })
                    }

                    function wrap(value, wrapper) {
                        return wrapper = null == wrapper ? identity : wrapper, createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], [])
                    }

                    function clone(value, isDeep, customizer, thisArg) {
                        return isDeep && "boolean" != typeof isDeep && isIterateeCall(value, isDeep, customizer) ? isDeep = !1 : "function" == typeof isDeep && (thisArg = customizer, customizer = isDeep, isDeep = !1), "function" == typeof customizer ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 3)) : baseClone(value, isDeep)
                    }

                    function cloneDeep(value, customizer, thisArg) {
                        return "function" == typeof customizer ? baseClone(value, !0, bindCallback(customizer, thisArg, 3)) : baseClone(value, !0)
                    }

                    function gt(value, other) {
                        return value > other
                    }

                    function gte(value, other) {
                        return value >= other
                    }

                    function isArguments(value) {
                        return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee")
                    }

                    function isBoolean(value) {
                        return value === !0 || value === !1 || isObjectLike(value) && objToString.call(value) == boolTag
                    }

                    function isDate(value) {
                        return isObjectLike(value) && objToString.call(value) == dateTag
                    }

                    function isElement(value) {
                        return !!value && 1 === value.nodeType && isObjectLike(value) && !isPlainObject(value)
                    }

                    function isEmpty(value) {
                        return null == value ? !0 : isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || isObjectLike(value) && isFunction(value.splice)) ? !value.length : !keys(value).length
                    }

                    function isEqual(value, other, customizer, thisArg) {
                        customizer = "function" == typeof customizer ? bindCallback(customizer, thisArg, 3) : undefined;
                        var result = customizer ? customizer(value, other) : undefined;
                        return result === undefined ? baseIsEqual(value, other, customizer) : !!result
                    }

                    function isError(value) {
                        return isObjectLike(value) && "string" == typeof value.message && objToString.call(value) == errorTag
                    }

                    function isFinite(value) {
                        return "number" == typeof value && nativeIsFinite(value)
                    }

                    function isFunction(value) {
                        return isObject(value) && objToString.call(value) == funcTag
                    }

                    function isObject(value) {
                        var type = typeof value;
                        return !!value && ("object" == type || "function" == type)
                    }

                    function isMatch(object, source, customizer, thisArg) {
                        return customizer = "function" == typeof customizer ? bindCallback(customizer, thisArg, 3) : undefined, baseIsMatch(object, getMatchData(source), customizer)
                    }

                    function isNaN(value) {
                        return isNumber(value) && value != +value
                    }

                    function isNative(value) {
                        return null == value ? !1 : isFunction(value) ? reIsNative.test(fnToString.call(value)) : isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value)
                    }

                    function isNull(value) {
                        return null === value
                    }

                    function isNumber(value) {
                        return "number" == typeof value || isObjectLike(value) && objToString.call(value) == numberTag
                    }

                    function isPlainObject(value) {
                        var Ctor;
                        if (!isObjectLike(value) || objToString.call(value) != objectTag || isHostObject(value) || isArguments(value) || !hasOwnProperty.call(value, "constructor") && (Ctor = value.constructor, "function" == typeof Ctor && !(Ctor instanceof Ctor)))return !1;
                        var result;
                        return lodash.support.ownLast ? (baseForIn(value, function (subValue, key, object) {
                            return result = hasOwnProperty.call(object, key), !1
                        }), result !== !1) : (baseForIn(value, function (subValue, key) {
                            result = key
                        }), result === undefined || hasOwnProperty.call(value, result))
                    }

                    function isRegExp(value) {
                        return isObject(value) && objToString.call(value) == regexpTag
                    }

                    function isString(value) {
                        return "string" == typeof value || isObjectLike(value) && objToString.call(value) == stringTag
                    }

                    function isTypedArray(value) {
                        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)]
                    }

                    function isUndefined(value) {
                        return value === undefined
                    }

                    function lt(value, other) {
                        return other > value
                    }

                    function lte(value, other) {
                        return other >= value
                    }

                    function toArray(value) {
                        var length = value ? getLength(value) : 0;
                        return isLength(length) ? length ? lodash.support.unindexedChars && isString(value) ? value.split("") : arrayCopy(value) : [] : values(value)
                    }

                    function toPlainObject(value) {
                        return baseCopy(value, keysIn(value))
                    }

                    function create(prototype, properties, guard) {
                        var result = baseCreate(prototype);
                        return guard && isIterateeCall(prototype, properties, guard) && (properties = undefined), properties ? baseAssign(result, properties) : result
                    }

                    function functions(object) {
                        return baseFunctions(object, keysIn(object))
                    }

                    function get(object, path, defaultValue) {
                        var result = null == object ? undefined : baseGet(object, toPath(path), path + "");
                        return result === undefined ? defaultValue : result
                    }

                    function has(object, path) {
                        if (null == object)return !1;
                        var result = hasOwnProperty.call(object, path);
                        if (!result && !isKey(path)) {
                            if (path = toPath(path), object = 1 == path.length ? object : baseGet(object, baseSlice(path, 0, -1)), null == object)return !1;
                            path = last(path), result = hasOwnProperty.call(object, path)
                        }
                        return result || isLength(object.length) && isIndex(path, object.length) && (isArray(object) || isArguments(object) || isString(object))
                    }

                    function invert(object, multiValue, guard) {
                        guard && isIterateeCall(object, multiValue, guard) && (multiValue = undefined);
                        for (var index = -1, props = keys(object), length = props.length, result = {}; ++index < length;) {
                            var key = props[index], value = object[key];
                            multiValue ? hasOwnProperty.call(result, value) ? result[value].push(key) : result[value] = [key] : result[value] = key
                        }
                        return result
                    }

                    function keysIn(object) {
                        if (null == object)return [];
                        isObject(object) || (object = Object(object));
                        var length = object.length, support = lodash.support;
                        length = length && isLength(length) && (isArray(object) || isArguments(object) || isString(object)) && length || 0;
                        for (var Ctor = object.constructor, index = -1, proto = isFunction(Ctor) && Ctor.prototype || objectProto, isProto = proto === object, result = Array(length), skipIndexes = length > 0, skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error), skipProto = support.enumPrototypes && isFunction(object); ++index < length;)result[index] = index + "";
                        for (var key in object)skipProto && "prototype" == key || skipErrorProps && ("message" == key || "name" == key) || skipIndexes && isIndex(key, length) || "constructor" == key && (isProto || !hasOwnProperty.call(object, key)) || result.push(key);
                        if (support.nonEnumShadows && object !== objectProto) {
                            var tag = object === stringProto ? stringTag : object === errorProto ? errorTag : objToString.call(object), nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];
                            for (tag == objectTag && (proto = objectProto), length = shadowProps.length; length--;) {
                                key = shadowProps[length];
                                var nonEnum = nonEnums[key];
                                isProto && nonEnum || (nonEnum ? !hasOwnProperty.call(object, key) : object[key] === proto[key]) || result.push(key)
                            }
                        }
                        return result
                    }

                    function pairs(object) {
                        object = toObject(object);
                        for (var index = -1, props = keys(object), length = props.length, result = Array(length); ++index < length;) {
                            var key = props[index];
                            result[index] = [key, object[key]]
                        }
                        return result
                    }

                    function result(object, path, defaultValue) {
                        var result = null == object ? undefined : toObject(object)[path];
                        return result === undefined && (null == object || isKey(path, object) || (path = toPath(path), object = 1 == path.length ? object : baseGet(object, baseSlice(path, 0, -1)), result = null == object ? undefined : toObject(object)[last(path)]), result = result === undefined ? defaultValue : result), isFunction(result) ? result.call(object) : result
                    }

                    function set(object, path, value) {
                        if (null == object)return object;
                        var pathKey = path + "";
                        path = null != object[pathKey] || isKey(path, object) ? [pathKey] : toPath(path);
                        for (var index = -1, length = path.length, lastIndex = length - 1, nested = object; null != nested && ++index < length;) {
                            var key = path[index];
                            isObject(nested) && (index == lastIndex ? nested[key] = value : null == nested[key] && (nested[key] = isIndex(path[index + 1]) ? [] : {})), nested = nested[key]
                        }
                        return object
                    }

                    function transform(object, iteratee, accumulator, thisArg) {
                        var isArr = isArray(object) || isTypedArray(object);
                        if (iteratee = getCallback(iteratee, thisArg, 4), null == accumulator)if (isArr || isObject(object)) {
                            var Ctor = object.constructor;
                            accumulator = isArr ? isArray(object) ? new Ctor : [] : baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined)
                        } else accumulator = {};
                        return (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
                            return iteratee(accumulator, value, index, object)
                        }), accumulator
                    }

                    function values(object) {
                        return baseValues(object, keys(object))
                    }

                    function valuesIn(object) {
                        return baseValues(object, keysIn(object))
                    }

                    function inRange(value, start, end) {
                        return start = +start || 0, end === undefined ? (end = start, start = 0) : end = +end || 0, value >= nativeMin(start, end) && value < nativeMax(start, end)
                    }

                    function random(min, max, floating) {
                        floating && isIterateeCall(min, max, floating) && (max = floating = undefined);
                        var noMin = null == min, noMax = null == max;
                        if (null == floating && (noMax && "boolean" == typeof min ? (floating = min, min = 1) : "boolean" == typeof max && (floating = max, noMax = !0)), noMin && noMax && (max = 1, noMax = !1), min = +min || 0, noMax ? (max = min, min = 0) : max = +max || 0, floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max)
                        }
                        return baseRandom(min, max)
                    }

                    function capitalize(string) {
                        return string = baseToString(string), string && string.charAt(0).toUpperCase() + string.slice(1)
                    }

                    function deburr(string) {
                        return string = baseToString(string), string && string.replace(reLatin1, deburrLetter).replace(reComboMark, "")
                    }

                    function endsWith(string, target, position) {
                        string = baseToString(string), target += "";
                        var length = string.length;
                        return position = position === undefined ? length : nativeMin(0 > position ? 0 : +position || 0, length), position -= target.length, position >= 0 && string.indexOf(target, position) == position
                    }

                    function escape(string) {
                        return string = baseToString(string), string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string
                    }

                    function escapeRegExp(string) {
                        return string = baseToString(string), string && reHasRegExpChars.test(string) ? string.replace(reRegExpChars, escapeRegExpChar) : string || "(?:)"
                    }

                    function pad(string, length, chars) {
                        string = baseToString(string), length = +length;
                        var strLength = string.length;
                        if (strLength >= length || !nativeIsFinite(length))return string;
                        var mid = (length - strLength) / 2, leftLength = nativeFloor(mid), rightLength = nativeCeil(mid);
                        return chars = createPadding("", rightLength, chars), chars.slice(0, leftLength) + string + chars
                    }

                    function parseInt(string, radix, guard) {
                        return (guard ? isIterateeCall(string, radix, guard) : null == radix) ? radix = 0 : radix && (radix = +radix), string = trim(string), nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10))
                    }

                    function repeat(string, n) {
                        var result = "";
                        if (string = baseToString(string), n = +n, 1 > n || !string || !nativeIsFinite(n))return result;
                        do n % 2 && (result += string), n = nativeFloor(n / 2), string += string; while (n);
                        return result
                    }

                    function startsWith(string, target, position) {
                        return string = baseToString(string), position = null == position ? 0 : nativeMin(0 > position ? 0 : +position || 0, string.length), string.lastIndexOf(target, position) == position
                    }

                    function template(string, options, otherOptions) {
                        var settings = lodash.templateSettings;
                        otherOptions && isIterateeCall(string, options, otherOptions) && (options = otherOptions = undefined), string = baseToString(string), options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
                        var isEscaping, isEvaluating, imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys), index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '", reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g"), sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                        string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            return interpolateValue || (interpolateValue = esTemplateValue), source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar), escapeValue && (isEscaping = !0, source += "' +\n__e(" + escapeValue + ") +\n'"), evaluateValue && (isEvaluating = !0, source += "';\n" + evaluateValue + ";\n__p += '"), interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"), index = offset + match.length, match
                        }), source += "';\n";
                        var variable = options.variable;
                        variable || (source = "with (obj) {\n" + source + "\n}\n"), source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var result = attempt(function () {
                            return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues)
                        });
                        if (result.source = source, isError(result))throw result;
                        return result
                    }

                    function trim(string, chars, guard) {
                        var value = string;
                        return (string = baseToString(string)) ? (guard ? isIterateeCall(value, chars, guard) : null == chars) ? string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1) : (chars += "", string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1)) : string
                    }

                    function trimLeft(string, chars, guard) {
                        var value = string;
                        return string = baseToString(string), string ? (guard ? isIterateeCall(value, chars, guard) : null == chars) ? string.slice(trimmedLeftIndex(string)) : string.slice(charsLeftIndex(string, chars + "")) : string
                    }

                    function trimRight(string, chars, guard) {
                        var value = string;
                        return string = baseToString(string), string ? (guard ? isIterateeCall(value, chars, guard) : null == chars) ? string.slice(0, trimmedRightIndex(string) + 1) : string.slice(0, charsRightIndex(string, chars + "") + 1) : string
                    }

                    function trunc(string, options, guard) {
                        guard && isIterateeCall(string, options, guard) && (options = undefined);
                        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                        if (null != options)if (isObject(options)) {
                            var separator = "separator" in options ? options.separator : separator;
                            length = "length" in options ? +options.length || 0 : length, omission = "omission" in options ? baseToString(options.omission) : omission
                        } else length = +options || 0;
                        if (string = baseToString(string), length >= string.length)return string;
                        var end = length - omission.length;
                        if (1 > end)return omission;
                        var result = string.slice(0, end);
                        if (null == separator)return result + omission;
                        if (isRegExp(separator)) {
                            if (string.slice(end).search(separator)) {
                                var match, newEnd, substring = string.slice(0, end);
                                for (separator.global || (separator = RegExp(separator.source, (reFlags.exec(separator) || "") + "g")), separator.lastIndex = 0; match = separator.exec(substring);)newEnd = match.index;
                                result = result.slice(0, null == newEnd ? end : newEnd)
                            }
                        } else if (string.indexOf(separator, end) != end) {
                            var index = result.lastIndexOf(separator);
                            index > -1 && (result = result.slice(0, index))
                        }
                        return result + omission
                    }

                    function unescape(string) {
                        return string = baseToString(string), string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string
                    }

                    function words(string, pattern, guard) {
                        return guard && isIterateeCall(string, pattern, guard) && (pattern = undefined),
                            string = baseToString(string), string.match(pattern || reWords) || []
                    }

                    function callback(func, thisArg, guard) {
                        return guard && isIterateeCall(func, thisArg, guard) && (thisArg = undefined), isObjectLike(func) ? matches(func) : baseCallback(func, thisArg)
                    }

                    function constant(value) {
                        return function () {
                            return value
                        }
                    }

                    function identity(value) {
                        return value
                    }

                    function matches(source) {
                        return baseMatches(baseClone(source, !0))
                    }

                    function matchesProperty(path, srcValue) {
                        return baseMatchesProperty(path, baseClone(srcValue, !0))
                    }

                    function mixin(object, source, options) {
                        if (null == options) {
                            var isObj = isObject(source), props = isObj ? keys(source) : undefined, methodNames = props && props.length ? baseFunctions(source, props) : undefined;
                            (methodNames ? methodNames.length : isObj) || (methodNames = !1, options = source, source = object, object = this)
                        }
                        methodNames || (methodNames = baseFunctions(source, keys(source)));
                        var chain = !0, index = -1, isFunc = isFunction(object), length = methodNames.length;
                        options === !1 ? chain = !1 : isObject(options) && "chain" in options && (chain = options.chain);
                        for (; ++index < length;) {
                            var methodName = methodNames[index], func = source[methodName];
                            object[methodName] = func, isFunc && (object.prototype[methodName] = function (func) {
                                return function () {
                                    var chainAll = this.__chain__;
                                    if (chain || chainAll) {
                                        var result = object(this.__wrapped__), actions = result.__actions__ = arrayCopy(this.__actions__);
                                        return actions.push({
                                            func: func,
                                            args: arguments,
                                            thisArg: object
                                        }), result.__chain__ = chainAll, result
                                    }
                                    return func.apply(object, arrayPush([this.value()], arguments))
                                }
                            }(func))
                        }
                        return object
                    }

                    function noConflict() {
                        return root._ = oldDash, this
                    }

                    function noop() {
                    }

                    function property(path) {
                        return isKey(path) ? baseProperty(path) : basePropertyDeep(path)
                    }

                    function propertyOf(object) {
                        return function (path) {
                            return baseGet(object, toPath(path), path + "")
                        }
                    }

                    function range(start, end, step) {
                        step && isIterateeCall(start, end, step) && (end = step = undefined), start = +start || 0, step = null == step ? 1 : +step || 0, null == end ? (end = start, start = 0) : end = +end || 0;
                        for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); ++index < length;)result[index] = start, start += step;
                        return result
                    }

                    function times(n, iteratee, thisArg) {
                        if (n = nativeFloor(n), 1 > n || !nativeIsFinite(n))return [];
                        var index = -1, result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
                        for (iteratee = bindCallback(iteratee, thisArg, 1); ++index < n;)MAX_ARRAY_LENGTH > index ? result[index] = iteratee(index) : iteratee(index);
                        return result
                    }

                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return baseToString(prefix) + id
                    }

                    function add(augend, addend) {
                        return (+augend || 0) + (+addend || 0)
                    }

                    function sum(collection, iteratee, thisArg) {
                        return thisArg && isIterateeCall(collection, iteratee, thisArg) && (iteratee = undefined), iteratee = getCallback(iteratee, thisArg, 3), 1 == iteratee.length ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee) : baseSum(collection, iteratee)
                    }

                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
                    var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError, arrayProto = Array.prototype, errorProto = Error.prototype, objectProto = Object.prototype, stringProto = String.prototype, fnToString = Function.prototype.toString, hasOwnProperty = objectProto.hasOwnProperty, idCounter = 0, objToString = objectProto.toString, oldDash = root._, reIsNative = RegExp("^" + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), ArrayBuffer = context.ArrayBuffer, clearTimeout = context.clearTimeout, parseFloat = context.parseFloat, pow = Math.pow, propertyIsEnumerable = objectProto.propertyIsEnumerable, Set = getNative(context, "Set"), setTimeout = context.setTimeout, splice = arrayProto.splice, Uint8Array = context.Uint8Array, WeakMap = getNative(context, "WeakMap"), nativeCeil = Math.ceil, nativeCreate = getNative(Object, "create"), nativeFloor = Math.floor, nativeIsArray = getNative(Array, "isArray"), nativeIsFinite = context.isFinite, nativeKeys = getNative(Object, "keys"), nativeMax = Math.max, nativeMin = Math.min, nativeNow = getNative(Date, "now"), nativeParseInt = context.parseInt, nativeRandom = Math.random, NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, POSITIVE_INFINITY = Number.POSITIVE_INFINITY, MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1, MAX_SAFE_INTEGER = 9007199254740991, metaMap = WeakMap && new WeakMap, realNames = {}, ctorByTag = {};
                    ctorByTag[float32Tag] = context.Float32Array, ctorByTag[float64Tag] = context.Float64Array, ctorByTag[int8Tag] = context.Int8Array, ctorByTag[int16Tag] = context.Int16Array, ctorByTag[int32Tag] = context.Int32Array, ctorByTag[uint8Tag] = Uint8Array, ctorByTag[uint8ClampedTag] = context.Uint8ClampedArray, ctorByTag[uint16Tag] = context.Uint16Array, ctorByTag[uint32Tag] = context.Uint32Array;
                    var nonEnumProps = {};
                    nonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = {
                        constructor: !0,
                        toLocaleString: !0,
                        toString: !0,
                        valueOf: !0
                    }, nonEnumProps[boolTag] = nonEnumProps[stringTag] = {
                        constructor: !0,
                        toString: !0,
                        valueOf: !0
                    }, nonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = {
                        constructor: !0,
                        toString: !0
                    }, nonEnumProps[objectTag] = {constructor: !0}, arrayEach(shadowProps, function (key) {
                        for (var tag in nonEnumProps)if (hasOwnProperty.call(nonEnumProps, tag)) {
                            var props = nonEnumProps[tag];
                            props[key] = hasOwnProperty.call(props, key)
                        }
                    });
                    var support = lodash.support = {};
                    !function (x) {
                        var Ctor = function () {
                            this.x = x
                        }, object = {0: x, length: x}, props = [];
                        Ctor.prototype = {valueOf: x, y: x};
                        for (var key in new Ctor)props.push(key);
                        support.enumErrorProps = propertyIsEnumerable.call(errorProto, "message") || propertyIsEnumerable.call(errorProto, "name"), support.enumPrototypes = propertyIsEnumerable.call(Ctor, "prototype"), support.nonEnumShadows = !/valueOf/.test(props), support.ownLast = "x" != props[0], support.spliceObjects = (splice.call(object, 0, 1), !object[0]), support.unindexedChars = "x"[0] + Object("x")[0] != "xx"
                    }(1, 0), lodash.templateSettings = {
                        escape: reEscape,
                        evaluate: reEvaluate,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {_: lodash}
                    };
                    var baseCreate = function () {
                        function object() {
                        }

                        return function (prototype) {
                            if (isObject(prototype)) {
                                object.prototype = prototype;
                                var result = new object;
                                object.prototype = undefined
                            }
                            return result || {}
                        }
                    }(), baseEach = createBaseEach(baseForOwn), baseEachRight = createBaseEach(baseForOwnRight, !0), baseFor = createBaseFor(), baseForRight = createBaseFor(!0), baseSetData = metaMap ? function (func, data) {
                        return metaMap.set(func, data), func
                    } : identity, getData = metaMap ? function (func) {
                        return metaMap.get(func)
                    } : noop, getLength = baseProperty("length"), setData = function () {
                        var count = 0, lastCalled = 0;
                        return function (key, value) {
                            var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
                            if (lastCalled = stamp, remaining > 0) {
                                if (++count >= HOT_COUNT)return key
                            } else count = 0;
                            return baseSetData(key, value)
                        }
                    }(), difference = restParam(function (array, values) {
                        return isObjectLike(array) && isArrayLike(array) ? baseDifference(array, baseFlatten(values, !1, !0)) : []
                    }), findIndex = createFindIndex(), findLastIndex = createFindIndex(!0), intersection = restParam(function (arrays) {
                        for (var othLength = arrays.length, othIndex = othLength, caches = Array(length), indexOf = getIndexOf(), isCommon = indexOf === baseIndexOf, result = []; othIndex--;) {
                            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
                            caches[othIndex] = isCommon && value.length >= 120 ? createCache(othIndex && value) : null
                        }
                        var array = arrays[0], index = -1, length = array ? array.length : 0, seen = caches[0];
                        outer:for (; ++index < length;)if (value = array[index], (seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                            for (var othIndex = othLength; --othIndex;) {
                                var cache = caches[othIndex];
                                if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0)continue outer
                            }
                            seen && seen.push(value), result.push(value)
                        }
                        return result
                    }), pullAt = restParam(function (array, indexes) {
                        indexes = baseFlatten(indexes);
                        var result = baseAt(array, indexes);
                        return basePullAt(array, indexes.sort(baseCompareAscending)), result
                    }), sortedIndex = createSortedIndex(), sortedLastIndex = createSortedIndex(!0), union = restParam(function (arrays) {
                        return baseUniq(baseFlatten(arrays, !1, !0))
                    }), without = restParam(function (array, values) {
                        return isArrayLike(array) ? baseDifference(array, values) : []
                    }), zip = restParam(unzip), zipWith = restParam(function (arrays) {
                        var length = arrays.length, iteratee = length > 2 ? arrays[length - 2] : undefined, thisArg = length > 1 ? arrays[length - 1] : undefined;
                        return length > 2 && "function" == typeof iteratee ? length -= 2 : (iteratee = length > 1 && "function" == typeof thisArg ? (--length, thisArg) : undefined, thisArg = undefined), arrays.length = length, unzipWith(arrays, iteratee, thisArg)
                    }), wrapperConcat = restParam(function (values) {
                        return values = baseFlatten(values), this.thru(function (array) {
                            return arrayConcat(isArray(array) ? array : [toObject(array)], values)
                        })
                    }), at = restParam(function (collection, props) {
                        return isArrayLike(collection) && (collection = toIterable(collection)), baseAt(collection, baseFlatten(props))
                    }), countBy = createAggregator(function (result, value, key) {
                        hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1
                    }), find = createFind(baseEach), findLast = createFind(baseEachRight, !0), forEach = createForEach(arrayEach, baseEach), forEachRight = createForEach(arrayEachRight, baseEachRight), groupBy = createAggregator(function (result, value, key) {
                        hasOwnProperty.call(result, key) ? result[key].push(value) : result[key] = [value]
                    }), indexBy = createAggregator(function (result, value, key) {
                        result[key] = value
                    }), invoke = restParam(function (collection, path, args) {
                        var index = -1, isFunc = "function" == typeof path, isProp = isKey(path), result = isArrayLike(collection) ? Array(collection.length) : [];
                        return baseEach(collection, function (value) {
                            var func = isFunc ? path : isProp && null != value ? value[path] : undefined;
                            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args)
                        }), result
                    }), partition = createAggregator(function (result, value, key) {
                        result[key ? 0 : 1].push(value)
                    }, function () {
                        return [[], []]
                    }), reduce = createReduce(arrayReduce, baseEach), reduceRight = createReduce(arrayReduceRight, baseEachRight), sortByAll = restParam(function (collection, iteratees) {
                        if (null == collection)return [];
                        var guard = iteratees[2];
                        return guard && isIterateeCall(iteratees[0], iteratees[1], guard) && (iteratees.length = 1), baseSortByOrder(collection, baseFlatten(iteratees), [])
                    }), now = nativeNow || function () {
                            return (new Date).getTime()
                        }, bind = restParam(function (func, thisArg, partials) {
                        var bitmask = BIND_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, bind.placeholder);
                            bitmask |= PARTIAL_FLAG
                        }
                        return createWrapper(func, bitmask, thisArg, partials, holders)
                    }), bindAll = restParam(function (object, methodNames) {
                        methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
                        for (var index = -1, length = methodNames.length; ++index < length;) {
                            var key = methodNames[index];
                            object[key] = createWrapper(object[key], BIND_FLAG, object)
                        }
                        return object
                    }), bindKey = restParam(function (object, key, partials) {
                        var bitmask = BIND_FLAG | BIND_KEY_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, bindKey.placeholder);
                            bitmask |= PARTIAL_FLAG
                        }
                        return createWrapper(key, bitmask, object, partials, holders)
                    }), curry = createCurry(CURRY_FLAG), curryRight = createCurry(CURRY_RIGHT_FLAG), defer = restParam(function (func, args) {
                        return baseDelay(func, 1, args)
                    }), delay = restParam(function (func, wait, args) {
                        return baseDelay(func, wait, args)
                    }), flow = createFlow(), flowRight = createFlow(!0), modArgs = restParam(function (func, transforms) {
                        if (transforms = baseFlatten(transforms), "function" != typeof func || !arrayEvery(transforms, baseIsFunction))throw new TypeError(FUNC_ERROR_TEXT);
                        var length = transforms.length;
                        return restParam(function (args) {
                            for (var index = nativeMin(args.length, length); index--;)args[index] = transforms[index](args[index]);
                            return func.apply(this, args)
                        })
                    }), partial = createPartial(PARTIAL_FLAG), partialRight = createPartial(PARTIAL_RIGHT_FLAG), rearg = restParam(function (func, indexes) {
                        return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes))
                    }), isArray = nativeIsArray || function (value) {
                            return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag
                        }, merge = createAssigner(baseMerge), assign = createAssigner(function (object, source, customizer) {
                        return customizer ? assignWith(object, source, customizer) : baseAssign(object, source)
                    }), defaults = createDefaults(assign, assignDefaults), defaultsDeep = createDefaults(merge, mergeDefaults), findKey = createFindKey(baseForOwn), findLastKey = createFindKey(baseForOwnRight), forIn = createForIn(baseFor), forInRight = createForIn(baseForRight), forOwn = createForOwn(baseForOwn), forOwnRight = createForOwn(baseForOwnRight), keys = nativeKeys ? function (object) {
                        var Ctor = null == object ? undefined : object.constructor;
                        return "function" == typeof Ctor && Ctor.prototype === object || ("function" == typeof object ? lodash.support.enumPrototypes : isArrayLike(object)) ? shimKeys(object) : isObject(object) ? nativeKeys(object) : []
                    } : shimKeys, mapKeys = createObjectMapper(!0), mapValues = createObjectMapper(), omit = restParam(function (object, props) {
                        if (null == object)return {};
                        if ("function" != typeof props[0]) {
                            var props = arrayMap(baseFlatten(props), String);
                            return pickByArray(object, baseDifference(keysIn(object), props))
                        }
                        var predicate = bindCallback(props[0], props[1], 3);
                        return pickByCallback(object, function (value, key, object) {
                            return !predicate(value, key, object)
                        })
                    }), pick = restParam(function (object, props) {
                        return null == object ? {} : "function" == typeof props[0] ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props))
                    }), camelCase = createCompounder(function (result, word, index) {
                        return word = word.toLowerCase(), result + (index ? word.charAt(0).toUpperCase() + word.slice(1) : word)
                    }), kebabCase = createCompounder(function (result, word, index) {
                        return result + (index ? "-" : "") + word.toLowerCase()
                    }), padLeft = createPadDir(), padRight = createPadDir(!0), snakeCase = createCompounder(function (result, word, index) {
                        return result + (index ? "_" : "") + word.toLowerCase()
                    }), startCase = createCompounder(function (result, word, index) {
                        return result + (index ? " " : "") + (word.charAt(0).toUpperCase() + word.slice(1))
                    }), attempt = restParam(function (func, args) {
                        try {
                            return func.apply(undefined, args)
                        } catch (e) {
                            return isError(e) ? e : new Error(e)
                        }
                    }), method = restParam(function (path, args) {
                        return function (object) {
                            return invokePath(object, path, args)
                        }
                    }), methodOf = restParam(function (object, args) {
                        return function (path) {
                            return invokePath(object, path, args)
                        }
                    }), ceil = createRound("ceil"), floor = createRound("floor"), max = createExtremum(gt, NEGATIVE_INFINITY), min = createExtremum(lt, POSITIVE_INFINITY), round = createRound("round");
                    return lodash.prototype = baseLodash.prototype, LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper, LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper, MapCache.prototype["delete"] = mapDelete, MapCache.prototype.get = mapGet, MapCache.prototype.has = mapHas, MapCache.prototype.set = mapSet, SetCache.prototype.push = cachePush, memoize.Cache = MapCache, lodash.after = after, lodash.ary = ary, lodash.assign = assign, lodash.at = at, lodash.before = before, lodash.bind = bind, lodash.bindAll = bindAll, lodash.bindKey = bindKey, lodash.callback = callback, lodash.chain = chain, lodash.chunk = chunk, lodash.compact = compact, lodash.constant = constant, lodash.countBy = countBy, lodash.create = create, lodash.curry = curry, lodash.curryRight = curryRight, lodash.debounce = debounce, lodash.defaults = defaults, lodash.defaultsDeep = defaultsDeep, lodash.defer = defer, lodash.delay = delay, lodash.difference = difference, lodash.drop = drop, lodash.dropRight = dropRight, lodash.dropRightWhile = dropRightWhile, lodash.dropWhile = dropWhile, lodash.fill = fill, lodash.filter = filter, lodash.flatten = flatten, lodash.flattenDeep = flattenDeep, lodash.flow = flow, lodash.flowRight = flowRight, lodash.forEach = forEach, lodash.forEachRight = forEachRight, lodash.forIn = forIn, lodash.forInRight = forInRight, lodash.forOwn = forOwn, lodash.forOwnRight = forOwnRight, lodash.functions = functions, lodash.groupBy = groupBy, lodash.indexBy = indexBy, lodash.initial = initial, lodash.intersection = intersection, lodash.invert = invert, lodash.invoke = invoke, lodash.keys = keys, lodash.keysIn = keysIn, lodash.map = map, lodash.mapKeys = mapKeys, lodash.mapValues = mapValues, lodash.matches = matches, lodash.matchesProperty = matchesProperty, lodash.memoize = memoize, lodash.merge = merge, lodash.method = method, lodash.methodOf = methodOf, lodash.mixin = mixin, lodash.modArgs = modArgs, lodash.negate = negate, lodash.omit = omit, lodash.once = once, lodash.pairs = pairs, lodash.partial = partial, lodash.partialRight = partialRight, lodash.partition = partition, lodash.pick = pick, lodash.pluck = pluck, lodash.property = property, lodash.propertyOf = propertyOf, lodash.pull = pull, lodash.pullAt = pullAt, lodash.range = range, lodash.rearg = rearg, lodash.reject = reject, lodash.remove = remove, lodash.rest = rest, lodash.restParam = restParam, lodash.set = set, lodash.shuffle = shuffle, lodash.slice = slice, lodash.sortBy = sortBy, lodash.sortByAll = sortByAll, lodash.sortByOrder = sortByOrder, lodash.spread = spread, lodash.take = take, lodash.takeRight = takeRight, lodash.takeRightWhile = takeRightWhile, lodash.takeWhile = takeWhile, lodash.tap = tap,lodash.throttle = throttle,lodash.thru = thru,lodash.times = times,lodash.toArray = toArray,lodash.toPlainObject = toPlainObject,lodash.transform = transform,lodash.union = union,lodash.uniq = uniq,lodash.unzip = unzip,lodash.unzipWith = unzipWith,lodash.values = values,lodash.valuesIn = valuesIn,lodash.where = where,lodash.without = without,lodash.wrap = wrap,lodash.xor = xor,lodash.zip = zip,lodash.zipObject = zipObject,lodash.zipWith = zipWith,lodash.backflow = flowRight,lodash.collect = map,lodash.compose = flowRight,lodash.each = forEach,lodash.eachRight = forEachRight,lodash.extend = assign,lodash.iteratee = callback,lodash.methods = functions,lodash.object = zipObject,lodash.select = filter,lodash.tail = rest,lodash.unique = uniq,mixin(lodash, lodash),lodash.add = add,lodash.attempt = attempt,lodash.camelCase = camelCase,lodash.capitalize = capitalize,lodash.ceil = ceil,lodash.clone = clone,lodash.cloneDeep = cloneDeep,lodash.deburr = deburr,lodash.endsWith = endsWith,lodash.escape = escape,lodash.escapeRegExp = escapeRegExp,lodash.every = every,lodash.find = find,lodash.findIndex = findIndex,lodash.findKey = findKey,lodash.findLast = findLast,lodash.findLastIndex = findLastIndex,lodash.findLastKey = findLastKey,lodash.findWhere = findWhere,lodash.first = first,lodash.floor = floor,lodash.get = get,lodash.gt = gt,lodash.gte = gte,lodash.has = has,lodash.identity = identity,lodash.includes = includes,lodash.indexOf = indexOf,lodash.inRange = inRange,lodash.isArguments = isArguments,lodash.isArray = isArray,lodash.isBoolean = isBoolean,lodash.isDate = isDate,lodash.isElement = isElement,lodash.isEmpty = isEmpty,lodash.isEqual = isEqual,lodash.isError = isError,lodash.isFinite = isFinite,lodash.isFunction = isFunction,lodash.isMatch = isMatch,lodash.isNaN = isNaN,lodash.isNative = isNative,lodash.isNull = isNull,lodash.isNumber = isNumber,lodash.isObject = isObject,lodash.isPlainObject = isPlainObject,lodash.isRegExp = isRegExp,lodash.isString = isString,lodash.isTypedArray = isTypedArray,lodash.isUndefined = isUndefined,lodash.kebabCase = kebabCase,lodash.last = last,lodash.lastIndexOf = lastIndexOf,lodash.lt = lt,lodash.lte = lte,lodash.max = max,lodash.min = min,lodash.noConflict = noConflict,lodash.noop = noop,lodash.now = now,lodash.pad = pad,lodash.padLeft = padLeft,lodash.padRight = padRight,lodash.parseInt = parseInt,lodash.random = random,lodash.reduce = reduce,lodash.reduceRight = reduceRight,lodash.repeat = repeat,lodash.result = result,lodash.round = round,lodash.runInContext = runInContext,lodash.size = size,lodash.snakeCase = snakeCase,lodash.some = some,lodash.sortedIndex = sortedIndex,lodash.sortedLastIndex = sortedLastIndex,lodash.startCase = startCase,lodash.startsWith = startsWith,lodash.sum = sum,lodash.template = template,lodash.trim = trim,lodash.trimLeft = trimLeft,lodash.trimRight = trimRight,lodash.trunc = trunc,lodash.unescape = unescape,lodash.uniqueId = uniqueId,lodash.words = words,lodash.all = every,lodash.any = some,lodash.contains = includes,lodash.eq = isEqual,lodash.detect = find,lodash.foldl = reduce,lodash.foldr = reduceRight,lodash.head = first,lodash.include = includes,lodash.inject = reduce,mixin(lodash, function () {
                        var source = {};
                        return baseForOwn(lodash, function (func, methodName) {
                            lodash.prototype[methodName] || (source[methodName] = func)
                        }), source
                    }(), !1),lodash.sample = sample,lodash.prototype.sample = function (n) {
                        return this.__chain__ || null != n ? this.thru(function (value) {
                            return sample(value, n)
                        }) : sample(this.value())
                    },lodash.VERSION = VERSION,arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (methodName) {
                        lodash[methodName].placeholder = lodash
                    }),arrayEach(["drop", "take"], function (methodName, index) {
                        LazyWrapper.prototype[methodName] = function (n) {
                            var filtered = this.__filtered__;
                            if (filtered && !index)return new LazyWrapper(this);
                            n = null == n ? 1 : nativeMax(nativeFloor(n) || 0, 0);
                            var result = this.clone();
                            return filtered ? result.__takeCount__ = nativeMin(result.__takeCount__, n) : result.__views__.push({
                                size: n,
                                type: methodName + (result.__dir__ < 0 ? "Right" : "")
                            }), result
                        }, LazyWrapper.prototype[methodName + "Right"] = function (n) {
                            return this.reverse()[methodName](n).reverse()
                        }
                    }),arrayEach(["filter", "map", "takeWhile"], function (methodName, index) {
                        var type = index + 1, isFilter = type != LAZY_MAP_FLAG;
                        LazyWrapper.prototype[methodName] = function (iteratee, thisArg) {
                            var result = this.clone();
                            return result.__iteratees__.push({
                                iteratee: getCallback(iteratee, thisArg, 1),
                                type: type
                            }), result.__filtered__ = result.__filtered__ || isFilter, result
                        }
                    }),arrayEach(["first", "last"], function (methodName, index) {
                        var takeName = "take" + (index ? "Right" : "");
                        LazyWrapper.prototype[methodName] = function () {
                            return this[takeName](1).value()[0]
                        }
                    }),arrayEach(["initial", "rest"], function (methodName, index) {
                        var dropName = "drop" + (index ? "" : "Right");
                        LazyWrapper.prototype[methodName] = function () {
                            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1)
                        }
                    }),arrayEach(["pluck", "where"], function (methodName, index) {
                        var operationName = index ? "filter" : "map", createCallback = index ? baseMatches : property;
                        LazyWrapper.prototype[methodName] = function (value) {
                            return this[operationName](createCallback(value))
                        }
                    }),LazyWrapper.prototype.compact = function () {
                        return this.filter(identity)
                    },LazyWrapper.prototype.reject = function (predicate, thisArg) {
                        return predicate = getCallback(predicate, thisArg, 1), this.filter(function (value) {
                            return !predicate(value)
                        })
                    },LazyWrapper.prototype.slice = function (start, end) {
                        start = null == start ? 0 : +start || 0;
                        var result = this;
                        return result.__filtered__ && (start > 0 || 0 > end) ? new LazyWrapper(result) : (0 > start ? result = result.takeRight(-start) : start && (result = result.drop(start)), end !== undefined && (end = +end || 0, result = 0 > end ? result.dropRight(-end) : result.take(end - start)), result)
                    },LazyWrapper.prototype.takeRightWhile = function (predicate, thisArg) {
                        return this.reverse().takeWhile(predicate, thisArg).reverse()
                    },LazyWrapper.prototype.toArray = function () {
                        return this.take(POSITIVE_INFINITY)
                    },baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                        var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName), retUnwrapped = /^(?:first|last)$/.test(methodName), lodashFunc = lodash[retUnwrapped ? "take" + ("last" == methodName ? "Right" : "") : methodName];
                        lodashFunc && (lodash.prototype[methodName] = function () {
                            var args = retUnwrapped ? [1] : arguments, chainAll = this.__chain__, value = this.__wrapped__, isHybrid = !!this.__actions__.length, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                            useLazy && checkIteratee && "function" == typeof iteratee && 1 != iteratee.length && (isLazy = useLazy = !1);
                            var interceptor = function (value) {
                                return retUnwrapped && chainAll ? lodashFunc(value, 1)[0] : lodashFunc.apply(undefined, arrayPush([value], args))
                            }, action = {
                                func: thru,
                                args: [interceptor],
                                thisArg: undefined
                            }, onlyLazy = isLazy && !isHybrid;
                            if (retUnwrapped && !chainAll)return onlyLazy ? (value = value.clone(), value.__actions__.push(action), func.call(value)) : lodashFunc.call(undefined, this.value())[0];
                            if (!retUnwrapped && useLazy) {
                                value = onlyLazy ? value : new LazyWrapper(this);
                                var result = func.apply(value, args);
                                return result.__actions__.push(action), new LodashWrapper(result, chainAll)
                            }
                            return this.thru(interceptor)
                        })
                    }),arrayEach(["join", "pop", "push", "replace", "shift", "sort", "splice", "split", "unshift"], function (methodName) {
                        var protoFunc = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", fixObjects = !support.spliceObjects && /^(?:pop|shift|splice)$/.test(methodName), retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName), func = fixObjects ? function () {
                            var result = protoFunc.apply(this, arguments);
                            return 0 === this.length && delete this[0], result
                        } : protoFunc;
                        lodash.prototype[methodName] = function () {
                            var args = arguments;
                            return retUnwrapped && !this.__chain__ ? func.apply(this.value(), args) : this[chainName](function (value) {
                                return func.apply(value, args)
                            })
                        }
                    }),baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                        var lodashFunc = lodash[methodName];
                        if (lodashFunc) {
                            var key = lodashFunc.name + "", names = realNames[key] || (realNames[key] = []);
                            names.push({name: methodName, func: lodashFunc})
                        }
                    }),realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
                        name: "wrapper",
                        func: undefined
                    }],LazyWrapper.prototype.clone = lazyClone,LazyWrapper.prototype.reverse = lazyReverse,LazyWrapper.prototype.value = lazyValue,lodash.prototype.chain = wrapperChain,lodash.prototype.commit = wrapperCommit,lodash.prototype.concat = wrapperConcat,lodash.prototype.plant = wrapperPlant,lodash.prototype.reverse = wrapperReverse,lodash.prototype.toString = wrapperToString,lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue,lodash.prototype.collect = lodash.prototype.map,lodash.prototype.head = lodash.prototype.first,lodash.prototype.select = lodash.prototype.filter,lodash.prototype.tail = lodash.prototype.rest,lodash
                }

                var undefined, VERSION = "3.10.2", BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256, DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...", HOT_COUNT = 150, HOT_SPAN = 16, LARGE_ARRAY_SIZE = 200, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, FUNC_ERROR_TEXT = "Expected a function", PLACEHOLDER = "__lodash_placeholder__", argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g, reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g, reHasRegExpChars = RegExp(reRegExpChars.source), reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reHasHexPrefix = /^0[xX]/, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsUint = /^\d+$/, reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, reWords = function () {
                    var upper = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", lower = "[a-z\\xdf-\\xf6\\xf8-\\xff]+";
                    return RegExp(upper + "+(?=" + upper + lower + ")|" + upper + "?" + lower + "|" + upper + "+|[0-9]+", "g")
                }(), contextProps = ["Array", "ArrayBuffer", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Math", "Number", "Object", "RegExp", "Set", "String", "_", "clearTimeout", "isFinite", "parseFloat", "parseInt", "setTimeout", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap"], shadowProps = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], templateCounter = -1, typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
                var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = !1;
                var deburredLetters = {
                    "À": "A",
                    "Á": "A",
                    "Â": "A",
                    "Ã": "A",
                    "Ä": "A",
                    "Å": "A",
                    "à": "a",
                    "á": "a",
                    "â": "a",
                    "ã": "a",
                    "ä": "a",
                    "å": "a",
                    "Ç": "C",
                    "ç": "c",
                    "Ð": "D",
                    "ð": "d",
                    "È": "E",
                    "É": "E",
                    "Ê": "E",
                    "Ë": "E",
                    "è": "e",
                    "é": "e",
                    "ê": "e",
                    "ë": "e",
                    "Ì": "I",
                    "Í": "I",
                    "Î": "I",
                    "Ï": "I",
                    "ì": "i",
                    "í": "i",
                    "î": "i",
                    "ï": "i",
                    "Ñ": "N",
                    "ñ": "n",
                    "Ò": "O",
                    "Ó": "O",
                    "Ô": "O",
                    "Õ": "O",
                    "Ö": "O",
                    "Ø": "O",
                    "ò": "o",
                    "ó": "o",
                    "ô": "o",
                    "õ": "o",
                    "ö": "o",
                    "ø": "o",
                    "Ù": "U",
                    "Ú": "U",
                    "Û": "U",
                    "Ü": "U",
                    "ù": "u",
                    "ú": "u",
                    "û": "u",
                    "ü": "u",
                    "Ý": "Y",
                    "ý": "y",
                    "ÿ": "y",
                    "Æ": "Ae",
                    "æ": "ae",
                    "Þ": "Th",
                    "þ": "th",
                    "ß": "ss"
                }, htmlEscapes = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;",
                    "`": "&#96;"
                }, htmlUnescapes = {
                    "&amp;": "&",
                    "&lt;": "<",
                    "&gt;": ">",
                    "&quot;": '"',
                    "&#39;": "'",
                    "&#96;": "`"
                }, objectTypes = {"function": !0, object: !0}, regexpEscapes = {
                    0: "x30",
                    1: "x31",
                    2: "x32",
                    3: "x33",
                    4: "x34",
                    5: "x35",
                    6: "x36",
                    7: "x37",
                    8: "x38",
                    9: "x39",
                    A: "x41",
                    B: "x42",
                    C: "x43",
                    D: "x44",
                    E: "x45",
                    F: "x46",
                    a: "x61",
                    b: "x62",
                    c: "x63",
                    d: "x64",
                    e: "x65",
                    f: "x66",
                    n: "x6e",
                    r: "x72",
                    t: "x74",
                    u: "x75",
                    v: "x76",
                    x: "x78"
                }, stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                }, freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports, freeModule = objectTypes[typeof module] && module && !module.nodeType && module, freeGlobal = freeExports && freeModule && "object" == typeof global && global && global.Object && global, freeSelf = objectTypes[typeof self] && self && self.Object && self, freeWindow = objectTypes[typeof window] && window && window.Object && window, moduleExports = freeModule && freeModule.exports === freeExports && freeExports, root = freeGlobal || freeWindow !== (this && this.window) && freeWindow || freeSelf || this, isHostObject = function () {
                    try {
                        Object({toString: 0} + "")
                    } catch (e) {
                        return function () {
                            return !1
                        }
                    }
                    return function (value) {
                        return "function" != typeof value.toString && "string" == typeof(value + "")
                    }
                }(), _ = runInContext();
                "function" == typeof define && "object" == typeof define.amd && define.amd ? (root._ = _, define(function () {
                    return _
                })) : freeExports && freeModule ? moduleExports ? (freeModule.exports = _)._ = _ : freeExports._ = _ : root._ = _
            }).call(this)
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    46: [function (require, module, exports) {
        (function (global) {
            (function () {
                function addMapEntry(map, pair) {
                    return map.set(pair[0], pair[1]), map
                }

                function addSetEntry(set, value) {
                    return set.add(value), set
                }

                function apply(func, thisArg, args) {
                    var length = args.length;
                    switch (length) {
                        case 0:
                            return func.call(thisArg);
                        case 1:
                            return func.call(thisArg, args[0]);
                        case 2:
                            return func.call(thisArg, args[0], args[1]);
                        case 3:
                            return func.call(thisArg, args[0], args[1], args[2])
                    }
                    return func.apply(thisArg, args)
                }

                function arrayAggregator(array, setter, iteratee, accumulator) {
                    for (var index = -1, length = array.length; ++index < length;) {
                        var value = array[index];
                        setter(accumulator, value, iteratee(value), array);
                    }
                    return accumulator
                }

                function arrayEach(array, iteratee) {
                    for (var index = -1, length = array.length; ++index < length && iteratee(array[index], index, array) !== !1;);
                    return array
                }

                function arrayEachRight(array, iteratee) {
                    for (var length = array.length; length-- && iteratee(array[length], length, array) !== !1;);
                    return array
                }

                function arrayEvery(array, predicate) {
                    for (var index = -1, length = array.length; ++index < length;)if (!predicate(array[index], index, array))return !1;
                    return !0
                }

                function arrayFilter(array, predicate) {
                    for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length;) {
                        var value = array[index];
                        predicate(value, index, array) && (result[resIndex++] = value)
                    }
                    return result
                }

                function arrayIncludes(array, value) {
                    return !!array.length && baseIndexOf(array, value, 0) > -1
                }

                function arrayIncludesWith(array, value, comparator) {
                    for (var index = -1, length = array.length; ++index < length;)if (comparator(value, array[index]))return !0;
                    return !1
                }

                function arrayMap(array, iteratee) {
                    for (var index = -1, length = array.length, result = Array(length); ++index < length;)result[index] = iteratee(array[index], index, array);
                    return result
                }

                function arrayPush(array, values) {
                    for (var index = -1, length = values.length, offset = array.length; ++index < length;)array[offset + index] = values[index];
                    return array
                }

                function arrayReduce(array, iteratee, accumulator, initAccum) {
                    var index = -1, length = array.length;
                    for (initAccum && length && (accumulator = array[++index]); ++index < length;)accumulator = iteratee(accumulator, array[index], index, array);
                    return accumulator
                }

                function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                    var length = array.length;
                    for (initAccum && length && (accumulator = array[--length]); length--;)accumulator = iteratee(accumulator, array[length], length, array);
                    return accumulator
                }

                function arraySome(array, predicate) {
                    for (var index = -1, length = array.length; ++index < length;)if (predicate(array[index], index, array))return !0;
                    return !1
                }

                function baseFind(collection, predicate, eachFunc, retKey) {
                    var result;
                    return eachFunc(collection, function (value, key, collection) {
                        return predicate(value, key, collection) ? (result = retKey ? key : value, !1) : void 0
                    }), result
                }

                function baseFindIndex(array, predicate, fromRight) {
                    for (var length = array.length, index = fromRight ? length : -1; fromRight ? index-- : ++index < length;)if (predicate(array[index], index, array))return index;
                    return -1
                }

                function baseIndexOf(array, value, fromIndex) {
                    if (value !== value)return indexOfNaN(array, fromIndex);
                    for (var index = fromIndex - 1, length = array.length; ++index < length;)if (array[index] === value)return index;
                    return -1
                }

                function baseIndexOfWith(array, value, fromIndex, comparator) {
                    for (var index = fromIndex - 1, length = array.length; ++index < length;)if (comparator(array[index], value))return index;
                    return -1
                }

                function baseMean(array, iteratee) {
                    var length = array ? array.length : 0;
                    return length ? baseSum(array, iteratee) / length : NAN
                }

                function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                    return eachFunc(collection, function (value, index, collection) {
                        accumulator = initAccum ? (initAccum = !1, value) : iteratee(accumulator, value, index, collection)
                    }), accumulator
                }

                function baseSortBy(array, comparer) {
                    var length = array.length;
                    for (array.sort(comparer); length--;)array[length] = array[length].value;
                    return array
                }

                function baseSum(array, iteratee) {
                    for (var result, index = -1, length = array.length; ++index < length;) {
                        var current = iteratee(array[index]);
                        current !== undefined && (result = result === undefined ? current : result + current)
                    }
                    return result
                }

                function baseTimes(n, iteratee) {
                    for (var index = -1, result = Array(n); ++index < n;)result[index] = iteratee(index);
                    return result
                }

                function baseToPairs(object, props) {
                    return arrayMap(props, function (key) {
                        return [key, object[key]]
                    })
                }

                function baseUnary(func) {
                    return function (value) {
                        return func(value)
                    }
                }

                function baseValues(object, props) {
                    return arrayMap(props, function (key) {
                        return object[key]
                    })
                }

                function cacheHas(cache, key) {
                    return cache.has(key)
                }

                function charsStartIndex(strSymbols, chrSymbols) {
                    for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1;);
                    return index
                }

                function charsEndIndex(strSymbols, chrSymbols) {
                    for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1;);
                    return index
                }

                function checkGlobal(value) {
                    return value && value.Object === Object ? value : null
                }

                function countHolders(array, placeholder) {
                    for (var length = array.length, result = 0; length--;)array[length] === placeholder && result++;
                    return result
                }

                function deburrLetter(letter) {
                    return deburredLetters[letter]
                }

                function escapeHtmlChar(chr) {
                    return htmlEscapes[chr]
                }

                function escapeStringChar(chr) {
                    return "\\" + stringEscapes[chr]
                }

                function indexOfNaN(array, fromIndex, fromRight) {
                    for (var length = array.length, index = fromIndex + (fromRight ? 0 : -1); fromRight ? index-- : ++index < length;) {
                        var other = array[index];
                        if (other !== other)return index
                    }
                    return -1
                }

                function isHostObject(value) {
                    var result = !1;
                    if (null != value && "function" != typeof value.toString)try {
                        result = !!(value + "")
                    } catch (e) {
                    }
                    return result
                }

                function iteratorToArray(iterator) {
                    for (var data, result = []; !(data = iterator.next()).done;)result.push(data.value);
                    return result
                }

                function mapToArray(map) {
                    var index = -1, result = Array(map.size);
                    return map.forEach(function (value, key) {
                        result[++index] = [key, value]
                    }), result
                }

                function replaceHolders(array, placeholder) {
                    for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length;) {
                        var value = array[index];
                        value !== placeholder && value !== PLACEHOLDER || (array[index] = PLACEHOLDER, result[resIndex++] = index)
                    }
                    return result
                }

                function setToArray(set) {
                    var index = -1, result = Array(set.size);
                    return set.forEach(function (value) {
                        result[++index] = value
                    }), result
                }

                function setToPairs(set) {
                    var index = -1, result = Array(set.size);
                    return set.forEach(function (value) {
                        result[++index] = [value, value]
                    }), result
                }

                function stringSize(string) {
                    if (!string || !reHasComplexSymbol.test(string))return string.length;
                    for (var result = reComplexSymbol.lastIndex = 0; reComplexSymbol.test(string);)result++;
                    return result
                }

                function stringToArray(string) {
                    return string.match(reComplexSymbol)
                }

                function unescapeHtmlChar(chr) {
                    return htmlUnescapes[chr]
                }

                function runInContext(context) {
                    function lodash(value) {
                        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                            if (value instanceof LodashWrapper)return value;
                            if (hasOwnProperty.call(value, "__wrapped__"))return wrapperClone(value)
                        }
                        return new LodashWrapper(value)
                    }

                    function baseLodash() {
                    }

                    function LodashWrapper(value, chainAll) {
                        this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0, this.__values__ = undefined
                    }

                    function LazyWrapper(value) {
                        this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = []
                    }

                    function lazyClone() {
                        var result = new LazyWrapper(this.__wrapped__);
                        return result.__actions__ = copyArray(this.__actions__), result.__dir__ = this.__dir__, result.__filtered__ = this.__filtered__, result.__iteratees__ = copyArray(this.__iteratees__), result.__takeCount__ = this.__takeCount__, result.__views__ = copyArray(this.__views__), result
                    }

                    function lazyReverse() {
                        if (this.__filtered__) {
                            var result = new LazyWrapper(this);
                            result.__dir__ = -1, result.__filtered__ = !0
                        } else result = this.clone(), result.__dir__ *= -1;
                        return result
                    }

                    function lazyValue() {
                        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = 0 > dir, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                        if (!isArr || LARGE_ARRAY_SIZE > arrLength || arrLength == length && takeCount == length)return baseWrapperValue(array, this.__actions__);
                        var result = [];
                        outer:for (; length-- && takeCount > resIndex;) {
                            index += dir;
                            for (var iterIndex = -1, value = array[index]; ++iterIndex < iterLength;) {
                                var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                                if (type == LAZY_MAP_FLAG)value = computed; else if (!computed) {
                                    if (type == LAZY_FILTER_FLAG)continue outer;
                                    break outer
                                }
                            }
                            result[resIndex++] = value
                        }
                        return result
                    }

                    function Hash(entries) {
                        var index = -1, length = entries ? entries.length : 0;
                        for (this.clear(); ++index < length;) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1])
                        }
                    }

                    function hashClear() {
                        this.__data__ = nativeCreate ? nativeCreate(null) : {}
                    }

                    function hashDelete(key) {
                        return this.has(key) && delete this.__data__[key]
                    }

                    function hashGet(key) {
                        var data = this.__data__;
                        if (nativeCreate) {
                            var result = data[key];
                            return result === HASH_UNDEFINED ? undefined : result
                        }
                        return hasOwnProperty.call(data, key) ? data[key] : undefined
                    }

                    function hashHas(key) {
                        var data = this.__data__;
                        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key)
                    }

                    function hashSet(key, value) {
                        var data = this.__data__;
                        return data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value, this
                    }

                    function ListCache(entries) {
                        var index = -1, length = entries ? entries.length : 0;
                        for (this.clear(); ++index < length;) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1])
                        }
                    }

                    function listCacheClear() {
                        this.__data__ = []
                    }

                    function listCacheDelete(key) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        if (0 > index)return !1;
                        var lastIndex = data.length - 1;
                        return index == lastIndex ? data.pop() : splice.call(data, index, 1), !0
                    }

                    function listCacheGet(key) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        return 0 > index ? undefined : data[index][1]
                    }

                    function listCacheHas(key) {
                        return assocIndexOf(this.__data__, key) > -1
                    }

                    function listCacheSet(key, value) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        return 0 > index ? data.push([key, value]) : data[index][1] = value, this
                    }

                    function MapCache(entries) {
                        var index = -1, length = entries ? entries.length : 0;
                        for (this.clear(); ++index < length;) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1])
                        }
                    }

                    function mapCacheClear() {
                        this.__data__ = {hash: new Hash, map: new (Map || ListCache), string: new Hash}
                    }

                    function mapCacheDelete(key) {
                        return getMapData(this, key)["delete"](key)
                    }

                    function mapCacheGet(key) {
                        return getMapData(this, key).get(key)
                    }

                    function mapCacheHas(key) {
                        return getMapData(this, key).has(key)
                    }

                    function mapCacheSet(key, value) {
                        return getMapData(this, key).set(key, value), this
                    }

                    function SetCache(values) {
                        var index = -1, length = values ? values.length : 0;
                        for (this.__data__ = new MapCache; ++index < length;)this.add(values[index])
                    }

                    function setCacheAdd(value) {
                        return this.__data__.set(value, HASH_UNDEFINED), this
                    }

                    function setCacheHas(value) {
                        return this.__data__.has(value)
                    }

                    function Stack(entries) {
                        this.__data__ = new ListCache(entries)
                    }

                    function stackClear() {
                        this.__data__ = new ListCache
                    }

                    function stackDelete(key) {
                        return this.__data__["delete"](key)
                    }

                    function stackGet(key) {
                        return this.__data__.get(key)
                    }

                    function stackHas(key) {
                        return this.__data__.has(key)
                    }

                    function stackSet(key, value) {
                        var cache = this.__data__;
                        return cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE && (cache = this.__data__ = new MapCache(cache.__data__)), cache.set(key, value), this
                    }

                    function assignInDefaults(objValue, srcValue, key, object) {
                        return objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key) ? srcValue : objValue
                    }

                    function assignMergeValue(object, key, value) {
                        (value === undefined || eq(object[key], value)) && ("number" != typeof key || value !== undefined || key in object) || (object[key] = value)
                    }

                    function assignValue(object, key, value) {
                        var objValue = object[key];
                        hasOwnProperty.call(object, key) && eq(objValue, value) && (value !== undefined || key in object) || (object[key] = value)
                    }

                    function assocIndexOf(array, key) {
                        for (var length = array.length; length--;)if (eq(array[length][0], key))return length;
                        return -1
                    }

                    function baseAggregator(collection, setter, iteratee, accumulator) {
                        return baseEach(collection, function (value, key, collection) {
                            setter(accumulator, value, iteratee(value), collection)
                        }), accumulator
                    }

                    function baseAssign(object, source) {
                        return object && copyObject(source, keys(source), object)
                    }

                    function baseAt(object, paths) {
                        for (var index = -1, isNil = null == object, length = paths.length, result = Array(length); ++index < length;)result[index] = isNil ? undefined : get(object, paths[index]);
                        return result
                    }

                    function baseClamp(number, lower, upper) {
                        return number === number && (upper !== undefined && (number = upper >= number ? number : upper), lower !== undefined && (number = number >= lower ? number : lower)), number
                    }

                    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
                        var result;
                        if (customizer && (result = object ? customizer(value, key, object, stack) : customizer(value)), result !== undefined)return result;
                        if (!isObject(value))return value;
                        var isArr = isArray(value);
                        if (isArr) {
                            if (result = initCloneArray(value), !isDeep)return copyArray(value, result)
                        } else {
                            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                            if (isBuffer(value))return cloneBuffer(value, isDeep);
                            if (tag == objectTag || tag == argsTag || isFunc && !object) {
                                if (isHostObject(value))return object ? value : {};
                                if (result = initCloneObject(isFunc ? {} : value), !isDeep)return copySymbols(value, baseAssign(result, value))
                            } else {
                                if (!cloneableTags[tag])return object ? value : {};
                                result = initCloneByTag(value, tag, baseClone, isDeep)
                            }
                        }
                        stack || (stack = new Stack);
                        var stacked = stack.get(value);
                        if (stacked)return stacked;
                        if (stack.set(value, result), !isArr)var props = isFull ? getAllKeys(value) : keys(value);
                        return arrayEach(props || value, function (subValue, key) {
                            props && (key = subValue, subValue = value[key]), assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack))
                        }), result
                    }

                    function baseConforms(source) {
                        var props = keys(source), length = props.length;
                        return function (object) {
                            if (null == object)return !length;
                            for (var index = length; index--;) {
                                var key = props[index], predicate = source[key], value = object[key];
                                if (value === undefined && !(key in Object(object)) || !predicate(value))return !1
                            }
                            return !0
                        }
                    }

                    function baseCreate(proto) {
                        return isObject(proto) ? objectCreate(proto) : {}
                    }

                    function baseDelay(func, wait, args) {
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        return setTimeout(function () {
                            func.apply(undefined, args)
                        }, wait)
                    }

                    function baseDifference(array, values, iteratee, comparator) {
                        var index = -1, includes = arrayIncludes, isCommon = !0, length = array.length, result = [], valuesLength = values.length;
                        if (!length)return result;
                        iteratee && (values = arrayMap(values, baseUnary(iteratee))), comparator ? (includes = arrayIncludesWith, isCommon = !1) : values.length >= LARGE_ARRAY_SIZE && (includes = cacheHas, isCommon = !1, values = new SetCache(values));
                        outer:for (; ++index < length;) {
                            var value = array[index], computed = iteratee ? iteratee(value) : value;
                            if (value = comparator || 0 !== value ? value : 0, isCommon && computed === computed) {
                                for (var valuesIndex = valuesLength; valuesIndex--;)if (values[valuesIndex] === computed)continue outer;
                                result.push(value)
                            } else includes(values, computed, comparator) || result.push(value)
                        }
                        return result
                    }

                    function baseEvery(collection, predicate) {
                        var result = !0;
                        return baseEach(collection, function (value, index, collection) {
                            return result = !!predicate(value, index, collection)
                        }), result
                    }

                    function baseExtremum(array, iteratee, comparator) {
                        for (var index = -1, length = array.length; ++index < length;) {
                            var value = array[index], current = iteratee(value);
                            if (null != current && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed)))var computed = current, result = value
                        }
                        return result
                    }

                    function baseFill(array, value, start, end) {
                        var length = array.length;
                        for (start = toInteger(start), 0 > start && (start = -start > length ? 0 : length + start), end = end === undefined || end > length ? length : toInteger(end), 0 > end && (end += length), end = start > end ? 0 : toLength(end); end > start;)array[start++] = value;
                        return array
                    }

                    function baseFilter(collection, predicate) {
                        var result = [];
                        return baseEach(collection, function (value, index, collection) {
                            predicate(value, index, collection) && result.push(value)
                        }), result
                    }

                    function baseFlatten(array, depth, predicate, isStrict, result) {
                        var index = -1, length = array.length;
                        for (predicate || (predicate = isFlattenable), result || (result = []); ++index < length;) {
                            var value = array[index];
                            depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value)
                        }
                        return result
                    }

                    function baseForOwn(object, iteratee) {
                        return object && baseFor(object, iteratee, keys)
                    }

                    function baseForOwnRight(object, iteratee) {
                        return object && baseForRight(object, iteratee, keys)
                    }

                    function baseFunctions(object, props) {
                        return arrayFilter(props, function (key) {
                            return isFunction(object[key])
                        })
                    }

                    function baseGet(object, path) {
                        path = isKey(path, object) ? [path] : castPath(path);
                        for (var index = 0, length = path.length; null != object && length > index;)object = object[toKey(path[index++])];
                        return index && index == length ? object : undefined
                    }

                    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                        var result = keysFunc(object);
                        return isArray(object) ? result : arrayPush(result, symbolsFunc(object))
                    }

                    function baseGt(value, other) {
                        return value > other
                    }

                    function baseHas(object, key) {
                        return hasOwnProperty.call(object, key) || "object" == typeof object && key in object && null === getPrototype(object)
                    }

                    function baseHasIn(object, key) {
                        return key in Object(object)
                    }

                    function baseInRange(number, start, end) {
                        return number >= nativeMin(start, end) && number < nativeMax(start, end)
                    }

                    function baseIntersection(arrays, iteratee, comparator) {
                        for (var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = 1 / 0, result = []; othIndex--;) {
                            var array = arrays[othIndex];
                            othIndex && iteratee && (array = arrayMap(array, baseUnary(iteratee))), maxLength = nativeMin(array.length, maxLength), caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined
                        }
                        array = arrays[0];
                        var index = -1, seen = caches[0];
                        outer:for (; ++index < length && result.length < maxLength;) {
                            var value = array[index], computed = iteratee ? iteratee(value) : value;
                            if (value = comparator || 0 !== value ? value : 0, !(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                                for (othIndex = othLength; --othIndex;) {
                                    var cache = caches[othIndex];
                                    if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator)))continue outer
                                }
                                seen && seen.push(computed), result.push(value)
                            }
                        }
                        return result
                    }

                    function baseInverter(object, setter, iteratee, accumulator) {
                        return baseForOwn(object, function (value, key, object) {
                            setter(accumulator, iteratee(value), key, object)
                        }), accumulator
                    }

                    function baseInvoke(object, path, args) {
                        isKey(path, object) || (path = castPath(path), object = parent(object, path), path = last(path));
                        var func = null == object ? object : object[toKey(path)];
                        return null == func ? undefined : apply(func, object, args)
                    }

                    function baseIsEqual(value, other, customizer, bitmask, stack) {
                        return value === other ? !0 : null == value || null == other || !isObject(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack)
                    }

                    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
                        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
                        objIsArr || (objTag = getTag(object), objTag = objTag == argsTag ? objectTag : objTag), othIsArr || (othTag = getTag(other), othTag = othTag == argsTag ? objectTag : othTag);
                        var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
                        if (isSameTag && !objIsObj)return stack || (stack = new Stack), objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
                        if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                            if (objIsWrapped || othIsWrapped) {
                                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                                return stack || (stack = new Stack), equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack)
                            }
                        }
                        return isSameTag ? (stack || (stack = new Stack), equalObjects(object, other, equalFunc, customizer, bitmask, stack)) : !1
                    }

                    function baseIsMatch(object, source, matchData, customizer) {
                        var index = matchData.length, length = index, noCustomizer = !customizer;
                        if (null == object)return !length;
                        for (object = Object(object); index--;) {
                            var data = matchData[index];
                            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object))return !1
                        }
                        for (; ++index < length;) {
                            data = matchData[index];
                            var key = data[0], objValue = object[key], srcValue = data[1];
                            if (noCustomizer && data[2]) {
                                if (objValue === undefined && !(key in object))return !1
                            } else {
                                var stack = new Stack;
                                if (customizer)var result = customizer(objValue, srcValue, key, object, source, stack);
                                if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result))return !1
                            }
                        }
                        return !0
                    }

                    function baseIteratee(value) {
                        return "function" == typeof value ? value : null == value ? identity : "object" == typeof value ? isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value)
                    }

                    function baseKeys(object) {
                        return nativeKeys(Object(object))
                    }

                    function baseKeysIn(object) {
                        object = null == object ? object : Object(object);
                        var result = [];
                        for (var key in object)result.push(key);
                        return result
                    }

                    function baseLt(value, other) {
                        return other > value
                    }

                    function baseMap(collection, iteratee) {
                        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
                        return baseEach(collection, function (value, key, collection) {
                            result[++index] = iteratee(value, key, collection)
                        }), result
                    }

                    function baseMatches(source) {
                        var matchData = getMatchData(source);
                        return 1 == matchData.length && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function (object) {
                            return object === source || baseIsMatch(object, source, matchData)
                        }
                    }

                    function baseMatchesProperty(path, srcValue) {
                        return isKey(path) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path), srcValue) : function (object) {
                            var objValue = get(object, path);
                            return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG)
                        }
                    }

                    function baseMerge(object, source, srcIndex, customizer, stack) {
                        if (object !== source) {
                            if (!isArray(source) && !isTypedArray(source))var props = keysIn(source);
                            arrayEach(props || source, function (srcValue, key) {
                                if (props && (key = srcValue, srcValue = source[key]), isObject(srcValue))stack || (stack = new Stack), baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack); else {
                                    var newValue = customizer ? customizer(object[key], srcValue, key + "", object, source, stack) : undefined;
                                    newValue === undefined && (newValue = srcValue), assignMergeValue(object, key, newValue)
                                }
                            })
                        }
                    }

                    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                        var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
                        if (stacked)return void assignMergeValue(object, key, stacked);
                        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined, isCommon = newValue === undefined;
                        isCommon && (newValue = srcValue, isArray(srcValue) || isTypedArray(srcValue) ? isArray(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : (isCommon = !1, newValue = baseClone(srcValue, !0)) : isPlainObject(srcValue) || isArguments(srcValue) ? isArguments(objValue) ? newValue = toPlainObject(objValue) : !isObject(objValue) || srcIndex && isFunction(objValue) ? (isCommon = !1, newValue = baseClone(srcValue, !0)) : newValue = objValue : isCommon = !1), stack.set(srcValue, newValue), isCommon && mergeFunc(newValue, srcValue, srcIndex, customizer, stack), stack["delete"](srcValue), assignMergeValue(object, key, newValue)
                    }

                    function baseNth(array, n) {
                        var length = array.length;
                        if (length)return n += 0 > n ? length : 0, isIndex(n, length) ? array[n] : undefined
                    }

                    function baseOrderBy(collection, iteratees, orders) {
                        var index = -1;
                        iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
                        var result = baseMap(collection, function (value, key, collection) {
                            var criteria = arrayMap(iteratees, function (iteratee) {
                                return iteratee(value)
                            });
                            return {criteria: criteria, index: ++index, value: value}
                        });
                        return baseSortBy(result, function (object, other) {
                            return compareMultiple(object, other, orders)
                        })
                    }

                    function basePick(object, props) {
                        return object = Object(object), arrayReduce(props, function (result, key) {
                            return key in object && (result[key] = object[key]), result
                        }, {})
                    }

                    function basePickBy(object, predicate) {
                        for (var index = -1, props = getAllKeysIn(object), length = props.length, result = {}; ++index < length;) {
                            var key = props[index], value = object[key];
                            predicate(value, key) && (result[key] = value)
                        }
                        return result
                    }

                    function baseProperty(key) {
                        return function (object) {
                            return null == object ? undefined : object[key]
                        }
                    }

                    function basePropertyDeep(path) {
                        return function (object) {
                            return baseGet(object, path)
                        }
                    }

                    function basePullAll(array, values, iteratee, comparator) {
                        var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
                        for (iteratee && (seen = arrayMap(array, baseUnary(iteratee))); ++index < length;)for (var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value; (fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1;)seen !== array && splice.call(seen, fromIndex, 1), splice.call(array, fromIndex, 1);
                        return array
                    }

                    function basePullAt(array, indexes) {
                        for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--;) {
                            var index = indexes[length];
                            if (length == lastIndex || index !== previous) {
                                var previous = index;
                                if (isIndex(index))splice.call(array, index, 1); else if (isKey(index, array))delete array[toKey(index)]; else {
                                    var path = castPath(index), object = parent(array, path);
                                    null != object && delete object[toKey(last(path))]
                                }
                            }
                        }
                        return array
                    }

                    function baseRandom(lower, upper) {
                        return lower + nativeFloor(nativeRandom() * (upper - lower + 1))
                    }

                    function baseRange(start, end, step, fromRight) {
                        for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); length--;)result[fromRight ? length : ++index] = start, start += step;
                        return result
                    }

                    function baseRepeat(string, n) {
                        var result = "";
                        if (!string || 1 > n || n > MAX_SAFE_INTEGER)return result;
                        do n % 2 && (result += string), n = nativeFloor(n / 2), n && (string += string); while (n);
                        return result
                    }

                    function baseSet(object, path, value, customizer) {
                        path = isKey(path, object) ? [path] : castPath(path);
                        for (var index = -1, length = path.length, lastIndex = length - 1, nested = object; null != nested && ++index < length;) {
                            var key = toKey(path[index]);
                            if (isObject(nested)) {
                                var newValue = value;
                                if (index != lastIndex) {
                                    var objValue = nested[key];
                                    newValue = customizer ? customizer(objValue, key, nested) : undefined, newValue === undefined && (newValue = null == objValue ? isIndex(path[index + 1]) ? [] : {} : objValue)
                                }
                                assignValue(nested, key, newValue)
                            }
                            nested = nested[key]
                        }
                        return object
                    }

                    function baseSlice(array, start, end) {
                        var index = -1, length = array.length;
                        0 > start && (start = -start > length ? 0 : length + start), end = end > length ? length : end, 0 > end && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
                        for (var result = Array(length); ++index < length;)result[index] = array[index + start];
                        return result
                    }

                    function baseSome(collection, predicate) {
                        var result;
                        return baseEach(collection, function (value, index, collection) {
                            return result = predicate(value, index, collection), !result
                        }), !!result
                    }

                    function baseSortedIndex(array, value, retHighest) {
                        var low = 0, high = array ? array.length : low;
                        if ("number" == typeof value && value === value && HALF_MAX_ARRAY_LENGTH >= high) {
                            for (; high > low;) {
                                var mid = low + high >>> 1, computed = array[mid];
                                null !== computed && !isSymbol(computed) && (retHighest ? value >= computed : value > computed) ? low = mid + 1 : high = mid
                            }
                            return high
                        }
                        return baseSortedIndexBy(array, value, identity, retHighest)
                    }

                    function baseSortedIndexBy(array, value, iteratee, retHighest) {
                        value = iteratee(value);
                        for (var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsNull = null === value, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined; high > low;) {
                            var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = null === computed, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                            if (valIsNaN)var setLow = retHighest || othIsReflexive; else setLow = valIsUndefined ? othIsReflexive && (retHighest || othIsDefined) : valIsNull ? othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : othIsNull || othIsSymbol ? !1 : retHighest ? value >= computed : value > computed;
                            setLow ? low = mid + 1 : high = mid
                        }
                        return nativeMin(high, MAX_ARRAY_INDEX)
                    }

                    function baseSortedUniq(array, iteratee) {
                        for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length;) {
                            var value = array[index], computed = iteratee ? iteratee(value) : value;
                            if (!index || !eq(computed, seen)) {
                                var seen = computed;
                                result[resIndex++] = 0 === value ? 0 : value
                            }
                        }
                        return result
                    }

                    function baseToNumber(value) {
                        return "number" == typeof value ? value : isSymbol(value) ? NAN : +value
                    }

                    function baseToString(value) {
                        if ("string" == typeof value)return value;
                        if (isSymbol(value))return symbolToString ? symbolToString.call(value) : "";
                        var result = value + "";
                        return "0" == result && 1 / value == -INFINITY ? "-0" : result
                    }

                    function baseUniq(array, iteratee, comparator) {
                        var index = -1, includes = arrayIncludes, length = array.length, isCommon = !0, result = [], seen = result;
                        if (comparator)isCommon = !1, includes = arrayIncludesWith; else if (length >= LARGE_ARRAY_SIZE) {
                            var set = iteratee ? null : createSet(array);
                            if (set)return setToArray(set);
                            isCommon = !1, includes = cacheHas, seen = new SetCache
                        } else seen = iteratee ? [] : result;
                        outer:for (; ++index < length;) {
                            var value = array[index], computed = iteratee ? iteratee(value) : value;
                            if (value = comparator || 0 !== value ? value : 0, isCommon && computed === computed) {
                                for (var seenIndex = seen.length; seenIndex--;)if (seen[seenIndex] === computed)continue outer;
                                iteratee && seen.push(computed), result.push(value)
                            } else includes(seen, computed, comparator) || (seen !== result && seen.push(computed), result.push(value))
                        }
                        return result
                    }

                    function baseUnset(object, path) {
                        path = isKey(path, object) ? [path] : castPath(path), object = parent(object, path);
                        var key = toKey(last(path));
                        return !(null != object && baseHas(object, key)) || delete object[key]
                    }

                    function baseUpdate(object, path, updater, customizer) {
                        return baseSet(object, path, updater(baseGet(object, path)), customizer)
                    }

                    function baseWhile(array, predicate, isDrop, fromRight) {
                        for (var length = array.length, index = fromRight ? length : -1; (fromRight ? index-- : ++index < length) && predicate(array[index], index, array););
                        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index)
                    }

                    function baseWrapperValue(value, actions) {
                        var result = value;
                        return result instanceof LazyWrapper && (result = result.value()), arrayReduce(actions, function (result, action) {
                            return action.func.apply(action.thisArg, arrayPush([result], action.args))
                        }, result)
                    }

                    function baseXor(arrays, iteratee, comparator) {
                        for (var index = -1, length = arrays.length; ++index < length;)var result = result ? arrayPush(baseDifference(result, arrays[index], iteratee, comparator), baseDifference(arrays[index], result, iteratee, comparator)) : arrays[index];
                        return result && result.length ? baseUniq(result, iteratee, comparator) : []
                    }

                    function baseZipObject(props, values, assignFunc) {
                        for (var index = -1, length = props.length, valsLength = values.length, result = {}; ++index < length;) {
                            var value = valsLength > index ? values[index] : undefined;
                            assignFunc(result, props[index], value)
                        }
                        return result
                    }

                    function castArrayLikeObject(value) {
                        return isArrayLikeObject(value) ? value : []
                    }

                    function castFunction(value) {
                        return "function" == typeof value ? value : identity
                    }

                    function castPath(value) {
                        return isArray(value) ? value : stringToPath(value)
                    }

                    function castSlice(array, start, end) {
                        var length = array.length;
                        return end = end === undefined ? length : end, !start && end >= length ? array : baseSlice(array, start, end)
                    }

                    function cloneBuffer(buffer, isDeep) {
                        if (isDeep)return buffer.slice();
                        var result = new buffer.constructor(buffer.length);
                        return buffer.copy(result), result
                    }

                    function cloneArrayBuffer(arrayBuffer) {
                        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                        return new Uint8Array(result).set(new Uint8Array(arrayBuffer)), result
                    }

                    function cloneDataView(dataView, isDeep) {
                        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)
                    }

                    function cloneMap(map, isDeep, cloneFunc) {
                        var array = isDeep ? cloneFunc(mapToArray(map), !0) : mapToArray(map);
                        return arrayReduce(array, addMapEntry, new map.constructor)
                    }

                    function cloneRegExp(regexp) {
                        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                        return result.lastIndex = regexp.lastIndex, result
                    }

                    function cloneSet(set, isDeep, cloneFunc) {
                        var array = isDeep ? cloneFunc(setToArray(set), !0) : setToArray(set);
                        return arrayReduce(array, addSetEntry, new set.constructor)
                    }

                    function cloneSymbol(symbol) {
                        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
                    }

                    function cloneTypedArray(typedArray, isDeep) {
                        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length)
                    }

                    function compareAscending(value, other) {
                        if (value !== other) {
                            var valIsDefined = value !== undefined, valIsNull = null === value, valIsReflexive = value === value, valIsSymbol = isSymbol(value), othIsDefined = other !== undefined, othIsNull = null === other, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive)return 1;
                            if (!valIsNull && !valIsSymbol && !othIsSymbol && other > value || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive)return -1
                        }
                        return 0
                    }

                    function compareMultiple(object, other, orders) {
                        for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length;) {
                            var result = compareAscending(objCriteria[index], othCriteria[index]);
                            if (result) {
                                if (index >= ordersLength)return result;
                                var order = orders[index];
                                return result * ("desc" == order ? -1 : 1)
                            }
                        }
                        return object.index - other.index
                    }

                    function composeArgs(args, partials, holders, isCurried) {
                        for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength;)result[leftIndex] = partials[leftIndex];
                        for (; ++argsIndex < holdersLength;)(isUncurried || argsLength > argsIndex) && (result[holders[argsIndex]] = args[argsIndex]);
                        for (; rangeLength--;)result[leftIndex++] = args[argsIndex++];
                        return result
                    }

                    function composeArgsRight(args, partials, holders, isCurried) {
                        for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength;)result[argsIndex] = args[argsIndex];
                        for (var offset = argsIndex; ++rightIndex < rightLength;)result[offset + rightIndex] = partials[rightIndex];
                        for (; ++holdersIndex < holdersLength;)(isUncurried || argsLength > argsIndex) && (result[offset + holders[holdersIndex]] = args[argsIndex++]);
                        return result
                    }

                    function copyArray(source, array) {
                        var index = -1, length = source.length;
                        for (array || (array = Array(length)); ++index < length;)array[index] = source[index];
                        return array
                    }

                    function copyObject(source, props, object, customizer) {
                        object || (object = {});
                        for (var index = -1, length = props.length; ++index < length;) {
                            var key = props[index], newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];
                            assignValue(object, key, newValue)
                        }
                        return object
                    }

                    function copySymbols(source, object) {
                        return copyObject(source, getSymbols(source), object)
                    }

                    function createAggregator(setter, initializer) {
                        return function (collection, iteratee) {
                            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                            return func(collection, setter, getIteratee(iteratee), accumulator)
                        }
                    }

                    function createAssigner(assigner) {
                        return rest(function (object, sources) {
                            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                            for (customizer = assigner.length > 3 && "function" == typeof customizer ? (length--, customizer) : undefined, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = 3 > length ? undefined : customizer, length = 1), object = Object(object); ++index < length;) {
                                var source = sources[index];
                                source && assigner(object, source, index, customizer)
                            }
                            return object
                        })
                    }

                    function createBaseEach(eachFunc, fromRight) {
                        return function (collection, iteratee) {
                            if (null == collection)return collection;
                            if (!isArrayLike(collection))return eachFunc(collection, iteratee);
                            for (var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection); (fromRight ? index-- : ++index < length) && iteratee(iterable[index], index, iterable) !== !1;);
                            return collection
                        }
                    }

                    function createBaseFor(fromRight) {
                        return function (object, iteratee, keysFunc) {
                            for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--;) {
                                var key = props[fromRight ? length : ++index];
                                if (iteratee(iterable[key], key, iterable) === !1)break
                            }
                            return object
                        }
                    }

                    function createBaseWrapper(func, bitmask, thisArg) {
                        function wrapper() {
                            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                            return fn.apply(isBind ? thisArg : this, arguments)
                        }

                        var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
                        return wrapper
                    }

                    function createCaseFirst(methodName) {
                        return function (string) {
                            string = toString(string);
                            var strSymbols = reHasComplexSymbol.test(string) ? stringToArray(string) : undefined, chr = strSymbols ? strSymbols[0] : string.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                            return chr[methodName]() + trailing
                        }
                    }

                    function createCompounder(callback) {
                        return function (string) {
                            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "")
                        }
                    }

                    function createCtorWrapper(Ctor) {
                        return function () {
                            var args = arguments;
                            switch (args.length) {
                                case 0:
                                    return new Ctor;
                                case 1:
                                    return new Ctor(args[0]);
                                case 2:
                                    return new Ctor(args[0], args[1]);
                                case 3:
                                    return new Ctor(args[0], args[1], args[2]);
                                case 4:
                                    return new Ctor(args[0], args[1], args[2], args[3]);
                                case 5:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                                case 6:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                                case 7:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6])
                            }
                            var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                            return isObject(result) ? result : thisBinding
                        }
                    }

                    function createCurryWrapper(func, bitmask, arity) {
                        function wrapper() {
                            for (var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper); index--;)args[index] = arguments[index];
                            var holders = 3 > length && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                            if (length -= holders.length, arity > length)return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
                            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                            return apply(fn, this, args)
                        }

                        var Ctor = createCtorWrapper(func);
                        return wrapper
                    }

                    function createFlow(fromRight) {
                        return rest(function (funcs) {
                            funcs = baseFlatten(funcs, 1);
                            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                            for (fromRight && funcs.reverse(); index--;) {
                                var func = funcs[index];
                                if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                                if (prereq && !wrapper && "wrapper" == getFuncName(func))var wrapper = new LodashWrapper([], !0)
                            }
                            for (index = wrapper ? index : length; ++index < length;) {
                                func = funcs[index];
                                var funcName = getFuncName(func), data = "wrapper" == funcName ? getData(func) : undefined;
                                wrapper = data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && 1 == data[9] ? wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func)
                            }
                            return function () {
                                var args = arguments, value = args[0];
                                if (wrapper && 1 == args.length && isArray(value) && value.length >= LARGE_ARRAY_SIZE)return wrapper.plant(value).value();
                                for (var index = 0, result = length ? funcs[index].apply(this, args) : value; ++index < length;)result = funcs[index].call(this, result);
                                return result
                            }
                        })
                    }

                    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                        function wrapper() {
                            for (var length = arguments.length, args = Array(length), index = length; index--;)args[index] = arguments[index];
                            if (isCurried)var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                            if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)), length -= holdersCount, isCurried && arity > length) {
                                var newHolders = replaceHolders(args, placeholder);
                                return createRecurryWrapper(func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length)
                            }
                            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                            return length = args.length, argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse(), isAry && length > ary && (args.length = ary), this && this !== root && this instanceof wrapper && (fn = Ctor || createCtorWrapper(fn)), fn.apply(thisBinding, args)
                        }

                        var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG), isFlip = bitmask & FLIP_FLAG, Ctor = isBindKey ? undefined : createCtorWrapper(func);
                        return wrapper
                    }

                    function createInverter(setter, toIteratee) {
                        return function (object, iteratee) {
                            return baseInverter(object, setter, toIteratee(iteratee), {})
                        }
                    }

                    function createMathOperation(operator) {
                        return function (value, other) {
                            var result;
                            if (value === undefined && other === undefined)return 0;
                            if (value !== undefined && (result = value), other !== undefined) {
                                if (result === undefined)return other;
                                "string" == typeof value || "string" == typeof other ? (value = baseToString(value), other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)), result = operator(value, other)
                            }
                            return result
                        }
                    }

                    function createOver(arrayFunc) {
                        return rest(function (iteratees) {
                            return iteratees = 1 == iteratees.length && isArray(iteratees[0]) ? arrayMap(iteratees[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(iteratees, 1, isFlattenableIteratee), baseUnary(getIteratee())), rest(function (args) {
                                var thisArg = this;
                                return arrayFunc(iteratees, function (iteratee) {
                                    return apply(iteratee, thisArg, args)
                                })
                            })
                        })
                    }

                    function createPadding(length, chars) {
                        chars = chars === undefined ? " " : baseToString(chars);
                        var charsLength = chars.length;
                        if (2 > charsLength)return charsLength ? baseRepeat(chars, length) : chars;
                        var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                        return reHasComplexSymbol.test(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length)
                    }

                    function createPartialWrapper(func, bitmask, thisArg, partials) {
                        function wrapper() {
                            for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength;)args[leftIndex] = partials[leftIndex];
                            for (; argsLength--;)args[leftIndex++] = arguments[++argsIndex];
                            return apply(fn, isBind ? thisArg : this, args)
                        }

                        var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
                        return wrapper
                    }

                    function createRange(fromRight) {
                        return function (start, end, step) {
                            return step && "number" != typeof step && isIterateeCall(start, end, step) && (end = step = undefined), start = toNumber(start), start = start === start ? start : 0, end === undefined ? (end = start, start = 0) : end = toNumber(end) || 0, step = step === undefined ? end > start ? 1 : -1 : toNumber(step) || 0, baseRange(start, end, step, fromRight)
                        }
                    }

                    function createRelationalOperation(operator) {
                        return function (value, other) {
                            return "string" == typeof value && "string" == typeof other || (value = toNumber(value), other = toNumber(other)), operator(value, other)
                        }
                    }

                    function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                        var isCurry = bitmask & CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
                        bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG, bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG), bitmask & CURRY_BOUND_FLAG || (bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG));
                        var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity], result = wrapFunc.apply(undefined, newData);
                        return isLaziable(func) && setData(result, newData), result.placeholder = placeholder, result
                    }

                    function createRound(methodName) {
                        var func = Math[methodName];
                        return function (number, precision) {
                            if (number = toNumber(number), precision = toInteger(precision)) {
                                var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                                return pair = (toString(value) + "e").split("e"), +(pair[0] + "e" + (+pair[1] - precision))
                            }
                            return func(number)
                        }
                    }

                    function createToPairs(keysFunc) {
                        return function (object) {
                            var tag = getTag(object);
                            return tag == mapTag ? mapToArray(object) : tag == setTag ? setToPairs(object) : baseToPairs(object, keysFunc(object))
                        }
                    }

                    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                        var isBindKey = bitmask & BIND_KEY_FLAG;
                        if (!isBindKey && "function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        var length = partials ? partials.length : 0;
                        if (length || (bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG), partials = holders = undefined), ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0), arity = arity === undefined ? arity : toInteger(arity), length -= holders ? holders.length : 0, bitmask & PARTIAL_RIGHT_FLAG) {
                            var partialsRight = partials, holdersRight = holders;
                            partials = holders = undefined
                        }
                        var data = isBindKey ? undefined : getData(func), newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
                        if (data && mergeData(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2], partials = newData[3], holders = newData[4], arity = newData[9] = null == newData[9] ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0), !arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG) && (bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG)), bitmask && bitmask != BIND_FLAG)result = bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG ? createCurryWrapper(func, bitmask, arity) : bitmask != PARTIAL_FLAG && bitmask != (BIND_FLAG | PARTIAL_FLAG) || holders.length ? createHybridWrapper.apply(undefined, newData) : createPartialWrapper(func, bitmask, thisArg, partials); else var result = createBaseWrapper(func, bitmask, thisArg);
                        var setter = data ? baseSetData : setData;
                        return setter(result, newData)
                    }

                    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
                        var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
                        if (arrLength != othLength && !(isPartial && othLength > arrLength))return !1;
                        var stacked = stack.get(array);
                        if (stacked)return stacked == other;
                        var index = -1, result = !0, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache : undefined;
                        for (stack.set(array, other); ++index < arrLength;) {
                            var arrValue = array[index], othValue = other[index];
                            if (customizer)var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                            if (compared !== undefined) {
                                if (compared)continue;
                                result = !1;
                                break
                            }
                            if (seen) {
                                if (!arraySome(other, function (othValue, othIndex) {
                                        return seen.has(othIndex) || arrValue !== othValue && !equalFunc(arrValue, othValue, customizer, bitmask, stack) ? void 0 : seen.add(othIndex)
                                    })) {
                                    result = !1;
                                    break
                                }
                            } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, customizer, bitmask, stack)) {
                                result = !1;
                                break
                            }
                        }
                        return stack["delete"](array), result
                    }

                    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
                        switch (tag) {
                            case dataViewTag:
                                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset)return !1;
                                object = object.buffer, other = other.buffer;
                            case arrayBufferTag:
                                return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other)));
                            case boolTag:
                            case dateTag:
                                return +object == +other;
                            case errorTag:
                                return object.name == other.name && object.message == other.message;
                            case numberTag:
                                return object != +object ? other != +other : object == +other;
                            case regexpTag:
                            case stringTag:
                                return object == other + "";
                            case mapTag:
                                var convert = mapToArray;
                            case setTag:
                                var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                                if (convert || (convert = setToArray), object.size != other.size && !isPartial)return !1;
                                var stacked = stack.get(object);
                                return stacked ? stacked == other : (bitmask |= UNORDERED_COMPARE_FLAG, stack.set(object, other), equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack));
                            case symbolTag:
                                if (symbolValueOf)return symbolValueOf.call(object) == symbolValueOf.call(other)
                        }
                        return !1
                    }

                    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
                        var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
                        if (objLength != othLength && !isPartial)return !1;
                        for (var index = objLength; index--;) {
                            var key = objProps[index];
                            if (!(isPartial ? key in other : baseHas(other, key)))return !1
                        }
                        var stacked = stack.get(object);
                        if (stacked)return stacked == other;
                        var result = !0;
                        stack.set(object, other);
                        for (var skipCtor = isPartial; ++index < objLength;) {
                            key = objProps[index];
                            var objValue = object[key], othValue = other[key];
                            if (customizer)var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                            if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
                                result = !1;
                                break
                            }
                            skipCtor || (skipCtor = "constructor" == key)
                        }
                        if (result && !skipCtor) {
                            var objCtor = object.constructor, othCtor = other.constructor;
                            objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = !1)
                        }
                        return stack["delete"](object), result
                    }

                    function getAllKeys(object) {
                        return baseGetAllKeys(object, keys, getSymbols)
                    }

                    function getAllKeysIn(object) {
                        return baseGetAllKeys(object, keysIn, getSymbolsIn)
                    }

                    function getFuncName(func) {
                        for (var result = func.name + "", array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0; length--;) {
                            var data = array[length], otherFunc = data.func;
                            if (null == otherFunc || otherFunc == func)return data.name
                        }
                        return result
                    }

                    function getHolder(func) {
                        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
                        return object.placeholder
                    }

                    function getIteratee() {
                        var result = lodash.iteratee || iteratee;
                        return result = result === iteratee ? baseIteratee : result, arguments.length ? result(arguments[0], arguments[1]) : result
                    }

                    function getMapData(map, key) {
                        var data = map.__data__;
                        return isKeyable(key) ? data["string" == typeof key ? "string" : "hash"] : data.map
                    }

                    function getMatchData(object) {
                        for (var result = toPairs(object), length = result.length; length--;)result[length][2] = isStrictComparable(result[length][1]);
                        return result
                    }

                    function getNative(object, key) {
                        var value = object[key];
                        return isNative(value) ? value : undefined
                    }

                    function getPrototype(value) {
                        return nativeGetPrototype(Object(value))
                    }

                    function getSymbols(object) {
                        return getOwnPropertySymbols(Object(object))
                    }

                    function getTag(value) {
                        return objectToString.call(value)
                    }

                    function getView(start, end, transforms) {
                        for (var index = -1, length = transforms.length; ++index < length;) {
                            var data = transforms[index], size = data.size;
                            switch (data.type) {
                                case"drop":
                                    start += size;
                                    break;
                                case"dropRight":
                                    end -= size;
                                    break;
                                case"take":
                                    end = nativeMin(end, start + size);
                                    break;
                                case"takeRight":
                                    start = nativeMax(start, end - size)
                            }
                        }
                        return {start: start, end: end}
                    }

                    function hasPath(object, path, hasFunc) {
                        path = isKey(path, object) ? [path] : castPath(path);
                        for (var result, index = -1, length = path.length; ++index < length;) {
                            var key = toKey(path[index]);
                            if (!(result = null != object && hasFunc(object, key)))break;
                            object = object[key]
                        }
                        if (result)return result;
                        var length = object ? object.length : 0;
                        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isString(object) || isArguments(object))
                    }

                    function initCloneArray(array) {
                        var length = array.length, result = array.constructor(length);
                        return length && "string" == typeof array[0] && hasOwnProperty.call(array, "index") && (result.index = array.index, result.input = array.input), result
                    }

                    function initCloneObject(object) {
                        return "function" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object))
                    }

                    function initCloneByTag(object, tag, cloneFunc, isDeep) {
                        var Ctor = object.constructor;
                        switch (tag) {
                            case arrayBufferTag:
                                return cloneArrayBuffer(object);
                            case boolTag:
                            case dateTag:
                                return new Ctor(+object);
                            case dataViewTag:
                                return cloneDataView(object, isDeep);
                            case float32Tag:
                            case float64Tag:
                            case int8Tag:
                            case int16Tag:
                            case int32Tag:
                            case uint8Tag:
                            case uint8ClampedTag:
                            case uint16Tag:
                            case uint32Tag:
                                return cloneTypedArray(object, isDeep);
                            case mapTag:
                                return cloneMap(object, isDeep, cloneFunc);
                            case numberTag:
                            case stringTag:
                                return new Ctor(object);
                            case regexpTag:
                                return cloneRegExp(object);
                            case setTag:
                                return cloneSet(object, isDeep, cloneFunc);
                            case symbolTag:
                                return cloneSymbol(object)
                        }
                    }

                    function indexKeys(object) {
                        var length = object ? object.length : undefined;
                        return isLength(length) && (isArray(object) || isString(object) || isArguments(object)) ? baseTimes(length, String) : null
                    }

                    function isFlattenable(value) {
                        return isArray(value) || isArguments(value)
                    }

                    function isFlattenableIteratee(value) {
                        return isArray(value) && !(2 == value.length && !isFunction(value[0]))
                    }

                    function isIndex(value, length) {
                        return length = null == length ? MAX_SAFE_INTEGER : length, !!length && ("number" == typeof value || reIsUint.test(value)) && value > -1 && value % 1 == 0 && length > value
                    }

                    function isIterateeCall(value, index, object) {
                        if (!isObject(object))return !1;
                        var type = typeof index;
                        return ("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) ? eq(object[index], value) : !1
                    }

                    function isKey(value, object) {
                        if (isArray(value))return !1;
                        var type = typeof value;
                        return "number" == type || "symbol" == type || "boolean" == type || null == value || isSymbol(value) ? !0 : reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object && value in Object(object)
                    }

                    function isKeyable(value) {
                        var type = typeof value;
                        return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value
                    }

                    function isLaziable(func) {
                        var funcName = getFuncName(func), other = lodash[funcName];
                        if ("function" != typeof other || !(funcName in LazyWrapper.prototype))return !1;
                        if (func === other)return !0;
                        var data = getData(other);
                        return !!data && func === data[0]
                    }

                    function isPrototype(value) {
                        var Ctor = value && value.constructor, proto = "function" == typeof Ctor && Ctor.prototype || objectProto;
                        return value === proto
                    }

                    function isStrictComparable(value) {
                        return value === value && !isObject(value)
                    }

                    function matchesStrictComparable(key, srcValue) {
                        return function (object) {
                            return null == object ? !1 : object[key] === srcValue && (srcValue !== undefined || key in Object(object))
                        }
                    }

                    function mergeData(data, source) {
                        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG) > newBitmask, isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && source[7].length <= source[8] && bitmask == CURRY_FLAG;
                        if (!isCommon && !isCombo)return data;
                        srcBitmask & BIND_FLAG && (data[2] = source[2], newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG);
                        var value = source[3];
                        if (value) {
                            var partials = data[3];
                            data[3] = partials ? composeArgs(partials, value, source[4]) : value, data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4]
                        }
                        return value = source[5], value && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source[6]) : value, data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]), value = source[7], value && (data[7] = value), srcBitmask & ARY_FLAG && (data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8])), null == data[9] && (data[9] = source[9]), data[0] = source[0], data[1] = newBitmask, data
                    }

                    function mergeDefaults(objValue, srcValue, key, object, source, stack) {
                        return isObject(objValue) && isObject(srcValue) && baseMerge(objValue, srcValue, undefined, mergeDefaults, stack.set(srcValue, objValue)), objValue
                    }

                    function parent(object, path) {
                        return 1 == path.length ? object : baseGet(object, baseSlice(path, 0, -1))
                    }

                    function reorder(array, indexes) {
                        for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); length--;) {
                            var index = indexes[length];
                            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined
                        }
                        return array
                    }

                    function toKey(value) {
                        if ("string" == typeof value || isSymbol(value))return value;
                        var result = value + "";
                        return "0" == result && 1 / value == -INFINITY ? "-0" : result
                    }

                    function toSource(func) {
                        if (null != func) {
                            try {
                                return funcToString.call(func)
                            } catch (e) {
                            }
                            try {
                                return func + ""
                            } catch (e) {
                            }
                        }
                        return ""
                    }

                    function wrapperClone(wrapper) {
                        if (wrapper instanceof LazyWrapper)return wrapper.clone();
                        var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                        return result.__actions__ = copyArray(wrapper.__actions__), result.__index__ = wrapper.__index__, result.__values__ = wrapper.__values__, result
                    }

                    function chunk(array, size, guard) {
                        size = (guard ? isIterateeCall(array, size, guard) : size === undefined) ? 1 : nativeMax(toInteger(size), 0);
                        var length = array ? array.length : 0;
                        if (!length || 1 > size)return [];
                        for (var index = 0, resIndex = 0, result = Array(nativeCeil(length / size)); length > index;)result[resIndex++] = baseSlice(array, index, index += size);
                        return result
                    }

                    function compact(array) {
                        for (var index = -1, length = array ? array.length : 0, resIndex = 0, result = []; ++index < length;) {
                            var value = array[index];
                            value && (result[resIndex++] = value)
                        }
                        return result
                    }

                    function concat() {
                        for (var length = arguments.length, args = Array(length ? length - 1 : 0), array = arguments[0], index = length; index--;)args[index - 1] = arguments[index];
                        return length ? arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1)) : []
                    }

                    function drop(array, n, guard) {
                        var length = array ? array.length : 0;
                        return length ? (n = guard || n === undefined ? 1 : toInteger(n), baseSlice(array, 0 > n ? 0 : n, length)) : []
                    }

                    function dropRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        return length ? (n = guard || n === undefined ? 1 : toInteger(n), n = length - n, baseSlice(array, 0, 0 > n ? 0 : n)) : []
                    }

                    function dropRightWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0, !0) : []
                    }

                    function dropWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0) : []
                    }

                    function fill(array, value, start, end) {
                        var length = array ? array.length : 0;
                        return length ? (start && "number" != typeof start && isIterateeCall(array, value, start) && (start = 0, end = length), baseFill(array, value, start, end)) : []
                    }

                    function findIndex(array, predicate) {
                        return array && array.length ? baseFindIndex(array, getIteratee(predicate, 3)) : -1
                    }

                    function findLastIndex(array, predicate) {
                        return array && array.length ? baseFindIndex(array, getIteratee(predicate, 3), !0) : -1
                    }

                    function flatten(array) {
                        var length = array ? array.length : 0;
                        return length ? baseFlatten(array, 1) : []
                    }

                    function flattenDeep(array) {
                        var length = array ? array.length : 0;
                        return length ? baseFlatten(array, INFINITY) : []
                    }

                    function flattenDepth(array, depth) {
                        var length = array ? array.length : 0;
                        return length ? (depth = depth === undefined ? 1 : toInteger(depth), baseFlatten(array, depth)) : []
                    }

                    function fromPairs(pairs) {
                        for (var index = -1, length = pairs ? pairs.length : 0, result = {}; ++index < length;) {
                            var pair = pairs[index];
                            result[pair[0]] = pair[1]
                        }
                        return result
                    }

                    function head(array) {
                        return array && array.length ? array[0] : undefined
                    }

                    function indexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        return length ? (fromIndex = toInteger(fromIndex), 0 > fromIndex && (fromIndex = nativeMax(length + fromIndex, 0)), baseIndexOf(array, value, fromIndex)) : -1
                    }

                    function initial(array) {
                        return dropRight(array, 1)
                    }

                    function join(array, separator) {
                        return array ? nativeJoin.call(array, separator) : ""
                    }

                    function last(array) {
                        var length = array ? array.length : 0;
                        return length ? array[length - 1] : undefined
                    }

                    function lastIndexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        if (!length)return -1;
                        var index = length;
                        if (fromIndex !== undefined && (index = toInteger(fromIndex), index = (0 > index ? nativeMax(length + index, 0) : nativeMin(index, length - 1)) + 1), value !== value)return indexOfNaN(array, index, !0);
                        for (; index--;)if (array[index] === value)return index;
                        return -1
                    }

                    function nth(array, n) {
                        return array && array.length ? baseNth(array, toInteger(n)) : undefined
                    }

                    function pullAll(array, values) {
                        return array && array.length && values && values.length ? basePullAll(array, values) : array
                    }

                    function pullAllBy(array, values, iteratee) {
                        return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee)) : array
                    }

                    function pullAllWith(array, values, comparator) {
                        return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array
                    }

                    function remove(array, predicate) {
                        var result = [];
                        if (!array || !array.length)return result;
                        var index = -1, indexes = [], length = array.length;
                        for (predicate = getIteratee(predicate, 3); ++index < length;) {
                            var value = array[index];
                            predicate(value, index, array) && (result.push(value), indexes.push(index))
                        }
                        return basePullAt(array, indexes), result
                    }

                    function reverse(array) {
                        return array ? nativeReverse.call(array) : array
                    }

                    function slice(array, start, end) {
                        var length = array ? array.length : 0;
                        return length ? (end && "number" != typeof end && isIterateeCall(array, start, end) ? (start = 0, end = length) : (start = null == start ? 0 : toInteger(start), end = end === undefined ? length : toInteger(end)), baseSlice(array, start, end)) : []
                    }

                    function sortedIndex(array, value) {
                        return baseSortedIndex(array, value)
                    }

                    function sortedIndexBy(array, value, iteratee) {
                        return baseSortedIndexBy(array, value, getIteratee(iteratee))
                    }

                    function sortedIndexOf(array, value) {
                        var length = array ? array.length : 0;
                        if (length) {
                            var index = baseSortedIndex(array, value);
                            if (length > index && eq(array[index], value))return index
                        }
                        return -1
                    }

                    function sortedLastIndex(array, value) {
                        return baseSortedIndex(array, value, !0)
                    }

                    function sortedLastIndexBy(array, value, iteratee) {
                        return baseSortedIndexBy(array, value, getIteratee(iteratee), !0)
                    }

                    function sortedLastIndexOf(array, value) {
                        var length = array ? array.length : 0;
                        if (length) {
                            var index = baseSortedIndex(array, value, !0) - 1;
                            if (eq(array[index], value))return index
                        }
                        return -1
                    }

                    function sortedUniq(array) {
                        return array && array.length ? baseSortedUniq(array) : []
                    }

                    function sortedUniqBy(array, iteratee) {
                        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee)) : []
                    }

                    function tail(array) {
                        return drop(array, 1)
                    }

                    function take(array, n, guard) {
                        return array && array.length ? (n = guard || n === undefined ? 1 : toInteger(n), baseSlice(array, 0, 0 > n ? 0 : n)) : []
                    }

                    function takeRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        return length ? (n = guard || n === undefined ? 1 : toInteger(n), n = length - n, baseSlice(array, 0 > n ? 0 : n, length)) : []
                    }

                    function takeRightWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !1, !0) : []
                    }

                    function takeWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : []
                    }

                    function uniq(array) {
                        return array && array.length ? baseUniq(array) : []
                    }

                    function uniqBy(array, iteratee) {
                        return array && array.length ? baseUniq(array, getIteratee(iteratee)) : []
                    }

                    function uniqWith(array, comparator) {
                        return array && array.length ? baseUniq(array, undefined, comparator) : []
                    }

                    function unzip(array) {
                        if (!array || !array.length)return [];
                        var length = 0;
                        return array = arrayFilter(array, function (group) {
                            return isArrayLikeObject(group) ? (length = nativeMax(group.length, length), !0) : void 0
                        }), baseTimes(length, function (index) {
                            return arrayMap(array, baseProperty(index))
                        })
                    }

                    function unzipWith(array, iteratee) {
                        if (!array || !array.length)return [];
                        var result = unzip(array);
                        return null == iteratee ? result : arrayMap(result, function (group) {
                            return apply(iteratee, undefined, group)
                        })
                    }

                    function zipObject(props, values) {
                        return baseZipObject(props || [], values || [], assignValue)
                    }

                    function zipObjectDeep(props, values) {
                        return baseZipObject(props || [], values || [], baseSet)
                    }

                    function chain(value) {
                        var result = lodash(value);
                        return result.__chain__ = !0, result
                    }

                    function tap(value, interceptor) {
                        return interceptor(value), value
                    }

                    function thru(value, interceptor) {
                        return interceptor(value)
                    }

                    function wrapperChain() {
                        return chain(this)
                    }

                    function wrapperCommit() {
                        return new LodashWrapper(this.value(), this.__chain__)
                    }

                    function wrapperNext() {
                        this.__values__ === undefined && (this.__values__ = toArray(this.value()));
                        var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
                        return {done: done, value: value}
                    }

                    function wrapperToIterator() {
                        return this
                    }

                    function wrapperPlant(value) {
                        for (var result, parent = this; parent instanceof baseLodash;) {
                            var clone = wrapperClone(parent);
                            clone.__index__ = 0, clone.__values__ = undefined, result ? previous.__wrapped__ = clone : result = clone;
                            var previous = clone;
                            parent = parent.__wrapped__
                        }
                        return previous.__wrapped__ = value, result
                    }

                    function wrapperReverse() {
                        var value = this.__wrapped__;
                        if (value instanceof LazyWrapper) {
                            var wrapped = value;
                            return this.__actions__.length && (wrapped = new LazyWrapper(this)), wrapped = wrapped.reverse(), wrapped.__actions__.push({
                                func: thru,
                                args: [reverse],
                                thisArg: undefined
                            }), new LodashWrapper(wrapped, this.__chain__)
                        }
                        return this.thru(reverse)
                    }

                    function wrapperValue() {
                        return baseWrapperValue(this.__wrapped__, this.__actions__)
                    }

                    function every(collection, predicate, guard) {
                        var func = isArray(collection) ? arrayEvery : baseEvery;
                        return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined), func(collection, getIteratee(predicate, 3))
                    }

                    function filter(collection, predicate) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        return func(collection, getIteratee(predicate, 3))
                    }

                    function find(collection, predicate) {
                        if (predicate = getIteratee(predicate, 3), isArray(collection)) {
                            var index = baseFindIndex(collection, predicate);
                            return index > -1 ? collection[index] : undefined
                        }
                        return baseFind(collection, predicate, baseEach)
                    }

                    function findLast(collection, predicate) {
                        if (predicate = getIteratee(predicate, 3), isArray(collection)) {
                            var index = baseFindIndex(collection, predicate, !0);
                            return index > -1 ? collection[index] : undefined
                        }
                        return baseFind(collection, predicate, baseEachRight)
                    }

                    function flatMap(collection, iteratee) {
                        return baseFlatten(map(collection, iteratee), 1)
                    }

                    function flatMapDeep(collection, iteratee) {
                        return baseFlatten(map(collection, iteratee), INFINITY)
                    }

                    function flatMapDepth(collection, iteratee, depth) {
                        return depth = depth === undefined ? 1 : toInteger(depth), baseFlatten(map(collection, iteratee), depth)
                    }

                    function forEach(collection, iteratee) {
                        var func = isArray(collection) ? arrayEach : baseEach;
                        return func(collection, getIteratee(iteratee, 3))
                    }

                    function forEachRight(collection, iteratee) {
                        var func = isArray(collection) ? arrayEachRight : baseEachRight;
                        return func(collection, getIteratee(iteratee, 3))
                    }

                    function includes(collection, value, fromIndex, guard) {
                        collection = isArrayLike(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                        var length = collection.length;
                        return 0 > fromIndex && (fromIndex = nativeMax(length + fromIndex, 0)), isString(collection) ? length >= fromIndex && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1
                    }

                    function map(collection, iteratee) {
                        var func = isArray(collection) ? arrayMap : baseMap;
                        return func(collection, getIteratee(iteratee, 3))
                    }

                    function orderBy(collection, iteratees, orders, guard) {
                        return null == collection ? [] : (isArray(iteratees) || (iteratees = null == iteratees ? [] : [iteratees]), orders = guard ? undefined : orders, isArray(orders) || (orders = null == orders ? [] : [orders]), baseOrderBy(collection, iteratees, orders))
                    }

                    function reduce(collection, iteratee, accumulator) {
                        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach)
                    }

                    function reduceRight(collection, iteratee, accumulator) {
                        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight)
                    }

                    function reject(collection, predicate) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        return predicate = getIteratee(predicate, 3), func(collection, function (value, index, collection) {
                            return !predicate(value, index, collection)
                        })
                    }

                    function sample(collection) {
                        var array = isArrayLike(collection) ? collection : values(collection), length = array.length;
                        return length > 0 ? array[baseRandom(0, length - 1)] : undefined
                    }

                    function sampleSize(collection, n, guard) {
                        var index = -1, result = toArray(collection), length = result.length, lastIndex = length - 1;
                        for (n = (guard ? isIterateeCall(collection, n, guard) : n === undefined) ? 1 : baseClamp(toInteger(n), 0, length); ++index < n;) {
                            var rand = baseRandom(index, lastIndex), value = result[rand];
                            result[rand] = result[index], result[index] = value
                        }
                        return result.length = n, result
                    }

                    function shuffle(collection) {
                        return sampleSize(collection, MAX_ARRAY_LENGTH)
                    }

                    function size(collection) {
                        if (null == collection)return 0;
                        if (isArrayLike(collection)) {
                            var result = collection.length;
                            return result && isString(collection) ? stringSize(collection) : result
                        }
                        if (isObjectLike(collection)) {
                            var tag = getTag(collection);
                            if (tag == mapTag || tag == setTag)return collection.size
                        }
                        return keys(collection).length
                    }

                    function some(collection, predicate, guard) {
                        var func = isArray(collection) ? arraySome : baseSome;
                        return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined), func(collection, getIteratee(predicate, 3))
                    }

                    function after(n, func) {
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        return n = toInteger(n), function () {
                            return --n < 1 ? func.apply(this, arguments) : void 0
                        }
                    }

                    function ary(func, n, guard) {
                        return n = guard ? undefined : n, n = func && null == n ? func.length : n, createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n)
                    }

                    function before(n, func) {
                        var result;
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        return n = toInteger(n), function () {
                            return --n > 0 && (result = func.apply(this, arguments)), 1 >= n && (func = undefined), result
                        }
                    }

                    function curry(func, arity, guard) {
                        arity = guard ? undefined : arity;
                        var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                        return result.placeholder = curry.placeholder, result
                    }

                    function curryRight(func, arity, guard) {
                        arity = guard ? undefined : arity;
                        var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                        return result.placeholder = curryRight.placeholder, result
                    }

                    function debounce(func, wait, options) {
                        function invokeFunc(time) {
                            var args = lastArgs, thisArg = lastThis;
                            return lastArgs = lastThis = undefined, lastInvokeTime = time, result = func.apply(thisArg, args)
                        }

                        function leadingEdge(time) {
                            return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result
                        }

                        function remainingWait(time) {
                            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                            return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result
                        }

                        function shouldInvoke(time) {
                            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                            return !lastCallTime || timeSinceLastCall >= wait || 0 > timeSinceLastCall || maxing && timeSinceLastInvoke >= maxWait
                        }

                        function timerExpired() {
                            var time = now();
                            return shouldInvoke(time) ? trailingEdge(time) : void(timerId = setTimeout(timerExpired, remainingWait(time)))
                        }

                        function trailingEdge(time) {
                            return clearTimeout(timerId), timerId = undefined, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined, result)
                        }

                        function cancel() {
                            timerId !== undefined && clearTimeout(timerId), lastCallTime = lastInvokeTime = 0, lastArgs = lastThis = timerId = undefined
                        }

                        function flush() {
                            return timerId === undefined ? result : trailingEdge(now())
                        }

                        function debounced() {
                            var time = now(), isInvoking = shouldInvoke(time);
                            if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                                if (timerId === undefined)return leadingEdge(lastCallTime);
                                if (maxing)return clearTimeout(timerId), timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime)
                            }
                            return timerId === undefined && (timerId = setTimeout(timerExpired, wait)), result
                        }

                        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime = 0, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel, debounced.flush = flush, debounced
                    }

                    function flip(func) {
                        return createWrapper(func, FLIP_FLAG)
                    }

                    function memoize(func, resolver) {
                        if ("function" != typeof func || resolver && "function" != typeof resolver)throw new TypeError(FUNC_ERROR_TEXT);
                        var memoized = function () {
                            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                            if (cache.has(key))return cache.get(key);
                            var result = func.apply(this, args);
                            return memoized.cache = cache.set(key, result), result
                        };
                        return memoized.cache = new (memoize.Cache || MapCache), memoized
                    }

                    function negate(predicate) {
                        if ("function" != typeof predicate)throw new TypeError(FUNC_ERROR_TEXT);
                        return function () {
                            return !predicate.apply(this, arguments)
                        }
                    }

                    function once(func) {
                        return before(2, func)
                    }

                    function rest(func, start) {
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        return start = nativeMax(start === undefined ? func.length - 1 : toInteger(start), 0), function () {
                            for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length;)array[index] = args[start + index];
                            switch (start) {
                                case 0:
                                    return func.call(this, array);
                                case 1:
                                    return func.call(this, args[0], array);
                                case 2:
                                    return func.call(this, args[0], args[1], array)
                            }
                            var otherArgs = Array(start + 1);
                            for (index = -1; ++index < start;)otherArgs[index] = args[index];
                            return otherArgs[start] = array, apply(func, this, otherArgs)
                        }
                    }

                    function spread(func, start) {
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        return start = start === undefined ? 0 : nativeMax(toInteger(start), 0), rest(function (args) {
                            var array = args[start], otherArgs = castSlice(args, 0, start);
                            return array && arrayPush(otherArgs, array), apply(func, this, otherArgs)
                        })
                    }

                    function throttle(func, wait, options) {
                        var leading = !0, trailing = !0;
                        if ("function" != typeof func)throw new TypeError(FUNC_ERROR_TEXT);
                        return isObject(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce(func, wait, {
                            leading: leading,
                            maxWait: wait,
                            trailing: trailing
                        })
                    }

                    function unary(func) {
                        return ary(func, 1)
                    }

                    function wrap(value, wrapper) {
                        return wrapper = null == wrapper ? identity : wrapper, partial(wrapper, value)
                    }

                    function castArray() {
                        if (!arguments.length)return [];
                        var value = arguments[0];
                        return isArray(value) ? value : [value]
                    }

                    function clone(value) {
                        return baseClone(value, !1, !0)
                    }

                    function cloneWith(value, customizer) {
                        return baseClone(value, !1, !0, customizer)
                    }

                    function cloneDeep(value) {
                        return baseClone(value, !0, !0)
                    }

                    function cloneDeepWith(value, customizer) {
                        return baseClone(value, !0, !0, customizer)
                    }

                    function eq(value, other) {
                        return value === other || value !== value && other !== other
                    }

                    function isArguments(value) {
                        return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag)
                    }

                    function isArrayBuffer(value) {
                        return isObjectLike(value) && objectToString.call(value) == arrayBufferTag
                    }

                    function isArrayLike(value) {
                        return null != value && isLength(getLength(value)) && !isFunction(value)
                    }

                    function isArrayLikeObject(value) {
                        return isObjectLike(value) && isArrayLike(value)
                    }

                    function isBoolean(value) {
                        return value === !0 || value === !1 || isObjectLike(value) && objectToString.call(value) == boolTag
                    }

                    function isDate(value) {
                        return isObjectLike(value) && objectToString.call(value) == dateTag
                    }

                    function isElement(value) {
                        return !!value && 1 === value.nodeType && isObjectLike(value) && !isPlainObject(value)
                    }

                    function isEmpty(value) {
                        if (isArrayLike(value) && (isArray(value) || isString(value) || isFunction(value.splice) || isArguments(value) || isBuffer(value)))return !value.length;
                        if (isObjectLike(value)) {
                            var tag = getTag(value);
                            if (tag == mapTag || tag == setTag)return !value.size
                        }
                        for (var key in value)if (hasOwnProperty.call(value, key))return !1;
                        return !(nonEnumShadows && keys(value).length)
                    }

                    function isEqual(value, other) {
                        return baseIsEqual(value, other)
                    }

                    function isEqualWith(value, other, customizer) {
                        customizer = "function" == typeof customizer ? customizer : undefined;
                        var result = customizer ? customizer(value, other) : undefined;
                        return result === undefined ? baseIsEqual(value, other, customizer) : !!result
                    }

                    function isError(value) {
                        return isObjectLike(value) ? objectToString.call(value) == errorTag || "string" == typeof value.message && "string" == typeof value.name : !1
                    }

                    function isFinite(value) {
                        return "number" == typeof value && nativeIsFinite(value)
                    }

                    function isFunction(value) {
                        var tag = isObject(value) ? objectToString.call(value) : "";
                        return tag == funcTag || tag == genTag
                    }

                    function isInteger(value) {
                        return "number" == typeof value && value == toInteger(value)
                    }

                    function isLength(value) {
                        return "number" == typeof value && value > -1 && value % 1 == 0 && MAX_SAFE_INTEGER >= value
                    }

                    function isObject(value) {
                        var type = typeof value;
                        return !!value && ("object" == type || "function" == type)
                    }

                    function isObjectLike(value) {
                        return !!value && "object" == typeof value
                    }

                    function isMap(value) {
                        return isObjectLike(value) && getTag(value) == mapTag
                    }

                    function isMatch(object, source) {
                        return object === source || baseIsMatch(object, source, getMatchData(source))
                    }

                    function isMatchWith(object, source, customizer) {
                        return customizer = "function" == typeof customizer ? customizer : undefined, baseIsMatch(object, source, getMatchData(source), customizer)
                    }

                    function isNaN(value) {
                        return isNumber(value) && value != +value
                    }

                    function isNative(value) {
                        if (!isObject(value))return !1;
                        var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
                        return pattern.test(toSource(value))
                    }

                    function isNull(value) {
                        return null === value
                    }

                    function isNil(value) {
                        return null == value
                    }

                    function isNumber(value) {
                        return "number" == typeof value || isObjectLike(value) && objectToString.call(value) == numberTag
                    }

                    function isPlainObject(value) {
                        if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value))return !1;
                        var proto = getPrototype(value);
                        if (null === proto)return !0;
                        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                        return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString
                    }

                    function isRegExp(value) {
                        return isObject(value) && objectToString.call(value) == regexpTag
                    }

                    function isSafeInteger(value) {
                        return isInteger(value) && value >= -MAX_SAFE_INTEGER && MAX_SAFE_INTEGER >= value
                    }

                    function isSet(value) {
                        return isObjectLike(value) && getTag(value) == setTag
                    }

                    function isString(value) {
                        return "string" == typeof value || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag
                    }

                    function isSymbol(value) {
                        return "symbol" == typeof value || isObjectLike(value) && objectToString.call(value) == symbolTag
                    }

                    function isTypedArray(value) {
                        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)]
                    }

                    function isUndefined(value) {
                        return value === undefined
                    }

                    function isWeakMap(value) {
                        return isObjectLike(value) && getTag(value) == weakMapTag
                    }

                    function isWeakSet(value) {
                        return isObjectLike(value) && objectToString.call(value) == weakSetTag
                    }

                    function toArray(value) {
                        if (!value)return [];
                        if (isArrayLike(value))return isString(value) ? stringToArray(value) : copyArray(value);
                        if (iteratorSymbol && value[iteratorSymbol])return iteratorToArray(value[iteratorSymbol]());
                        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                        return func(value)
                    }

                    function toFinite(value) {
                        if (!value)return 0 === value ? value : 0;
                        if (value = toNumber(value), value === INFINITY || value === -INFINITY) {
                            var sign = 0 > value ? -1 : 1;
                            return sign * MAX_INTEGER
                        }
                        return value === value ? value : 0
                    }

                    function toInteger(value) {
                        var result = toFinite(value), remainder = result % 1;
                        return result === result ? remainder ? result - remainder : result : 0
                    }

                    function toLength(value) {
                        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0
                    }

                    function toNumber(value) {
                        if ("number" == typeof value)return value;
                        if (isSymbol(value))return NAN;
                        if (isObject(value)) {
                            var other = isFunction(value.valueOf) ? value.valueOf() : value;
                            value = isObject(other) ? other + "" : other
                        }
                        if ("string" != typeof value)return 0 === value ? value : +value;
                        value = value.replace(reTrim, "");
                        var isBinary = reIsBinary.test(value);
                        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value
                    }

                    function toPlainObject(value) {
                        return copyObject(value, keysIn(value))
                    }

                    function toSafeInteger(value) {
                        return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
                    }

                    function toString(value) {
                        return null == value ? "" : baseToString(value)
                    }

                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties ? baseAssign(result, properties) : result
                    }

                    function findKey(object, predicate) {
                        return baseFind(object, getIteratee(predicate, 3), baseForOwn, !0)
                    }

                    function findLastKey(object, predicate) {
                        return baseFind(object, getIteratee(predicate, 3), baseForOwnRight, !0)
                    }

                    function forIn(object, iteratee) {
                        return null == object ? object : baseFor(object, getIteratee(iteratee, 3), keysIn)
                    }

                    function forInRight(object, iteratee) {
                        return null == object ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn)
                    }

                    function forOwn(object, iteratee) {
                        return object && baseForOwn(object, getIteratee(iteratee, 3))
                    }

                    function forOwnRight(object, iteratee) {
                        return object && baseForOwnRight(object, getIteratee(iteratee, 3))
                    }

                    function functions(object) {
                        return null == object ? [] : baseFunctions(object, keys(object))
                    }

                    function functionsIn(object) {
                        return null == object ? [] : baseFunctions(object, keysIn(object))
                    }

                    function get(object, path, defaultValue) {
                        var result = null == object ? undefined : baseGet(object, path);
                        return result === undefined ? defaultValue : result
                    }

                    function has(object, path) {
                        return null != object && hasPath(object, path, baseHas)
                    }

                    function hasIn(object, path) {
                        return null != object && hasPath(object, path, baseHasIn)
                    }

                    function keys(object) {
                        var isProto = isPrototype(object);
                        if (!isProto && !isArrayLike(object))return baseKeys(object);
                        var indexes = indexKeys(object), skipIndexes = !!indexes, result = indexes || [], length = result.length;
                        for (var key in object)!baseHas(object, key) || skipIndexes && ("length" == key || isIndex(key, length)) || isProto && "constructor" == key || result.push(key);
                        return result
                    }

                    function keysIn(object) {
                        for (var index = -1, isProto = isPrototype(object), props = baseKeysIn(object), propsLength = props.length, indexes = indexKeys(object), skipIndexes = !!indexes, result = indexes || [], length = result.length; ++index < propsLength;) {
                            var key = props[index];
                            skipIndexes && ("length" == key || isIndex(key, length)) || "constructor" == key && (isProto || !hasOwnProperty.call(object, key)) || result.push(key)
                        }
                        return result
                    }

                    function mapKeys(object, iteratee) {
                        var result = {};
                        return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function (value, key, object) {
                            result[iteratee(value, key, object)] = value
                        }), result
                    }

                    function mapValues(object, iteratee) {
                        var result = {};
                        return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function (value, key, object) {
                            result[key] = iteratee(value, key, object)
                        }), result
                    }

                    function omitBy(object, predicate) {
                        return predicate = getIteratee(predicate), basePickBy(object, function (value, key) {
                            return !predicate(value, key)
                        })
                    }

                    function pickBy(object, predicate) {
                        return null == object ? {} : basePickBy(object, getIteratee(predicate))
                    }

                    function result(object, path, defaultValue) {
                        path = isKey(path, object) ? [path] : castPath(path);
                        var index = -1, length = path.length;
                        for (length || (object = undefined, length = 1); ++index < length;) {
                            var value = null == object ? undefined : object[toKey(path[index])];
                            value === undefined && (index = length, value = defaultValue), object = isFunction(value) ? value.call(object) : value
                        }
                        return object
                    }

                    function set(object, path, value) {
                        return null == object ? object : baseSet(object, path, value)
                    }

                    function setWith(object, path, value, customizer) {
                        return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseSet(object, path, value, customizer)
                    }

                    function transform(object, iteratee, accumulator) {
                        var isArr = isArray(object) || isTypedArray(object);
                        if (iteratee = getIteratee(iteratee, 4), null == accumulator)if (isArr || isObject(object)) {
                            var Ctor = object.constructor;
                            accumulator = isArr ? isArray(object) ? new Ctor : [] : isFunction(Ctor) ? baseCreate(getPrototype(object)) : {}
                        } else accumulator = {};
                        return (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
                            return iteratee(accumulator, value, index, object)
                        }), accumulator
                    }

                    function unset(object, path) {
                        return null == object ? !0 : baseUnset(object, path)
                    }

                    function update(object, path, updater) {
                        return null == object ? object : baseUpdate(object, path, castFunction(updater))
                    }

                    function updateWith(object, path, updater, customizer) {
                        return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseUpdate(object, path, castFunction(updater), customizer)
                    }

                    function values(object) {
                        return object ? baseValues(object, keys(object)) : []
                    }

                    function valuesIn(object) {
                        return null == object ? [] : baseValues(object, keysIn(object))
                    }

                    function clamp(number, lower, upper) {
                        return upper === undefined && (upper = lower, lower = undefined), upper !== undefined && (upper = toNumber(upper), upper = upper === upper ? upper : 0), lower !== undefined && (lower = toNumber(lower), lower = lower === lower ? lower : 0), baseClamp(toNumber(number), lower, upper)
                    }

                    function inRange(number, start, end) {
                        return start = toNumber(start) || 0, end === undefined ? (end = start, start = 0) : end = toNumber(end) || 0, number = toNumber(number), baseInRange(number, start, end)
                    }

                    function random(lower, upper, floating) {
                        if (floating && "boolean" != typeof floating && isIterateeCall(lower, upper, floating) && (upper = floating = undefined), floating === undefined && ("boolean" == typeof upper ? (floating = upper, upper = undefined) : "boolean" == typeof lower && (floating = lower, lower = undefined)), lower === undefined && upper === undefined ? (lower = 0, upper = 1) : (lower = toNumber(lower) || 0, upper === undefined ? (upper = lower, lower = 0) : upper = toNumber(upper) || 0), lower > upper) {
                            var temp = lower;
                            lower = upper, upper = temp
                        }
                        if (floating || lower % 1 || upper % 1) {
                            var rand = nativeRandom();
                            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper)
                        }
                        return baseRandom(lower, upper)
                    }

                    function capitalize(string) {
                        return upperFirst(toString(string).toLowerCase())
                    }

                    function deburr(string) {
                        return string = toString(string), string && string.replace(reLatin1, deburrLetter).replace(reComboMark, "")
                    }

                    function endsWith(string, target, position) {
                        string = toString(string), target = baseToString(target);
                        var length = string.length;
                        return position = position === undefined ? length : baseClamp(toInteger(position), 0, length), position -= target.length, position >= 0 && string.indexOf(target, position) == position
                    }

                    function escape(string) {
                        return string = toString(string), string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string
                    }

                    function escapeRegExp(string) {
                        return string = toString(string), string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string
                    }

                    function pad(string, length, chars) {
                        string = toString(string), length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        if (!length || strLength >= length)return string;
                        var mid = (length - strLength) / 2;
                        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars)
                    }

                    function padEnd(string, length, chars) {
                        string = toString(string), length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        return length && length > strLength ? string + createPadding(length - strLength, chars) : string
                    }

                    function padStart(string, length, chars) {
                        string = toString(string), length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        return length && length > strLength ? createPadding(length - strLength, chars) + string : string
                    }

                    function parseInt(string, radix, guard) {
                        return guard || null == radix ? radix = 0 : radix && (radix = +radix), string = toString(string).replace(reTrim, ""), nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10))
                    }

                    function repeat(string, n, guard) {
                        return n = (guard ? isIterateeCall(string, n, guard) : n === undefined) ? 1 : toInteger(n), baseRepeat(toString(string), n)
                    }

                    function replace() {
                        var args = arguments, string = toString(args[0]);
                        return args.length < 3 ? string : nativeReplace.call(string, args[1], args[2])
                    }

                    function split(string, separator, limit) {
                        return limit && "number" != typeof limit && isIterateeCall(string, separator, limit) && (separator = limit = undefined), (limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0) ? (string = toString(string), string && ("string" == typeof separator || null != separator && !isRegExp(separator)) && (separator = baseToString(separator), "" == separator && reHasComplexSymbol.test(string)) ? castSlice(stringToArray(string), 0, limit) : nativeSplit.call(string, separator, limit)) : []
                    }

                    function startsWith(string, target, position) {
                        return string = toString(string), position = baseClamp(toInteger(position), 0, string.length), string.lastIndexOf(baseToString(target), position) == position
                    }

                    function template(string, options, guard) {
                        var settings = lodash.templateSettings;
                        guard && isIterateeCall(string, options, guard) && (options = undefined), string = toString(string), options = assignInWith({}, options, settings, assignInDefaults);
                        var isEscaping, isEvaluating, imports = assignInWith({}, options.imports, settings.imports, assignInDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys), index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '", reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g"), sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                        string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            return interpolateValue || (interpolateValue = esTemplateValue), source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar), escapeValue && (isEscaping = !0, source += "' +\n__e(" + escapeValue + ") +\n'"), evaluateValue && (isEvaluating = !0, source += "';\n" + evaluateValue + ";\n__p += '"), interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"), index = offset + match.length, match
                        }), source += "';\n";
                        var variable = options.variable;
                        variable || (source = "with (obj) {\n" + source + "\n}\n"), source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var result = attempt(function () {
                            return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues)
                        });
                        if (result.source = source, isError(result))throw result;
                        return result
                    }

                    function toLower(value) {
                        return toString(value).toLowerCase()
                    }

                    function toUpper(value) {
                        return toString(value).toUpperCase()
                    }

                    function trim(string, chars, guard) {
                        if (string = toString(string), string && (guard || chars === undefined))return string.replace(reTrim, "");
                        if (!string || !(chars = baseToString(chars)))return string;
                        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                        return castSlice(strSymbols, start, end).join("")
                    }

                    function trimEnd(string, chars, guard) {
                        if (string = toString(string), string && (guard || chars === undefined))return string.replace(reTrimEnd, "");
                        if (!string || !(chars = baseToString(chars)))return string;
                        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                        return castSlice(strSymbols, 0, end).join("")
                    }

                    function trimStart(string, chars, guard) {
                        if (string = toString(string), string && (guard || chars === undefined))return string.replace(reTrimStart, "");
                        if (!string || !(chars = baseToString(chars)))return string;
                        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                        return castSlice(strSymbols, start).join("")
                    }

                    function truncate(string, options) {
                        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                        if (isObject(options)) {
                            var separator = "separator" in options ? options.separator : separator;
                            length = "length" in options ? toInteger(options.length) : length, omission = "omission" in options ? baseToString(options.omission) : omission
                        }
                        string = toString(string);
                        var strLength = string.length;
                        if (reHasComplexSymbol.test(string)) {
                            var strSymbols = stringToArray(string);
                            strLength = strSymbols.length
                        }
                        if (length >= strLength)return string;
                        var end = length - stringSize(omission);
                        if (1 > end)return omission;
                        var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                        if (separator === undefined)return result + omission;
                        if (strSymbols && (end += result.length - end), isRegExp(separator)) {
                            if (string.slice(end).search(separator)) {
                                var match, substring = result;
                                for (separator.global || (separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g")), separator.lastIndex = 0; match = separator.exec(substring);)var newEnd = match.index;
                                result = result.slice(0, newEnd === undefined ? end : newEnd)
                            }
                        } else if (string.indexOf(baseToString(separator), end) != end) {
                            var index = result.lastIndexOf(separator);
                            index > -1 && (result = result.slice(0, index))
                        }
                        return result + omission
                    }

                    function unescape(string) {
                        return string = toString(string), string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string
                    }

                    function words(string, pattern, guard) {
                        return string = toString(string), pattern = guard ? undefined : pattern, pattern === undefined && (pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord), string.match(pattern) || []
                    }

                    function cond(pairs) {
                        var length = pairs ? pairs.length : 0, toIteratee = getIteratee();
                        return pairs = length ? arrayMap(pairs, function (pair) {
                            if ("function" != typeof pair[1])throw new TypeError(FUNC_ERROR_TEXT);
                            return [toIteratee(pair[0]), pair[1]]
                        }) : [], rest(function (args) {
                            for (var index = -1; ++index < length;) {
                                var pair = pairs[index];
                                if (apply(pair[0], this, args))return apply(pair[1], this, args)
                            }
                        })
                    }

                    function conforms(source) {
                        return baseConforms(baseClone(source, !0))
                    }

                    function constant(value) {
                        return function () {
                            return value
                        }
                    }

                    function identity(value) {
                        return value
                    }

                    function iteratee(func) {
                        return baseIteratee("function" == typeof func ? func : baseClone(func, !0))
                    }

                    function matches(source) {
                        return baseMatches(baseClone(source, !0))
                    }

                    function matchesProperty(path, srcValue) {
                        return baseMatchesProperty(path, baseClone(srcValue, !0))
                    }

                    function mixin(object, source, options) {
                        var props = keys(source), methodNames = baseFunctions(source, props);
                        null != options || isObject(source) && (methodNames.length || !props.length) || (options = source, source = object, object = this, methodNames = baseFunctions(source, keys(source)));
                        var chain = !(isObject(options) && "chain" in options && !options.chain), isFunc = isFunction(object);
                        return arrayEach(methodNames, function (methodName) {
                            var func = source[methodName];
                            object[methodName] = func, isFunc && (object.prototype[methodName] = function () {
                                var chainAll = this.__chain__;
                                if (chain || chainAll) {
                                    var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                                    return actions.push({
                                        func: func,
                                        args: arguments,
                                        thisArg: object
                                    }), result.__chain__ = chainAll, result
                                }
                                return func.apply(object, arrayPush([this.value()], arguments))
                            })
                        }), object
                    }

                    function noConflict() {
                        return root._ === this && (root._ = oldDash), this
                    }

                    function noop() {
                    }

                    function nthArg(n) {
                        return n = toInteger(n), rest(function (args) {
                            return baseNth(args, n)
                        })
                    }

                    function property(path) {
                        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)
                    }

                    function propertyOf(object) {
                        return function (path) {
                            return null == object ? undefined : baseGet(object, path)
                        }
                    }

                    function times(n, iteratee) {
                        if (n = toInteger(n), 1 > n || n > MAX_SAFE_INTEGER)return [];
                        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                        iteratee = getIteratee(iteratee), n -= MAX_ARRAY_LENGTH;
                        for (var result = baseTimes(length, iteratee); ++index < n;)iteratee(index);
                        return result
                    }

                    function toPath(value) {
                        return isArray(value) ? arrayMap(value, toKey) : isSymbol(value) ? [value] : copyArray(stringToPath(value))
                    }

                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return toString(prefix) + id
                    }

                    function max(array) {
                        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined
                    }

                    function maxBy(array, iteratee) {
                        return array && array.length ? baseExtremum(array, getIteratee(iteratee), baseGt) : undefined
                    }

                    function mean(array) {
                        return baseMean(array, identity)
                    }

                    function meanBy(array, iteratee) {
                        return baseMean(array, getIteratee(iteratee))
                    }

                    function min(array) {
                        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined
                    }

                    function minBy(array, iteratee) {
                        return array && array.length ? baseExtremum(array, getIteratee(iteratee), baseLt) : undefined
                    }

                    function sum(array) {
                        return array && array.length ? baseSum(array, identity) : 0
                    }

                    function sumBy(array, iteratee) {
                        return array && array.length ? baseSum(array, getIteratee(iteratee)) : 0
                    }

                    context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;
                    var Date = context.Date, Error = context.Error, Math = context.Math, RegExp = context.RegExp, TypeError = context.TypeError, arrayProto = context.Array.prototype, objectProto = context.Object.prototype, stringProto = context.String.prototype, funcToString = context.Function.prototype.toString, hasOwnProperty = objectProto.hasOwnProperty, idCounter = 0, objectCtorString = funcToString.call(Object), objectToString = objectProto.toString, oldDash = root._, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Buffer = moduleExports ? context.Buffer : undefined, Reflect = context.Reflect, Symbol = context.Symbol, Uint8Array = context.Uint8Array, clearTimeout = context.clearTimeout, enumerate = Reflect ? Reflect.enumerate : undefined, getOwnPropertySymbols = Object.getOwnPropertySymbols, iteratorSymbol = "symbol" == typeof(iteratorSymbol = Symbol && Symbol.iterator) ? iteratorSymbol : undefined, objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, setTimeout = context.setTimeout, splice = arrayProto.splice, nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetPrototype = Object.getPrototypeOf, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = Object.keys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReplace = stringProto.replace, nativeReverse = arrayProto.reverse, nativeSplit = stringProto.split, DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object, "create"), metaMap = WeakMap && new WeakMap, nonEnumShadows = !propertyIsEnumerable.call({valueOf: 1}, "valueOf"), realNames = {}, dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap), symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
                    lodash.templateSettings = {
                        escape: reEscape,
                        evaluate: reEvaluate,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {_: lodash}
                    }, lodash.prototype = baseLodash.prototype, lodash.prototype.constructor = lodash, LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper, LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper, Hash.prototype.clear = hashClear, Hash.prototype["delete"] = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, ListCache.prototype.clear = listCacheClear, ListCache.prototype["delete"] = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet, MapCache.prototype.clear = mapCacheClear, MapCache.prototype["delete"] = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet, SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas, Stack.prototype.clear = stackClear, Stack.prototype["delete"] = stackDelete, Stack.prototype.get = stackGet, Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
                    var baseEach = createBaseEach(baseForOwn), baseEachRight = createBaseEach(baseForOwnRight, !0), baseFor = createBaseFor(), baseForRight = createBaseFor(!0);
                    enumerate && !propertyIsEnumerable.call({valueOf: 1}, "valueOf") && (baseKeysIn = function (object) {
                        return iteratorToArray(enumerate(object))
                    });
                    var baseSetData = metaMap ? function (func, data) {
                        return metaMap.set(func, data), func
                    } : identity, createSet = Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY ? function (values) {
                        return new Set(values)
                    } : noop, getData = metaMap ? function (func) {
                        return metaMap.get(func)
                    } : noop, getLength = baseProperty("length");
                    getOwnPropertySymbols || (getSymbols = function () {
                        return []
                    });
                    var getSymbolsIn = getOwnPropertySymbols ? function (object) {
                        for (var result = []; object;)arrayPush(result, getSymbols(object)), object = getPrototype(object);
                        return result
                    } : getSymbols;
                    (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) && (getTag = function (value) {
                        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
                        if (ctorString)switch (ctorString) {
                            case dataViewCtorString:
                                return dataViewTag;
                            case mapCtorString:
                                return mapTag;
                            case promiseCtorString:
                                return promiseTag;
                            case setCtorString:
                                return setTag;
                            case weakMapCtorString:
                                return weakMapTag
                        }
                        return result
                    });
                    var setData = function () {
                        var count = 0, lastCalled = 0;
                        return function (key, value) {
                            var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
                            if (lastCalled = stamp, remaining > 0) {
                                if (++count >= HOT_COUNT)return key
                            } else count = 0;
                            return baseSetData(key, value)
                        }
                    }(), stringToPath = memoize(function (string) {
                        var result = [];
                        return toString(string).replace(rePropName, function (match, number, quote, string) {
                            result.push(quote ? string.replace(reEscapeChar, "$1") : number || match)
                        }), result
                    }), difference = rest(function (array, values) {
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0)) : []
                    }), differenceBy = rest(function (array, values) {
                        var iteratee = last(values);
                        return isArrayLikeObject(iteratee) && (iteratee = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), getIteratee(iteratee)) : []
                    }), differenceWith = rest(function (array, values) {
                        var comparator = last(values);
                        return isArrayLikeObject(comparator) && (comparator = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), undefined, comparator) : []
                    }), intersection = rest(function (arrays) {
                        var mapped = arrayMap(arrays, castArrayLikeObject);
                        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : []
                    }), intersectionBy = rest(function (arrays) {
                        var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                        return iteratee === last(mapped) ? iteratee = undefined : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee)) : []
                    }), intersectionWith = rest(function (arrays) {
                        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                        return comparator === last(mapped) ? comparator = undefined : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : []
                    }), pull = rest(pullAll), pullAt = rest(function (array, indexes) {
                        indexes = baseFlatten(indexes, 1);
                        var length = array ? array.length : 0, result = baseAt(array, indexes);
                        return basePullAt(array, arrayMap(indexes, function (index) {
                            return isIndex(index, length) ? +index : index
                        }).sort(compareAscending)), result
                    }), union = rest(function (arrays) {
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0))
                    }), unionBy = rest(function (arrays) {
                        var iteratee = last(arrays);
                        return isArrayLikeObject(iteratee) && (iteratee = undefined), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee))
                    }), unionWith = rest(function (arrays) {
                        var comparator = last(arrays);
                        return isArrayLikeObject(comparator) && (comparator = undefined), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined, comparator)
                    }), without = rest(function (array, values) {
                        return isArrayLikeObject(array) ? baseDifference(array, values) : []
                    }), xor = rest(function (arrays) {
                        return baseXor(arrayFilter(arrays, isArrayLikeObject))
                    }), xorBy = rest(function (arrays) {
                        var iteratee = last(arrays);
                        return isArrayLikeObject(iteratee) && (iteratee = undefined), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee))
                    }), xorWith = rest(function (arrays) {
                        var comparator = last(arrays);
                        return isArrayLikeObject(comparator) && (comparator = undefined), baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator)
                    }), zip = rest(unzip), zipWith = rest(function (arrays) {
                        var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
                        return iteratee = "function" == typeof iteratee ? (arrays.pop(), iteratee) : undefined, unzipWith(arrays, iteratee)
                    }), wrapperAt = rest(function (paths) {
                        paths = baseFlatten(paths, 1);
                        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function (object) {
                            return baseAt(object, paths)
                        };
                        return !(length > 1 || this.__actions__.length) && value instanceof LazyWrapper && isIndex(start) ? (value = value.slice(start, +start + (length ? 1 : 0)), value.__actions__.push({
                            func: thru,
                            args: [interceptor],
                            thisArg: undefined
                        }), new LodashWrapper(value, this.__chain__).thru(function (array) {
                            return length && !array.length && array.push(undefined), array
                        })) : this.thru(interceptor)
                    }), countBy = createAggregator(function (result, value, key) {
                        hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1
                    }), groupBy = createAggregator(function (result, value, key) {
                        hasOwnProperty.call(result, key) ? result[key].push(value) : result[key] = [value]
                    }), invokeMap = rest(function (collection, path, args) {
                        var index = -1, isFunc = "function" == typeof path, isProp = isKey(path), result = isArrayLike(collection) ? Array(collection.length) : [];
                        return baseEach(collection, function (value) {
                            var func = isFunc ? path : isProp && null != value ? value[path] : undefined;
                            result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args)
                        }), result
                    }), keyBy = createAggregator(function (result, value, key) {
                        result[key] = value
                    }), partition = createAggregator(function (result, value, key) {
                        result[key ? 0 : 1].push(value)
                    }, function () {
                        return [[], []]
                    }), sortBy = rest(function (collection, iteratees) {
                        if (null == collection)return [];
                        var length = iteratees.length;
                        return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]), iteratees = 1 == iteratees.length && isArray(iteratees[0]) ? iteratees[0] : baseFlatten(iteratees, 1, isFlattenableIteratee), baseOrderBy(collection, iteratees, [])
                    }), now = Date.now, bind = rest(function (func, thisArg, partials) {
                        var bitmask = BIND_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, getHolder(bind));
                            bitmask |= PARTIAL_FLAG
                        }
                        return createWrapper(func, bitmask, thisArg, partials, holders)
                    }), bindKey = rest(function (object, key, partials) {
                        var bitmask = BIND_FLAG | BIND_KEY_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, getHolder(bindKey));
                            bitmask |= PARTIAL_FLAG
                        }
                        return createWrapper(key, bitmask, object, partials, holders)
                    }), defer = rest(function (func, args) {
                        return baseDelay(func, 1, args)
                    }), delay = rest(function (func, wait, args) {
                        return baseDelay(func, toNumber(wait) || 0, args)
                    });
                    memoize.Cache = MapCache;
                    var overArgs = rest(function (func, transforms) {
                        transforms = 1 == transforms.length && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1, isFlattenableIteratee), baseUnary(getIteratee()));
                        var funcsLength = transforms.length;
                        return rest(function (args) {
                            for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length;)args[index] = transforms[index].call(this, args[index]);
                            return apply(func, this, args)
                        })
                    }), partial = rest(function (func, partials) {
                        var holders = replaceHolders(partials, getHolder(partial));
                        return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders)
                    }), partialRight = rest(function (func, partials) {
                        var holders = replaceHolders(partials, getHolder(partialRight));
                        return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders)
                    }), rearg = rest(function (func, indexes) {
                        return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes, 1))
                    }), gt = createRelationalOperation(baseGt), gte = createRelationalOperation(function (value, other) {
                        return value >= other
                    }), isArray = Array.isArray, isBuffer = Buffer ? function (value) {
                        return value instanceof Buffer
                    } : constant(!1), lt = createRelationalOperation(baseLt), lte = createRelationalOperation(function (value, other) {
                        return other >= value
                    }), assign = createAssigner(function (object, source) {
                        if (nonEnumShadows || isPrototype(source) || isArrayLike(source))return void copyObject(source, keys(source), object);
                        for (var key in source)hasOwnProperty.call(source, key) && assignValue(object, key, source[key])
                    }), assignIn = createAssigner(function (object, source) {
                        if (nonEnumShadows || isPrototype(source) || isArrayLike(source))return void copyObject(source, keysIn(source), object);
                        for (var key in source)assignValue(object, key, source[key])
                    }), assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
                        copyObject(source, keysIn(source), object, customizer)
                    }), assignWith = createAssigner(function (object, source, srcIndex, customizer) {
                        copyObject(source, keys(source), object, customizer)
                    }), at = rest(function (object, paths) {
                        return baseAt(object, baseFlatten(paths, 1))
                    }), defaults = rest(function (args) {
                        return args.push(undefined, assignInDefaults), apply(assignInWith, undefined, args)
                    }), defaultsDeep = rest(function (args) {
                        return args.push(undefined, mergeDefaults), apply(mergeWith, undefined, args)
                    }), invert = createInverter(function (result, value, key) {
                        result[value] = key
                    }, constant(identity)), invertBy = createInverter(function (result, value, key) {
                        hasOwnProperty.call(result, value) ? result[value].push(key) : result[value] = [key]
                    }, getIteratee), invoke = rest(baseInvoke), merge = createAssigner(function (object, source, srcIndex) {
                        baseMerge(object, source, srcIndex)
                    }), mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
                        baseMerge(object, source, srcIndex, customizer)
                    }), omit = rest(function (object, props) {
                        return null == object ? {} : (props = arrayMap(baseFlatten(props, 1), toKey), basePick(object, baseDifference(getAllKeysIn(object), props)))
                    }), pick = rest(function (object, props) {
                        return null == object ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey))
                    }), toPairs = createToPairs(keys), toPairsIn = createToPairs(keysIn), camelCase = createCompounder(function (result, word, index) {
                        return word = word.toLowerCase(), result + (index ? capitalize(word) : word)
                    }), kebabCase = createCompounder(function (result, word, index) {
                        return result + (index ? "-" : "") + word.toLowerCase()
                    }), lowerCase = createCompounder(function (result, word, index) {
                        return result + (index ? " " : "") + word.toLowerCase()
                    }), lowerFirst = createCaseFirst("toLowerCase"), snakeCase = createCompounder(function (result, word, index) {
                        return result + (index ? "_" : "") + word.toLowerCase()
                    }), startCase = createCompounder(function (result, word, index) {
                        return result + (index ? " " : "") + upperFirst(word)
                    }), upperCase = createCompounder(function (result, word, index) {
                        return result + (index ? " " : "") + word.toUpperCase()
                    }), upperFirst = createCaseFirst("toUpperCase"), attempt = rest(function (func, args) {
                        try {
                            return apply(func, undefined, args)
                        } catch (e) {
                            return isError(e) ? e : new Error(e)
                        }
                    }), bindAll = rest(function (object, methodNames) {
                        return arrayEach(baseFlatten(methodNames, 1), function (key) {
                            key = toKey(key), object[key] = bind(object[key], object)
                        }), object
                    }), flow = createFlow(), flowRight = createFlow(!0), method = rest(function (path, args) {
                        return function (object) {
                            return baseInvoke(object, path, args)
                        }
                    }), methodOf = rest(function (object, args) {
                        return function (path) {
                            return baseInvoke(object, path, args)
                        }
                    }), over = createOver(arrayMap), overEvery = createOver(arrayEvery), overSome = createOver(arraySome), range = createRange(), rangeRight = createRange(!0), add = createMathOperation(function (augend, addend) {
                        return augend + addend
                    }), ceil = createRound("ceil"), divide = createMathOperation(function (dividend, divisor) {
                        return dividend / divisor
                    }), floor = createRound("floor"), multiply = createMathOperation(function (multiplier, multiplicand) {
                        return multiplier * multiplicand
                    }), round = createRound("round"), subtract = createMathOperation(function (minuend, subtrahend) {
                        return minuend - subtrahend
                    });
                    return lodash.after = after, lodash.ary = ary, lodash.assign = assign, lodash.assignIn = assignIn, lodash.assignInWith = assignInWith, lodash.assignWith = assignWith, lodash.at = at, lodash.before = before, lodash.bind = bind, lodash.bindAll = bindAll, lodash.bindKey = bindKey, lodash.castArray = castArray, lodash.chain = chain, lodash.chunk = chunk, lodash.compact = compact, lodash.concat = concat, lodash.cond = cond, lodash.conforms = conforms, lodash.constant = constant, lodash.countBy = countBy, lodash.create = create, lodash.curry = curry, lodash.curryRight = curryRight, lodash.debounce = debounce, lodash.defaults = defaults, lodash.defaultsDeep = defaultsDeep, lodash.defer = defer, lodash.delay = delay, lodash.difference = difference, lodash.differenceBy = differenceBy, lodash.differenceWith = differenceWith, lodash.drop = drop, lodash.dropRight = dropRight, lodash.dropRightWhile = dropRightWhile, lodash.dropWhile = dropWhile, lodash.fill = fill, lodash.filter = filter, lodash.flatMap = flatMap, lodash.flatMapDeep = flatMapDeep, lodash.flatMapDepth = flatMapDepth, lodash.flatten = flatten, lodash.flattenDeep = flattenDeep, lodash.flattenDepth = flattenDepth, lodash.flip = flip, lodash.flow = flow, lodash.flowRight = flowRight, lodash.fromPairs = fromPairs, lodash.functions = functions, lodash.functionsIn = functionsIn, lodash.groupBy = groupBy, lodash.initial = initial, lodash.intersection = intersection, lodash.intersectionBy = intersectionBy, lodash.intersectionWith = intersectionWith, lodash.invert = invert, lodash.invertBy = invertBy, lodash.invokeMap = invokeMap, lodash.iteratee = iteratee, lodash.keyBy = keyBy, lodash.keys = keys, lodash.keysIn = keysIn, lodash.map = map, lodash.mapKeys = mapKeys, lodash.mapValues = mapValues, lodash.matches = matches, lodash.matchesProperty = matchesProperty, lodash.memoize = memoize, lodash.merge = merge, lodash.mergeWith = mergeWith, lodash.method = method, lodash.methodOf = methodOf, lodash.mixin = mixin, lodash.negate = negate, lodash.nthArg = nthArg, lodash.omit = omit, lodash.omitBy = omitBy, lodash.once = once, lodash.orderBy = orderBy, lodash.over = over, lodash.overArgs = overArgs, lodash.overEvery = overEvery, lodash.overSome = overSome, lodash.partial = partial, lodash.partialRight = partialRight, lodash.partition = partition, lodash.pick = pick, lodash.pickBy = pickBy, lodash.property = property, lodash.propertyOf = propertyOf, lodash.pull = pull, lodash.pullAll = pullAll, lodash.pullAllBy = pullAllBy, lodash.pullAllWith = pullAllWith, lodash.pullAt = pullAt, lodash.range = range, lodash.rangeRight = rangeRight, lodash.rearg = rearg, lodash.reject = reject, lodash.remove = remove, lodash.rest = rest, lodash.reverse = reverse,lodash.sampleSize = sampleSize,lodash.set = set,lodash.setWith = setWith,lodash.shuffle = shuffle,lodash.slice = slice,lodash.sortBy = sortBy,lodash.sortedUniq = sortedUniq,lodash.sortedUniqBy = sortedUniqBy,lodash.split = split,lodash.spread = spread,lodash.tail = tail,lodash.take = take,lodash.takeRight = takeRight,lodash.takeRightWhile = takeRightWhile,lodash.takeWhile = takeWhile,lodash.tap = tap,lodash.throttle = throttle,lodash.thru = thru,lodash.toArray = toArray,lodash.toPairs = toPairs,lodash.toPairsIn = toPairsIn,lodash.toPath = toPath,lodash.toPlainObject = toPlainObject,lodash.transform = transform,lodash.unary = unary,lodash.union = union,lodash.unionBy = unionBy,lodash.unionWith = unionWith,lodash.uniq = uniq,lodash.uniqBy = uniqBy,lodash.uniqWith = uniqWith,lodash.unset = unset,lodash.unzip = unzip,lodash.unzipWith = unzipWith,lodash.update = update,lodash.updateWith = updateWith,lodash.values = values,lodash.valuesIn = valuesIn,lodash.without = without,lodash.words = words,lodash.wrap = wrap,lodash.xor = xor,lodash.xorBy = xorBy,lodash.xorWith = xorWith,lodash.zip = zip,lodash.zipObject = zipObject,lodash.zipObjectDeep = zipObjectDeep,lodash.zipWith = zipWith,lodash.entries = toPairs,lodash.entriesIn = toPairsIn,lodash.extend = assignIn,lodash.extendWith = assignInWith,mixin(lodash, lodash),lodash.add = add,lodash.attempt = attempt,lodash.camelCase = camelCase,lodash.capitalize = capitalize,lodash.ceil = ceil,lodash.clamp = clamp,lodash.clone = clone,lodash.cloneDeep = cloneDeep,lodash.cloneDeepWith = cloneDeepWith,lodash.cloneWith = cloneWith,lodash.deburr = deburr,lodash.divide = divide,lodash.endsWith = endsWith,lodash.eq = eq,lodash.escape = escape,lodash.escapeRegExp = escapeRegExp,lodash.every = every,lodash.find = find,lodash.findIndex = findIndex,lodash.findKey = findKey,lodash.findLast = findLast,lodash.findLastIndex = findLastIndex,lodash.findLastKey = findLastKey,lodash.floor = floor,lodash.forEach = forEach,lodash.forEachRight = forEachRight,lodash.forIn = forIn,lodash.forInRight = forInRight,lodash.forOwn = forOwn,lodash.forOwnRight = forOwnRight,lodash.get = get,lodash.gt = gt,lodash.gte = gte,lodash.has = has,lodash.hasIn = hasIn,lodash.head = head,lodash.identity = identity,lodash.includes = includes,lodash.indexOf = indexOf,lodash.inRange = inRange,lodash.invoke = invoke,lodash.isArguments = isArguments,lodash.isArray = isArray,lodash.isArrayBuffer = isArrayBuffer,lodash.isArrayLike = isArrayLike,lodash.isArrayLikeObject = isArrayLikeObject,lodash.isBoolean = isBoolean,lodash.isBuffer = isBuffer,lodash.isDate = isDate,lodash.isElement = isElement,lodash.isEmpty = isEmpty,lodash.isEqual = isEqual,lodash.isEqualWith = isEqualWith,lodash.isError = isError,lodash.isFinite = isFinite,lodash.isFunction = isFunction,lodash.isInteger = isInteger,lodash.isLength = isLength,lodash.isMap = isMap,lodash.isMatch = isMatch,lodash.isMatchWith = isMatchWith,lodash.isNaN = isNaN,lodash.isNative = isNative,lodash.isNil = isNil,lodash.isNull = isNull,lodash.isNumber = isNumber,lodash.isObject = isObject,lodash.isObjectLike = isObjectLike,lodash.isPlainObject = isPlainObject,lodash.isRegExp = isRegExp,lodash.isSafeInteger = isSafeInteger,lodash.isSet = isSet,lodash.isString = isString,lodash.isSymbol = isSymbol,lodash.isTypedArray = isTypedArray,lodash.isUndefined = isUndefined,lodash.isWeakMap = isWeakMap,lodash.isWeakSet = isWeakSet,lodash.join = join,lodash.kebabCase = kebabCase,lodash.last = last,lodash.lastIndexOf = lastIndexOf,lodash.lowerCase = lowerCase,lodash.lowerFirst = lowerFirst,lodash.lt = lt,lodash.lte = lte,lodash.max = max,lodash.maxBy = maxBy,lodash.mean = mean,lodash.meanBy = meanBy,lodash.min = min,lodash.minBy = minBy,lodash.multiply = multiply,lodash.nth = nth,lodash.noConflict = noConflict,lodash.noop = noop,lodash.now = now,lodash.pad = pad,lodash.padEnd = padEnd,lodash.padStart = padStart,lodash.parseInt = parseInt,lodash.random = random,lodash.reduce = reduce,lodash.reduceRight = reduceRight,lodash.repeat = repeat,lodash.replace = replace,lodash.result = result,lodash.round = round,lodash.runInContext = runInContext,lodash.sample = sample,lodash.size = size,lodash.snakeCase = snakeCase,lodash.some = some,lodash.sortedIndex = sortedIndex,lodash.sortedIndexBy = sortedIndexBy,lodash.sortedIndexOf = sortedIndexOf,lodash.sortedLastIndex = sortedLastIndex,lodash.sortedLastIndexBy = sortedLastIndexBy,lodash.sortedLastIndexOf = sortedLastIndexOf,lodash.startCase = startCase,lodash.startsWith = startsWith,lodash.subtract = subtract,lodash.sum = sum,lodash.sumBy = sumBy,lodash.template = template,lodash.times = times,lodash.toFinite = toFinite,lodash.toInteger = toInteger,lodash.toLength = toLength,lodash.toLower = toLower,lodash.toNumber = toNumber,lodash.toSafeInteger = toSafeInteger,lodash.toString = toString,lodash.toUpper = toUpper,lodash.trim = trim,lodash.trimEnd = trimEnd,lodash.trimStart = trimStart,lodash.truncate = truncate,lodash.unescape = unescape,lodash.uniqueId = uniqueId,lodash.upperCase = upperCase,lodash.upperFirst = upperFirst,lodash.each = forEach,lodash.eachRight = forEachRight,lodash.first = head,mixin(lodash, function () {
                        var source = {};
                        return baseForOwn(lodash, function (func, methodName) {
                            hasOwnProperty.call(lodash.prototype, methodName) || (source[methodName] = func)
                        }), source
                    }(), {chain: !1}),lodash.VERSION = VERSION,arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (methodName) {
                        lodash[methodName].placeholder = lodash
                    }),arrayEach(["drop", "take"], function (methodName, index) {
                        LazyWrapper.prototype[methodName] = function (n) {
                            var filtered = this.__filtered__;
                            if (filtered && !index)return new LazyWrapper(this);
                            n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                            var result = this.clone();
                            return filtered ? result.__takeCount__ = nativeMin(n, result.__takeCount__) : result.__views__.push({
                                size: nativeMin(n, MAX_ARRAY_LENGTH),
                                type: methodName + (result.__dir__ < 0 ? "Right" : "")
                            }), result
                        }, LazyWrapper.prototype[methodName + "Right"] = function (n) {
                            return this.reverse()[methodName](n).reverse()
                        }
                    }),arrayEach(["filter", "map", "takeWhile"], function (methodName, index) {
                        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                        LazyWrapper.prototype[methodName] = function (iteratee) {
                            var result = this.clone();
                            return result.__iteratees__.push({
                                iteratee: getIteratee(iteratee, 3),
                                type: type
                            }), result.__filtered__ = result.__filtered__ || isFilter, result
                        }
                    }),arrayEach(["head", "last"], function (methodName, index) {
                        var takeName = "take" + (index ? "Right" : "");
                        LazyWrapper.prototype[methodName] = function () {
                            return this[takeName](1).value()[0]
                        }
                    }),arrayEach(["initial", "tail"], function (methodName, index) {
                        var dropName = "drop" + (index ? "" : "Right");
                        LazyWrapper.prototype[methodName] = function () {
                            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1)
                        }
                    }),LazyWrapper.prototype.compact = function () {
                        return this.filter(identity)
                    },LazyWrapper.prototype.find = function (predicate) {
                        return this.filter(predicate).head()
                    },LazyWrapper.prototype.findLast = function (predicate) {
                        return this.reverse().find(predicate)
                    },LazyWrapper.prototype.invokeMap = rest(function (path, args) {
                        return "function" == typeof path ? new LazyWrapper(this) : this.map(function (value) {
                            return baseInvoke(value, path, args)
                        })
                    }),LazyWrapper.prototype.reject = function (predicate) {
                        return predicate = getIteratee(predicate, 3), this.filter(function (value) {
                            return !predicate(value)
                        })
                    },LazyWrapper.prototype.slice = function (start, end) {
                        start = toInteger(start);
                        var result = this;
                        return result.__filtered__ && (start > 0 || 0 > end) ? new LazyWrapper(result) : (0 > start ? result = result.takeRight(-start) : start && (result = result.drop(start)), end !== undefined && (end = toInteger(end), result = 0 > end ? result.dropRight(-end) : result.take(end - start)), result)
                    },LazyWrapper.prototype.takeRightWhile = function (predicate) {
                        return this.reverse().takeWhile(predicate).reverse()
                    },LazyWrapper.prototype.toArray = function () {
                        return this.take(MAX_ARRAY_LENGTH)
                    },baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + ("last" == methodName ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                        lodashFunc && (lodash.prototype[methodName] = function () {
                            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value), interceptor = function (value) {
                                var result = lodashFunc.apply(lodash, arrayPush([value], args));
                                return isTaker && chainAll ? result[0] : result
                            };
                            useLazy && checkIteratee && "function" == typeof iteratee && 1 != iteratee.length && (isLazy = useLazy = !1);
                            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                            if (!retUnwrapped && useLazy) {
                                value = onlyLazy ? value : new LazyWrapper(this);
                                var result = func.apply(value, args);
                                return result.__actions__.push({
                                    func: thru,
                                    args: [interceptor],
                                    thisArg: undefined
                                }), new LodashWrapper(result, chainAll)
                            }
                            return isUnwrapped && onlyLazy ? func.apply(this, args) : (result = this.thru(interceptor), isUnwrapped ? isTaker ? result.value()[0] : result.value() : result)
                        })
                    }),arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function (methodName) {
                        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                        lodash.prototype[methodName] = function () {
                            var args = arguments;
                            if (retUnwrapped && !this.__chain__) {
                                var value = this.value();
                                return func.apply(isArray(value) ? value : [], args)
                            }
                            return this[chainName](function (value) {
                                return func.apply(isArray(value) ? value : [], args)
                            })
                        }
                    }),baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                        var lodashFunc = lodash[methodName];
                        if (lodashFunc) {
                            var key = lodashFunc.name + "", names = realNames[key] || (realNames[key] = []);
                            names.push({name: methodName, func: lodashFunc})
                        }
                    }),realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
                        name: "wrapper",
                        func: undefined
                    }],LazyWrapper.prototype.clone = lazyClone,LazyWrapper.prototype.reverse = lazyReverse,LazyWrapper.prototype.value = lazyValue,lodash.prototype.at = wrapperAt,lodash.prototype.chain = wrapperChain,lodash.prototype.commit = wrapperCommit,lodash.prototype.next = wrapperNext,lodash.prototype.plant = wrapperPlant,lodash.prototype.reverse = wrapperReverse,lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue,iteratorSymbol && (lodash.prototype[iteratorSymbol] = wrapperToIterator),lodash
                }

                var undefined, VERSION = "4.12.0", LARGE_ARRAY_SIZE = 200, FUNC_ERROR_TEXT = "Expected a function", HASH_UNDEFINED = "__lodash_hash_undefined__", PLACEHOLDER = "__lodash_placeholder__", BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256, FLIP_FLAG = 512, UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2, DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...", HOT_COUNT = 150, HOT_SPAN = 16, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3, INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e308, NAN = NaN, MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1, argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source), reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/, reBasicWord = /[a-zA-Z0-9]+/g, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reHasHexPrefix = /^0x/i, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsOctal = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")", rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")", reApos = RegExp(rsApos, "g"), reComboMark = RegExp(rsCombo, "g"), reComplexSymbol = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reComplexWord = RegExp([rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")", rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr, rsUpper + "+" + rsOptUpperContr, rsDigits, rsEmoji].join("|"), "g"), reHasComplexSymbol = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]"), reHasComplexWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "Reflect", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], templateCounter = -1, typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
                var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0,
                    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
                var deburredLetters = {
                    "À": "A",
                    "Á": "A",
                    "Â": "A",
                    "Ã": "A",
                    "Ä": "A",
                    "Å": "A",
                    "à": "a",
                    "á": "a",
                    "â": "a",
                    "ã": "a",
                    "ä": "a",
                    "å": "a",
                    "Ç": "C",
                    "ç": "c",
                    "Ð": "D",
                    "ð": "d",
                    "È": "E",
                    "É": "E",
                    "Ê": "E",
                    "Ë": "E",
                    "è": "e",
                    "é": "e",
                    "ê": "e",
                    "ë": "e",
                    "Ì": "I",
                    "Í": "I",
                    "Î": "I",
                    "Ï": "I",
                    "ì": "i",
                    "í": "i",
                    "î": "i",
                    "ï": "i",
                    "Ñ": "N",
                    "ñ": "n",
                    "Ò": "O",
                    "Ó": "O",
                    "Ô": "O",
                    "Õ": "O",
                    "Ö": "O",
                    "Ø": "O",
                    "ò": "o",
                    "ó": "o",
                    "ô": "o",
                    "õ": "o",
                    "ö": "o",
                    "ø": "o",
                    "Ù": "U",
                    "Ú": "U",
                    "Û": "U",
                    "Ü": "U",
                    "ù": "u",
                    "ú": "u",
                    "û": "u",
                    "ü": "u",
                    "Ý": "Y",
                    "ý": "y",
                    "ÿ": "y",
                    "Æ": "Ae",
                    "æ": "ae",
                    "Þ": "Th",
                    "þ": "th",
                    "ß": "ss"
                }, htmlEscapes = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;",
                    "`": "&#96;"
                }, htmlUnescapes = {
                    "&amp;": "&",
                    "&lt;": "<",
                    "&gt;": ">",
                    "&quot;": '"',
                    "&#39;": "'",
                    "&#96;": "`"
                }, objectTypes = {"function": !0, object: !0}, stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                }, freeParseFloat = parseFloat, freeParseInt = parseInt, freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : undefined, freeModule = objectTypes[typeof module] && module && !module.nodeType ? module : undefined, moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : undefined, freeGlobal = checkGlobal(freeExports && freeModule && "object" == typeof global && global), freeSelf = checkGlobal(objectTypes[typeof self] && self), freeWindow = checkGlobal(objectTypes[typeof window] && window), thisGlobal = checkGlobal(objectTypes[typeof this] && this), root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function("return this")(), _ = runInContext();
                (freeWindow || freeSelf || {})._ = _, "function" == typeof define && "object" == typeof define.amd && define.amd ? define(function () {
                    return _
                }) : freeExports && freeModule ? (moduleExports && ((freeModule.exports = _)._ = _), freeExports._ = _) : root._ = _
            }).call(this)
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    47: [function (require, module, exports) {
        (function (process) {
            function normalizeArray(parts, allowAboveRoot) {
                for (var up = 0, i = parts.length - 1; i >= 0; i--) {
                    var last = parts[i];
                    "." === last ? parts.splice(i, 1) : ".." === last ? (parts.splice(i, 1), up++) : up && (parts.splice(i, 1), up--)
                }
                if (allowAboveRoot)for (; up--; up)parts.unshift("..");
                return parts
            }

            function filter(xs, f) {
                if (xs.filter)return xs.filter(f);
                for (var res = [], i = 0; i < xs.length; i++)f(xs[i], i, xs) && res.push(xs[i]);
                return res
            }

            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, splitPath = function (filename) {
                return splitPathRe.exec(filename).slice(1)
            };
            exports.resolve = function () {
                for (var resolvedPath = "", resolvedAbsolute = !1, i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                    var path = i >= 0 ? arguments[i] : process.cwd();
                    if ("string" != typeof path)throw new TypeError("Arguments to path.resolve must be strings");
                    path && (resolvedPath = path + "/" + resolvedPath, resolvedAbsolute = "/" === path.charAt(0))
                }
                return resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function (p) {
                    return !!p
                }), !resolvedAbsolute).join("/"), (resolvedAbsolute ? "/" : "") + resolvedPath || "."
            }, exports.normalize = function (path) {
                var isAbsolute = exports.isAbsolute(path), trailingSlash = "/" === substr(path, -1);
                return path = normalizeArray(filter(path.split("/"), function (p) {
                    return !!p
                }), !isAbsolute).join("/"), path || isAbsolute || (path = "."), path && trailingSlash && (path += "/"), (isAbsolute ? "/" : "") + path
            }, exports.isAbsolute = function (path) {
                return "/" === path.charAt(0)
            }, exports.join = function () {
                var paths = Array.prototype.slice.call(arguments, 0);
                return exports.normalize(filter(paths, function (p, index) {
                    if ("string" != typeof p)throw new TypeError("Arguments to path.join must be strings");
                    return p
                }).join("/"))
            }, exports.relative = function (from, to) {
                function trim(arr) {
                    for (var start = 0; start < arr.length && "" === arr[start]; start++);
                    for (var end = arr.length - 1; end >= 0 && "" === arr[end]; end--);
                    return start > end ? [] : arr.slice(start, end - start + 1)
                }

                from = exports.resolve(from).substr(1), to = exports.resolve(to).substr(1);
                for (var fromParts = trim(from.split("/")), toParts = trim(to.split("/")), length = Math.min(fromParts.length, toParts.length), samePartsLength = length, i = 0; length > i; i++)if (fromParts[i] !== toParts[i]) {
                    samePartsLength = i;
                    break
                }
                for (var outputParts = [], i = samePartsLength; i < fromParts.length; i++)outputParts.push("..");
                return outputParts = outputParts.concat(toParts.slice(samePartsLength)), outputParts.join("/")
            }, exports.sep = "/", exports.delimiter = ":", exports.dirname = function (path) {
                var result = splitPath(path), root = result[0], dir = result[1];
                return root || dir ? (dir && (dir = dir.substr(0, dir.length - 1)), root + dir) : "."
            }, exports.basename = function (path, ext) {
                var f = splitPath(path)[2];
                return ext && f.substr(-1 * ext.length) === ext && (f = f.substr(0, f.length - ext.length)), f
            }, exports.extname = function (path) {
                return splitPath(path)[3]
            };
            var substr = "b" === "ab".substr(-1) ? function (str, start, len) {
                return str.substr(start, len)
            } : function (str, start, len) {
                return 0 > start && (start = str.length + start), str.substr(start, len)
            }
        }).call(this, require("_process"))
    }, {_process: 48}],
    48: [function (require, module, exports) {
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue())
        }

        function drainQueue() {
            if (!draining) {
                var timeout = setTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len;) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len;)currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length
                }
                currentQueue = null, draining = !1, clearTimeout(timeout)
            }
        }

        function Item(fun, array) {
            this.fun = fun, this.array = array
        }

        function noop() {
        }

        var currentQueue, process = module.exports = {}, queue = [], draining = !1, queueIndex = -1;
        process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1)for (var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || setTimeout(drainQueue, 0)
        }, Item.prototype.run = function () {
            this.fun.apply(null, this.array)
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, process.emit = noop, process.binding = function (name) {
            throw new Error("process.binding is not supported")
        }, process.cwd = function () {
            return "/"
        }, process.chdir = function (dir) {
            throw new Error("process.chdir is not supported")
        }, process.umask = function () {
            return 0
        }
    }, {}],
    49: [function (require, module, exports) {
        "use strict";
        function noop() {
        }

        function getThen(obj) {
            try {
                return obj.then
            } catch (ex) {
                return LAST_ERROR = ex, IS_ERROR
            }
        }

        function tryCallOne(fn, a) {
            try {
                return fn(a)
            } catch (ex) {
                return LAST_ERROR = ex, IS_ERROR
            }
        }

        function tryCallTwo(fn, a, b) {
            try {
                fn(a, b)
            } catch (ex) {
                return LAST_ERROR = ex, IS_ERROR
            }
        }

        function Promise(fn) {
            if ("object" != typeof this)throw new TypeError("Promises must be constructed via new");
            if ("function" != typeof fn)throw new TypeError("not a function");
            this._45 = 0, this._81 = 0, this._65 = null, this._54 = null, fn !== noop && doResolve(fn, this)
        }

        function safeThen(self, onFulfilled, onRejected) {
            return new self.constructor(function (resolve, reject) {
                var res = new Promise(noop);
                res.then(resolve, reject), handle(self, new Handler(onFulfilled, onRejected, res))
            })
        }

        function handle(self, deferred) {
            for (; 3 === self._81;)self = self._65;
            return Promise._10 && Promise._10(self), 0 === self._81 ? 0 === self._45 ? (self._45 = 1, void(self._54 = deferred)) : 1 === self._45 ? (self._45 = 2, void(self._54 = [self._54, deferred])) : void self._54.push(deferred) : void handleResolved(self, deferred)
        }

        function handleResolved(self, deferred) {
            asap(function () {
                var cb = 1 === self._81 ? deferred.onFulfilled : deferred.onRejected;
                if (null === cb)return void(1 === self._81 ? resolve(deferred.promise, self._65) : reject(deferred.promise, self._65));
                var ret = tryCallOne(cb, self._65);
                ret === IS_ERROR ? reject(deferred.promise, LAST_ERROR) : resolve(deferred.promise, ret)
            })
        }

        function resolve(self, newValue) {
            if (newValue === self)return reject(self, new TypeError("A promise cannot be resolved with itself."));
            if (newValue && ("object" == typeof newValue || "function" == typeof newValue)) {
                var then = getThen(newValue);
                if (then === IS_ERROR)return reject(self, LAST_ERROR);
                if (then === self.then && newValue instanceof Promise)return self._81 = 3, self._65 = newValue, void finale(self);
                if ("function" == typeof then)return void doResolve(then.bind(newValue), self)
            }
            self._81 = 1, self._65 = newValue, finale(self)
        }

        function reject(self, newValue) {
            self._81 = 2, self._65 = newValue, Promise._97 && Promise._97(self, newValue), finale(self)
        }

        function finale(self) {
            if (1 === self._45 && (handle(self, self._54), self._54 = null), 2 === self._45) {
                for (var i = 0; i < self._54.length; i++)handle(self, self._54[i]);
                self._54 = null
            }
        }

        function Handler(onFulfilled, onRejected, promise) {
            this.onFulfilled = "function" == typeof onFulfilled ? onFulfilled : null, this.onRejected = "function" == typeof onRejected ? onRejected : null, this.promise = promise
        }

        function doResolve(fn, promise) {
            var done = !1, res = tryCallTwo(fn, function (value) {
                done || (done = !0, resolve(promise, value))
            }, function (reason) {
                done || (done = !0, reject(promise, reason))
            });
            done || res !== IS_ERROR || (done = !0, reject(promise, LAST_ERROR))
        }

        var asap = require("asap/raw"), LAST_ERROR = null, IS_ERROR = {};
        module.exports = Promise, Promise._10 = null, Promise._97 = null, Promise._61 = noop, Promise.prototype.then = function (onFulfilled, onRejected) {
            if (this.constructor !== Promise)return safeThen(this, onFulfilled, onRejected);
            var res = new Promise(noop);
            return handle(this, new Handler(onFulfilled, onRejected, res)), res
        }
    }, {"asap/raw": 1}],
    50: [function (require, module, exports) {
        "use strict";
        function valuePromise(value) {
            var p = new Promise(Promise._61);
            return p._81 = 1, p._65 = value, p
        }

        var Promise = require("./core.js");
        module.exports = Promise;
        var TRUE = valuePromise(!0), FALSE = valuePromise(!1), NULL = valuePromise(null), UNDEFINED = valuePromise(void 0), ZERO = valuePromise(0), EMPTYSTRING = valuePromise("");
        Promise.resolve = function (value) {
            if (value instanceof Promise)return value;
            if (null === value)return NULL;
            if (void 0 === value)return UNDEFINED;
            if (value === !0)return TRUE;
            if (value === !1)return FALSE;
            if (0 === value)return ZERO;
            if ("" === value)return EMPTYSTRING;
            if ("object" == typeof value || "function" == typeof value)try {
                var then = value.then;
                if ("function" == typeof then)return new Promise(then.bind(value))
            } catch (ex) {
                return new Promise(function (resolve, reject) {
                    reject(ex)
                })
            }
            return valuePromise(value)
        }, Promise.all = function (arr) {
            var args = Array.prototype.slice.call(arr);
            return new Promise(function (resolve, reject) {
                function res(i, val) {
                    if (val && ("object" == typeof val || "function" == typeof val)) {
                        if (val instanceof Promise && val.then === Promise.prototype.then) {
                            for (; 3 === val._81;)val = val._65;
                            return 1 === val._81 ? res(i, val._65) : (2 === val._81 && reject(val._65), void val.then(function (val) {
                                res(i, val)
                            }, reject))
                        }
                        var then = val.then;
                        if ("function" == typeof then) {
                            var p = new Promise(then.bind(val));
                            return void p.then(function (val) {
                                res(i, val)
                            }, reject)
                        }
                    }
                    args[i] = val, 0 === --remaining && resolve(args)
                }

                if (0 === args.length)return resolve([]);
                for (var remaining = args.length, i = 0; i < args.length; i++)res(i, args[i])
            })
        }, Promise.reject = function (value) {
            return new Promise(function (resolve, reject) {
                reject(value)
            })
        }, Promise.race = function (values) {
            return new Promise(function (resolve, reject) {
                values.forEach(function (value) {
                    Promise.resolve(value).then(resolve, reject)
                })
            })
        }, Promise.prototype["catch"] = function (onRejected) {
            return this.then(null, onRejected)
        }
    }, {"./core.js": 49}],
    51: [function (require, module, exports) {
        (function (global) {
            !function (root) {
                function error(type) {
                    throw new RangeError(errors[type])
                }

                function map(array, fn) {
                    for (var length = array.length, result = []; length--;)result[length] = fn(array[length]);
                    return result
                }

                function mapDomain(string, fn) {
                    var parts = string.split("@"), result = "";
                    parts.length > 1 && (result = parts[0] + "@", string = parts[1]), string = string.replace(regexSeparators, ".");
                    var labels = string.split("."), encoded = map(labels, fn).join(".");
                    return result + encoded
                }

                function ucs2decode(string) {
                    for (var value, extra, output = [], counter = 0, length = string.length; length > counter;)value = string.charCodeAt(counter++), value >= 55296 && 56319 >= value && length > counter ? (extra = string.charCodeAt(counter++), 56320 == (64512 & extra) ? output.push(((1023 & value) << 10) + (1023 & extra) + 65536) : (output.push(value), counter--)) : output.push(value);
                    return output
                }

                function ucs2encode(array) {
                    return map(array, function (value) {
                        var output = "";
                        return value > 65535 && (value -= 65536, output += stringFromCharCode(value >>> 10 & 1023 | 55296), value = 56320 | 1023 & value), output += stringFromCharCode(value)
                    }).join("")
                }

                function basicToDigit(codePoint) {
                    return 10 > codePoint - 48 ? codePoint - 22 : 26 > codePoint - 65 ? codePoint - 65 : 26 > codePoint - 97 ? codePoint - 97 : base
                }

                function digitToBasic(digit, flag) {
                    return digit + 22 + 75 * (26 > digit) - ((0 != flag) << 5)
                }

                function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    for (delta = firstTime ? floor(delta / damp) : delta >> 1, delta += floor(delta / numPoints); delta > baseMinusTMin * tMax >> 1; k += base)delta = floor(delta / baseMinusTMin);
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew))
                }

                function decode(input) {
                    var out, basic, j, index, oldi, w, k, digit, t, baseMinusT, output = [], inputLength = input.length, i = 0, n = initialN, bias = initialBias;
                    for (basic = input.lastIndexOf(delimiter), 0 > basic && (basic = 0), j = 0; basic > j; ++j)input.charCodeAt(j) >= 128 && error("not-basic"), output.push(input.charCodeAt(j));
                    for (index = basic > 0 ? basic + 1 : 0; inputLength > index;) {
                        for (oldi = i, w = 1, k = base; index >= inputLength && error("invalid-input"), digit = basicToDigit(input.charCodeAt(index++)), (digit >= base || digit > floor((maxInt - i) / w)) && error("overflow"), i += digit * w, t = bias >= k ? tMin : k >= bias + tMax ? tMax : k - bias, !(t > digit); k += base)baseMinusT = base - t, w > floor(maxInt / baseMinusT) && error("overflow"), w *= baseMinusT;
                        out = output.length + 1, bias = adapt(i - oldi, out, 0 == oldi), floor(i / out) > maxInt - n && error("overflow"), n += floor(i / out), i %= out, output.splice(i++, 0, n)
                    }
                    return ucs2encode(output)
                }

                function encode(input) {
                    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, inputLength, handledCPCountPlusOne, baseMinusT, qMinusT, output = [];
                    for (input = ucs2decode(input), inputLength = input.length, n = initialN, delta = 0, bias = initialBias, j = 0; inputLength > j; ++j)currentValue = input[j], 128 > currentValue && output.push(stringFromCharCode(currentValue));
                    for (handledCPCount = basicLength = output.length, basicLength && output.push(delimiter); inputLength > handledCPCount;) {
                        for (m = maxInt, j = 0; inputLength > j; ++j)currentValue = input[j], currentValue >= n && m > currentValue && (m = currentValue);
                        for (handledCPCountPlusOne = handledCPCount + 1, m - n > floor((maxInt - delta) / handledCPCountPlusOne) && error("overflow"), delta += (m - n) * handledCPCountPlusOne, n = m, j = 0; inputLength > j; ++j)if (currentValue = input[j], n > currentValue && ++delta > maxInt && error("overflow"), currentValue == n) {
                            for (q = delta, k = base; t = bias >= k ? tMin : k >= bias + tMax ? tMax : k - bias, !(t > q); k += base)qMinusT = q - t, baseMinusT = base - t, output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), q = floor(qMinusT / baseMinusT);
                            output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength), delta = 0, ++handledCPCount
                        }
                        ++delta, ++n
                    }
                    return output.join("")
                }

                function toUnicode(input) {
                    return mapDomain(input, function (string) {
                        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string
                    })
                }

                function toASCII(input) {
                    return mapDomain(input, function (string) {
                        return regexNonASCII.test(string) ? "xn--" + encode(string) : string
                    })
                }

                var freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = "object" == typeof module && module && !module.nodeType && module, freeGlobal = "object" == typeof global && global;
                freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal && freeGlobal.self !== freeGlobal || (root = freeGlobal);
                var punycode, key, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                    overflow: "Overflow: input needs wider integers to process",
                    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                    "invalid-input": "Invalid input"
                }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode;
                if (punycode = {
                        version: "1.4.1",
                        ucs2: {decode: ucs2decode, encode: ucs2encode},
                        decode: decode,
                        encode: encode,
                        toASCII: toASCII,
                        toUnicode: toUnicode
                    }, "function" == typeof define && "object" == typeof define.amd && define.amd)define("punycode", function () {
                    return punycode
                }); else if (freeExports && freeModule)if (module.exports == freeExports)freeModule.exports = punycode; else for (key in punycode)punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]); else root.punycode = punycode
            }(this)
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    52: [function (require, module, exports) {
        "use strict";
        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop)
        }

        module.exports = function (qs, sep, eq, options) {
            sep = sep || "&", eq = eq || "=";
            var obj = {};
            if ("string" != typeof qs || 0 === qs.length)return obj;
            var regexp = /\+/g;
            qs = qs.split(sep);
            var maxKeys = 1e3;
            options && "number" == typeof options.maxKeys && (maxKeys = options.maxKeys);
            var len = qs.length;
            maxKeys > 0 && len > maxKeys && (len = maxKeys);
            for (var i = 0; len > i; ++i) {
                var kstr, vstr, k, v, x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq);
                idx >= 0 ? (kstr = x.substr(0, idx), vstr = x.substr(idx + 1)) : (kstr = x, vstr = ""), k = decodeURIComponent(kstr), v = decodeURIComponent(vstr), hasOwnProperty(obj, k) ? isArray(obj[k]) ? obj[k].push(v) : obj[k] = [obj[k], v] : obj[k] = v
            }
            return obj
        };
        var isArray = Array.isArray || function (xs) {
                return "[object Array]" === Object.prototype.toString.call(xs)
            }
    }, {}],
    53: [function (require, module, exports) {
        "use strict";
        function map(xs, f) {
            if (xs.map)return xs.map(f);
            for (var res = [], i = 0; i < xs.length; i++)res.push(f(xs[i], i));
            return res
        }

        var stringifyPrimitive = function (v) {
            switch (typeof v) {
                case"string":
                    return v;
                case"boolean":
                    return v ? "true" : "false";
                case"number":
                    return isFinite(v) ? v : "";
                default:
                    return ""
            }
        };
        module.exports = function (obj, sep, eq, name) {
            return sep = sep || "&", eq = eq || "=", null === obj && (obj = void 0), "object" == typeof obj ? map(objectKeys(obj), function (k) {
                var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                return isArray(obj[k]) ? map(obj[k], function (v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v))
                }).join(sep) : ks + encodeURIComponent(stringifyPrimitive(obj[k]))
            }).join(sep) : name ? encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj)) : ""
        };
        var isArray = Array.isArray || function (xs) {
                return "[object Array]" === Object.prototype.toString.call(xs)
            }, objectKeys = Object.keys || function (obj) {
                var res = [];
                for (var key in obj)Object.prototype.hasOwnProperty.call(obj, key) && res.push(key);
                return res
            }
    }, {}],
    54: [function (require, module, exports) {
        "use strict";
        exports.decode = exports.parse = require("./decode"), exports.encode = exports.stringify = require("./encode")
    }, {"./decode": 52, "./encode": 53}],
    55: [function (require, module, exports) {
        "use strict";
        function Url() {
            this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
        }

        function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && util.isObject(url) && url instanceof Url)return url;
            var u = new Url;
            return u.parse(url, parseQueryString, slashesDenoteHost), u
        }

        function urlFormat(obj) {
            return util.isString(obj) && (obj = urlParse(obj)), obj instanceof Url ? obj.format() : Url.prototype.format.call(obj)
        }

        function urlResolve(source, relative) {
            return urlParse(source, !1, !0).resolve(relative)
        }

        function urlResolveObject(source, relative) {
            return source ? urlParse(source, !1, !0).resolveObject(relative) : relative
        }

        var punycode = require("punycode"), util = require("./util");
        exports.parse = urlParse, exports.resolve = urlResolve, exports.resolveObject = urlResolveObject, exports.format = urlFormat, exports.Url = Url;
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
            javascript: !0,
            "javascript:": !0
        }, hostlessProtocol = {javascript: !0, "javascript:": !0}, slashedProtocol = {
            http: !0,
            https: !0,
            ftp: !0,
            gopher: !0,
            file: !0,
            "http:": !0,
            "https:": !0,
            "ftp:": !0,
            "gopher:": !0,
            "file:": !0
        }, querystring = require("querystring");
        Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
            if (!util.isString(url))throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
            var queryIndex = url.indexOf("?"), splitter = -1 !== queryIndex && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
            uSplit[0] = uSplit[0].replace(slashRegex, "/"), url = uSplit.join(splitter);
            var rest = url;
            if (rest = rest.trim(), !slashesDenoteHost && 1 === url.split("#").length) {
                var simplePath = simplePathPattern.exec(rest);
                if (simplePath)return this.path = rest, this.href = rest, this.pathname = simplePath[1], simplePath[2] ? (this.search = simplePath[2], parseQueryString ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : parseQueryString && (this.search = "", this.query = {}), this
            }
            var proto = protocolPattern.exec(rest);
            if (proto) {
                proto = proto[0];
                var lowerProto = proto.toLowerCase();
                this.protocol = lowerProto, rest = rest.substr(proto.length)
            }
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                var slashes = "//" === rest.substr(0, 2);
                !slashes || proto && hostlessProtocol[proto] || (rest = rest.substr(2), this.slashes = !0)
            }
            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                for (var hostEnd = -1, i = 0; i < hostEndingChars.length; i++) {
                    var hec = rest.indexOf(hostEndingChars[i]);
                    -1 !== hec && (-1 === hostEnd || hostEnd > hec) && (hostEnd = hec)
                }
                var auth, atSign;
                atSign = -1 === hostEnd ? rest.lastIndexOf("@") : rest.lastIndexOf("@", hostEnd), -1 !== atSign && (auth = rest.slice(0, atSign), rest = rest.slice(atSign + 1), this.auth = decodeURIComponent(auth)), hostEnd = -1;
                for (var i = 0; i < nonHostChars.length; i++) {
                    var hec = rest.indexOf(nonHostChars[i]);
                    -1 !== hec && (-1 === hostEnd || hostEnd > hec) && (hostEnd = hec)
                }
                -1 === hostEnd && (hostEnd = rest.length), this.host = rest.slice(0, hostEnd), rest = rest.slice(hostEnd), this.parseHost(), this.hostname = this.hostname || "";
                var ipv6Hostname = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
                if (!ipv6Hostname)for (var hostparts = this.hostname.split(/\./), i = 0, l = hostparts.length; l > i; i++) {
                    var part = hostparts[i];
                    if (part && !part.match(hostnamePartPattern)) {
                        for (var newpart = "", j = 0, k = part.length; k > j; j++)newpart += part.charCodeAt(j) > 127 ? "x" : part[j];
                        if (!newpart.match(hostnamePartPattern)) {
                            var validParts = hostparts.slice(0, i), notHost = hostparts.slice(i + 1), bit = part.match(hostnamePartStart);
                            bit && (validParts.push(bit[1]), notHost.unshift(bit[2])), notHost.length && (rest = "/" + notHost.join(".") + rest), this.hostname = validParts.join(".");
                            break
                        }
                    }
                }
                this.hostname.length > hostnameMaxLen ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), ipv6Hostname || (this.hostname = punycode.toASCII(this.hostname));
                var p = this.port ? ":" + this.port : "", h = this.hostname || "";
                this.host = h + p, this.href += this.host, ipv6Hostname && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== rest[0] && (rest = "/" + rest))
            }
            if (!unsafeProtocol[lowerProto])for (var i = 0, l = autoEscape.length; l > i; i++) {
                var ae = autoEscape[i];
                if (-1 !== rest.indexOf(ae)) {
                    var esc = encodeURIComponent(ae);
                    esc === ae && (esc = escape(ae)), rest = rest.split(ae).join(esc)
                }
            }
            var hash = rest.indexOf("#");
            -1 !== hash && (this.hash = rest.substr(hash), rest = rest.slice(0, hash));
            var qm = rest.indexOf("?");
            if (-1 !== qm ? (this.search = rest.substr(qm), this.query = rest.substr(qm + 1), parseQueryString && (this.query = querystring.parse(this.query)), rest = rest.slice(0, qm)) : parseQueryString && (this.search = "", this.query = {}), rest && (this.pathname = rest), slashedProtocol[lowerProto] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
                var p = this.pathname || "", s = this.search || "";
                this.path = p + s
            }
            return this.href = this.format(), this
        }, Url.prototype.format = function () {
            var auth = this.auth || "";
            auth && (auth = encodeURIComponent(auth), auth = auth.replace(/%3A/i, ":"), auth += "@");
            var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = !1, query = "";
            this.host ? host = auth + this.host : this.hostname && (host = auth + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (host += ":" + this.port)), this.query && util.isObject(this.query) && Object.keys(this.query).length && (query = querystring.stringify(this.query));
            var search = this.search || query && "?" + query || "";
            return protocol && ":" !== protocol.substr(-1) && (protocol += ":"), this.slashes || (!protocol || slashedProtocol[protocol]) && host !== !1 ? (host = "//" + (host || ""), pathname && "/" !== pathname.charAt(0) && (pathname = "/" + pathname)) : host || (host = ""), hash && "#" !== hash.charAt(0) && (hash = "#" + hash), search && "?" !== search.charAt(0) && (search = "?" + search), pathname = pathname.replace(/[?#]/g, function (match) {
                return encodeURIComponent(match)
            }), search = search.replace("#", "%23"), protocol + host + pathname + search + hash
        }, Url.prototype.resolve = function (relative) {
            return this.resolveObject(urlParse(relative, !1, !0)).format()
        }, Url.prototype.resolveObject = function (relative) {
            if (util.isString(relative)) {
                var rel = new Url;
                rel.parse(relative, !1, !0), relative = rel
            }
            for (var result = new Url, tkeys = Object.keys(this), tk = 0; tk < tkeys.length; tk++) {
                var tkey = tkeys[tk];
                result[tkey] = this[tkey]
            }
            if (result.hash = relative.hash, "" === relative.href)return result.href = result.format(), result;
            if (relative.slashes && !relative.protocol) {
                for (var rkeys = Object.keys(relative), rk = 0; rk < rkeys.length; rk++) {
                    var rkey = rkeys[rk];
                    "protocol" !== rkey && (result[rkey] = relative[rkey])
                }
                return slashedProtocol[result.protocol] && result.hostname && !result.pathname && (result.path = result.pathname = "/"), result.href = result.format(), result
            }
            if (relative.protocol && relative.protocol !== result.protocol) {
                if (!slashedProtocol[relative.protocol]) {
                    for (var keys = Object.keys(relative), v = 0; v < keys.length; v++) {
                        var k = keys[v];
                        result[k] = relative[k]
                    }
                    return result.href = result.format(), result
                }
                if (result.protocol = relative.protocol, relative.host || hostlessProtocol[relative.protocol])result.pathname = relative.pathname; else {
                    for (var relPath = (relative.pathname || "").split("/"); relPath.length && !(relative.host = relPath.shift()););
                    relative.host || (relative.host = ""), relative.hostname || (relative.hostname = ""), "" !== relPath[0] && relPath.unshift(""), relPath.length < 2 && relPath.unshift(""), result.pathname = relPath.join("/")
                }
                if (result.search = relative.search, result.query = relative.query, result.host = relative.host || "", result.auth = relative.auth, result.hostname = relative.hostname || relative.host, result.port = relative.port, result.pathname || result.search) {
                    var p = result.pathname || "", s = result.search || "";
                    result.path = p + s
                }
                return result.slashes = result.slashes || relative.slashes, result.href = result.format(), result
            }
            var isSourceAbs = result.pathname && "/" === result.pathname.charAt(0), isRelAbs = relative.host || relative.pathname && "/" === relative.pathname.charAt(0), mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
            if (psychotic && (result.hostname = "", result.port = null, result.host && ("" === srcPath[0] ? srcPath[0] = result.host : srcPath.unshift(result.host)), result.host = "", relative.protocol && (relative.hostname = null, relative.port = null, relative.host && ("" === relPath[0] ? relPath[0] = relative.host : relPath.unshift(relative.host)), relative.host = null), mustEndAbs = mustEndAbs && ("" === relPath[0] || "" === srcPath[0])), isRelAbs)result.host = relative.host || "" === relative.host ? relative.host : result.host, result.hostname = relative.hostname || "" === relative.hostname ? relative.hostname : result.hostname, result.search = relative.search, result.query = relative.query, srcPath = relPath; else if (relPath.length)srcPath || (srcPath = []), srcPath.pop(), srcPath = srcPath.concat(relPath), result.search = relative.search, result.query = relative.query; else if (!util.isNullOrUndefined(relative.search)) {
                if (psychotic) {
                    result.hostname = result.host = srcPath.shift();
                    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : !1;
                    authInHost && (result.auth = authInHost.shift(), result.host = result.hostname = authInHost.shift())
                }
                return result.search = relative.search, result.query = relative.query, util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")), result.href = result.format(), result
            }
            if (!srcPath.length)return result.pathname = null, result.search ? result.path = "/" + result.search : result.path = null, result.href = result.format(), result;
            for (var last = srcPath.slice(-1)[0], hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && ("." === last || ".." === last) || "" === last, up = 0, i = srcPath.length; i >= 0; i--)last = srcPath[i], "." === last ? srcPath.splice(i, 1) : ".." === last ? (srcPath.splice(i, 1), up++) : up && (srcPath.splice(i, 1), up--);
            if (!mustEndAbs && !removeAllDots)for (; up--; up)srcPath.unshift("..");
            !mustEndAbs || "" === srcPath[0] || srcPath[0] && "/" === srcPath[0].charAt(0) || srcPath.unshift(""), hasTrailingSlash && "/" !== srcPath.join("/").substr(-1) && srcPath.push("");
            var isAbsolute = "" === srcPath[0] || srcPath[0] && "/" === srcPath[0].charAt(0);
            if (psychotic) {
                result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
                var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : !1;
                authInHost && (result.auth = authInHost.shift(), result.host = result.hostname = authInHost.shift())
            }
            return mustEndAbs = mustEndAbs || result.host && srcPath.length, mustEndAbs && !isAbsolute && srcPath.unshift(""), srcPath.length ? result.pathname = srcPath.join("/") : (result.pathname = null, result.path = null), util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")), result.auth = relative.auth || result.auth, result.slashes = result.slashes || relative.slashes, result.href = result.format(), result
        }, Url.prototype.parseHost = function () {
            var host = this.host, port = portPattern.exec(host);
            port && (port = port[0], ":" !== port && (this.port = port.substr(1)), host = host.substr(0, host.length - port.length)), host && (this.hostname = host)
        }
    }, {"./util": 56, punycode: 51, querystring: 54}],
    56: [function (require, module, exports) {
        "use strict";
        module.exports = {
            isString: function (arg) {
                return "string" == typeof arg
            }, isObject: function (arg) {
                return "object" == typeof arg && null !== arg
            }, isNull: function (arg) {
                return null === arg
            }, isNullOrUndefined: function (arg) {
                return null == arg
            }
        }
    }, {}],
    57: [function (require, module, exports) {
        module.exports = function (arg) {
            return arg && "object" == typeof arg && "function" == typeof arg.copy && "function" == typeof arg.fill && "function" == typeof arg.readUInt8
        }
    }, {}],
    58: [function (require, module, exports) {
        (function (process, global) {
            function inspect(obj, opts) {
                var ctx = {seen: [], stylize: stylizeNoColor};
                return arguments.length >= 3 && (ctx.depth = arguments[2]), arguments.length >= 4 && (ctx.colors = arguments[3]), isBoolean(opts) ? ctx.showHidden = opts : opts && exports._extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = !1), isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = !1), isUndefined(ctx.customInspect) && (ctx.customInspect = !0), ctx.colors && (ctx.stylize = stylizeWithColor), formatValue(ctx, obj, ctx.depth)
            }

            function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType];
                return style ? "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m" : str
            }

            function stylizeNoColor(str, styleType) {
                return str
            }

            function arrayToHash(array) {
                var hash = {};
                return array.forEach(function (val, idx) {
                    hash[val] = !0
                }), hash
            }

            function formatValue(ctx, value, recurseTimes) {
                if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && (!value.constructor || value.constructor.prototype !== value)) {
                    var ret = value.inspect(recurseTimes, ctx);
                    return isString(ret) || (ret = formatValue(ctx, ret, recurseTimes)), ret
                }
                var primitive = formatPrimitive(ctx, value);
                if (primitive)return primitive;
                var keys = Object.keys(value), visibleKeys = arrayToHash(keys);
                if (ctx.showHidden && (keys = Object.getOwnPropertyNames(value)), isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0))return formatError(value);
                if (0 === keys.length) {
                    if (isFunction(value)) {
                        var name = value.name ? ": " + value.name : "";
                        return ctx.stylize("[Function" + name + "]", "special")
                    }
                    if (isRegExp(value))return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                    if (isDate(value))return ctx.stylize(Date.prototype.toString.call(value), "date");
                    if (isError(value))return formatError(value)
                }
                var base = "", array = !1, braces = ["{", "}"];
                if (isArray(value) && (array = !0, braces = ["[", "]"]), isFunction(value)) {
                    var n = value.name ? ": " + value.name : "";
                    base = " [Function" + n + "]"
                }
                if (isRegExp(value) && (base = " " + RegExp.prototype.toString.call(value)), isDate(value) && (base = " " + Date.prototype.toUTCString.call(value)), isError(value) && (base = " " + formatError(value)), 0 === keys.length && (!array || 0 == value.length))return braces[0] + base + braces[1];
                if (0 > recurseTimes)return isRegExp(value) ? ctx.stylize(RegExp.prototype.toString.call(value), "regexp") : ctx.stylize("[Object]", "special");
                ctx.seen.push(value);
                var output;
                return output = array ? formatArray(ctx, value, recurseTimes, visibleKeys, keys) : keys.map(function (key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array)
                }), ctx.seen.pop(), reduceToSingleString(output, base, braces)
            }

            function formatPrimitive(ctx, value) {
                if (isUndefined(value))return ctx.stylize("undefined", "undefined");
                if (isString(value)) {
                    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                    return ctx.stylize(simple, "string")
                }
                return isNumber(value) ? ctx.stylize("" + value, "number") : isBoolean(value) ? ctx.stylize("" + value, "boolean") : isNull(value) ? ctx.stylize("null", "null") : void 0
            }

            function formatError(value) {
                return "[" + Error.prototype.toString.call(value) + "]"
            }

            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                for (var output = [], i = 0, l = value.length; l > i; ++i)hasOwnProperty(value, String(i)) ? output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0)) : output.push("");
                return keys.forEach(function (key) {
                    key.match(/^\d+$/) || output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0))
                }), output
            }

            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                var name, str, desc;
                if (desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]}, desc.get ? str = desc.set ? ctx.stylize("[Getter/Setter]", "special") : ctx.stylize("[Getter]", "special") : desc.set && (str = ctx.stylize("[Setter]", "special")), hasOwnProperty(visibleKeys, key) || (name = "[" + key + "]"), str || (ctx.seen.indexOf(desc.value) < 0 ? (str = isNull(recurseTimes) ? formatValue(ctx, desc.value, null) : formatValue(ctx, desc.value, recurseTimes - 1), str.indexOf("\n") > -1 && (str = array ? str.split("\n").map(function (line) {
                        return "  " + line
                    }).join("\n").substr(2) : "\n" + str.split("\n").map(function (line) {
                        return "   " + line
                    }).join("\n"))) : str = ctx.stylize("[Circular]", "special")), isUndefined(name)) {
                    if (array && key.match(/^\d+$/))return str;
                    name = JSON.stringify("" + key), name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name = name.substr(1, name.length - 2), name = ctx.stylize(name, "name")) : (name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name = ctx.stylize(name, "string"))
                }
                return name + ": " + str
            }

            function reduceToSingleString(output, base, braces) {
                var numLinesEst = 0, length = output.reduce(function (prev, cur) {
                    return numLinesEst++, cur.indexOf("\n") >= 0 && numLinesEst++, prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1
                }, 0);
                return length > 60 ? braces[0] + ("" === base ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1] : braces[0] + base + " " + output.join(", ") + " " + braces[1]
            }

            function isArray(ar) {
                return Array.isArray(ar)
            }

            function isBoolean(arg) {
                return "boolean" == typeof arg
            }

            function isNull(arg) {
                return null === arg
            }

            function isNullOrUndefined(arg) {
                return null == arg
            }

            function isNumber(arg) {
                return "number" == typeof arg
            }

            function isString(arg) {
                return "string" == typeof arg
            }

            function isSymbol(arg) {
                return "symbol" == typeof arg
            }

            function isUndefined(arg) {
                return void 0 === arg
            }

            function isRegExp(re) {
                return isObject(re) && "[object RegExp]" === objectToString(re)
            }

            function isObject(arg) {
                return "object" == typeof arg && null !== arg
            }

            function isDate(d) {
                return isObject(d) && "[object Date]" === objectToString(d)
            }

            function isError(e) {
                return isObject(e) && ("[object Error]" === objectToString(e) || e instanceof Error)
            }

            function isFunction(arg) {
                return "function" == typeof arg
            }

            function isPrimitive(arg) {
                return null === arg || "boolean" == typeof arg || "number" == typeof arg || "string" == typeof arg || "symbol" == typeof arg || "undefined" == typeof arg
            }

            function objectToString(o) {
                return Object.prototype.toString.call(o)
            }

            function pad(n) {
                return 10 > n ? "0" + n.toString(10) : n.toString(10)
            }

            function timestamp() {
                var d = new Date, time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
                return [d.getDate(), months[d.getMonth()], time].join(" ")
            }

            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop)
            }

            var formatRegExp = /%[sdj%]/g;
            exports.format = function (f) {
                if (!isString(f)) {
                    for (var objects = [], i = 0; i < arguments.length; i++)objects.push(inspect(arguments[i]));
                    return objects.join(" ")
                }
                for (var i = 1, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function (x) {
                    if ("%%" === x)return "%";
                    if (i >= len)return x;
                    switch (x) {
                        case"%s":
                            return String(args[i++]);
                        case"%d":
                            return Number(args[i++]);
                        case"%j":
                            try {
                                return JSON.stringify(args[i++])
                            } catch (_) {
                                return "[Circular]"
                            }
                        default:
                            return x
                    }
                }), x = args[i]; len > i; x = args[++i])str += isNull(x) || !isObject(x) ? " " + x : " " + inspect(x);
                return str
            }, exports.deprecate = function (fn, msg) {
                function deprecated() {
                    if (!warned) {
                        if (process.throwDeprecation)throw new Error(msg);
                        process.traceDeprecation ? console.trace(msg) : console.error(msg), warned = !0
                    }
                    return fn.apply(this, arguments)
                }

                if (isUndefined(global.process))return function () {
                    return exports.deprecate(fn, msg).apply(this, arguments)
                };
                if (process.noDeprecation === !0)return fn;
                var warned = !1;
                return deprecated
            };
            var debugEnviron, debugs = {};
            exports.debuglog = function (set) {
                if (isUndefined(debugEnviron) && (debugEnviron = process.env.NODE_DEBUG || ""), set = set.toUpperCase(), !debugs[set])if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function () {
                        var msg = exports.format.apply(exports, arguments);
                        console.error("%s %d: %s", set, pid, msg)
                    }
                } else debugs[set] = function () {
                };
                return debugs[set]
            }, exports.inspect = inspect, inspect.colors = {
                bold: [1, 22],
                italic: [3, 23],
                underline: [4, 24],
                inverse: [7, 27],
                white: [37, 39],
                grey: [90, 39],
                black: [30, 39],
                blue: [34, 39],
                cyan: [36, 39],
                green: [32, 39],
                magenta: [35, 39],
                red: [31, 39],
                yellow: [33, 39]
            }, inspect.styles = {
                special: "cyan",
                number: "yellow",
                "boolean": "yellow",
                undefined: "grey",
                "null": "bold",
                string: "green",
                date: "magenta",
                regexp: "red"
            }, exports.isArray = isArray, exports.isBoolean = isBoolean, exports.isNull = isNull, exports.isNullOrUndefined = isNullOrUndefined, exports.isNumber = isNumber, exports.isString = isString, exports.isSymbol = isSymbol, exports.isUndefined = isUndefined, exports.isRegExp = isRegExp, exports.isObject = isObject, exports.isDate = isDate, exports.isError = isError, exports.isFunction = isFunction, exports.isPrimitive = isPrimitive, exports.isBuffer = require("./support/isBuffer");
            var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            exports.log = function () {
                console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments))
            }, exports.inherits = require("inherits"), exports._extend = function (origin, add) {
                if (!add || !isObject(add))return origin;
                for (var keys = Object.keys(add), i = keys.length; i--;)origin[keys[i]] = add[keys[i]];
                return origin
            }
        }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {"./support/isBuffer": 57, _process: 48, inherits: 41}],
    59: [function (require, module, exports) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")
        }

        Object.defineProperty(exports, "__esModule", {value: !0});
        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                }
            }

            return function (Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
            }
        }(), Image = function () {
            function Image(imageTransformer, indexedImage) {
                _classCallCheck(this, Image), this.url = imageTransformer.transformedUrl(indexedImage._id), this.title = indexedImage._source.title, this.alt = indexedImage._source.altText, this.credit = indexedImage._source.credit, this.linkBack = indexedImage._source.linkBack, this.owner = indexedImage._source.owner
            }

            return _createClass(Image, [{
                key: "description", value: function () {
                    return this.shouldCredit() ? this.credit : this.shouldLinkBack() ? 'Taken by <a href="' + this.linkBack + '" target="_blank">' + this.owner + "</a>" : ""
                }
            }, {
                key: "shouldCredit", value: function () {
                    return void 0 !== this.credit
                }
            }, {
                key: "shouldLinkBack", value: function () {
                    return void 0 !== this.owner
                }
            }, {
                key: "toHtml", value: function () {
                    return '<li data-thumb="' + this.url + '"><img src="' + this.url + '" alt="' + this.alt + '"/><p class="image-description"><strong>' + this.title + '</strong></p><p class="image-description">' + this.description() + "</p></li>"
                }
            }]), Image
        }();
        exports["default"] = Image
    }, {}],
    60: [function (require, module, exports) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")
        }

        Object.defineProperty(exports, "__esModule", {value: !0});
        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                }
            }

            return function (Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
            }
        }(), _elasticsearch = require("elasticsearch"), ImageIndex = function () {
            function ImageIndex(host) {
                _classCallCheck(this, ImageIndex), this.client = new _elasticsearch.Client({host: host})
            }

            return _createClass(ImageIndex, [{
                key: "search", value: function (tags) {
                    var terms = tags.map(function (tag) {
                        return {term: {keywords: tag}}
                    });
                    return this.client.search({
                        index: "images",
                        type: "image",
                        body: {query: {constant_score: {filter: {and: terms}}}}
                    }).then(function (resp) {
                        return resp.hits.hits
                    })
                }
            }]), ImageIndex
        }();
        exports["default"] = ImageIndex
    }, {elasticsearch: 5}],
    61: [function (require, module, exports) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")
        }

        Object.defineProperty(exports, "__esModule", {value: !0});
        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                }
            }

            return function (Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
            }
        }(), _cloudinaryCore = require("cloudinary-core"), ImageTransformer = function () {
            function ImageTransformer(cloudName, options) {
                _classCallCheck(this, ImageTransformer), this.cloudinary = _cloudinaryCore.Cloudinary["new"]({cloud_name: cloudName}), this.options = options
            }

            return _createClass(ImageTransformer, [{
                key: "transformedUrl", value: function (id) {
                    return this.cloudinary.url(id, this.options)
                }
            }]), ImageTransformer
        }();
        exports["default"] = ImageTransformer
    }, {"cloudinary-core": 4}],
    62: [function (require, module, exports) {
        (function (global) {
            "use strict";
            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {"default": obj}
            }

            function displayCarousel(elementSelector, _ref) {
                var indexHost = _ref.indexHost, searchTerms = _ref.searchTerms, cloudName = _ref.cloudName, transformationOptions = _ref.transformationOptions, imageIndex = new _ImageIndex2["default"](indexHost), hitsPromise = imageIndex.search(searchTerms), imageTransformer = new _ImageTransformer2["default"](cloudName, transformationOptions), div = (0, _jquery2["default"])(elementSelector);
                hitsPromise.then(function (hits) {
                    return hits.map(function (hit) {
                        return new _Image2["default"](imageTransformer, hit)
                    })
                }).then(function (images) {
                    return images.map(function (image) {
                        return image.toHtml()
                    })
                }).then(function (imageListItems) {
                    return imageListItems.join("")
                }).then(function (imagesHtml) {
                    return "<ul>" + imagesHtml + "</ul>"
                }).then(function (carouselHtml) {
                    var carousel = _jquery2["default"].parseHTML(carouselHtml);
                    div.append(carousel), (0, _jquery2["default"])(carousel).lightSlider({
                        gallery: !0,
                        item: 1,
                        loop: !0,
                        slideMargin: 0,
                        thumbItem: 5
                    })
                })
            }

            function changeWallpaper(_ref2) {
                var indexHost = _ref2.indexHost, searchTerms = _ref2.searchTerms, cloudName = _ref2.cloudName, transformationOptions = _ref2.transformationOptions, imageIndex = new _ImageIndex2["default"](indexHost), hitsPromise = imageIndex.search(searchTerms), imageTransformer = new _ImageTransformer2["default"](cloudName, transformationOptions);
                hitsPromise.then(function (hits) {
                    return hits.map(function (hit) {
                        return new _Image2["default"](imageTransformer, hit)
                    })
                }).then(function (images) {
                    return images[Math.floor(Math.random() * images.length)]
                }).then(function (image) {
                    (0, _jquery2["default"])("body").css("background-image", 'url("' + image.url + '")').css("background-size", "cover").css("background-attachment", "fixed")
                })
            }

            Object.defineProperty(exports, "__esModule", {value: !0}), exports.displayCarousel = displayCarousel, exports.changeWallpaper = changeWallpaper;
            var _ImageIndex = require("./ImageIndex"), _ImageIndex2 = _interopRequireDefault(_ImageIndex), _ImageTransformer = require("./ImageTransformer"), _ImageTransformer2 = _interopRequireDefault(_ImageTransformer), _Image = require("./Image"), _Image2 = _interopRequireDefault(_Image), _jquery = "undefined" != typeof window ? window.jQuery : "undefined" != typeof global ? global.jQuery : null, _jquery2 = _interopRequireDefault(_jquery);
            require("lightslider"), window.indexedCloudinary = {
                displayCarousel: displayCarousel,
                changeWallpaper: changeWallpaper
            }
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {"./Image": 59, "./ImageIndex": 60, "./ImageTransformer": 61, lightslider: 44}]
}, {}, [62]);